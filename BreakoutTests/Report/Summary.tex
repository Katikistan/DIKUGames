\documentclass[a4paper,landscape,10pt]{article}
\usepackage[paper=a4paper,landscape,left=20mm,right=20mm,top=20mm,bottom=20mm]{geometry}
\usepackage{longtable}
\usepackage{fancyhdr}
\usepackage[pdftex]{color}
\usepackage{colortbl}
\definecolor{green}{rgb}{0.04,0.68,0.04}
\definecolor{orange}{rgb}{0.97,0.65,0.12}
\definecolor{red}{rgb}{0.75,0.04,0.04}
\definecolor{gray}{rgb}{0.86,0.86,0.86}

\usepackage[pdftex,
            colorlinks=true, linkcolor=red, urlcolor=green, citecolor=red,%
            raiselinks=true,%
            bookmarks=true,%
            bookmarksopenlevel=1,%
            bookmarksopen=true,%
            bookmarksnumbered=true,%
            hyperindex=true,% 
            plainpages=false,% correct hyperlinks
            pdfpagelabels=true%,% view TeX pagenumber in PDF reader
            %pdfborder={0 0 0.5}
            ]{hyperref}

\hypersetup{pdftitle={Coverage Report},
            pdfauthor={ReportGenerator - 5.1.21.0}
           }

\pagestyle{fancy}
\fancyhead[LE,LO]{\leftmark}
\fancyhead[R]{\thepage}
\fancyfoot[C]{ReportGenerator - 5.1.21.0}

\begin{document}

\setcounter{secnumdepth}{-1}
\section{Summary}
\begin{longtable}[l]{ll}
\textbf{Generated on:} & 06/06/2023 - 12.00.18\\
\textbf{Coverage date:} & 06/06/2023 - 11.59.12\\
\textbf{Parser:} & Cobertura\\
\textbf{Assemblies:} & 2\\
\textbf{Classes:} & 82\\
\textbf{Files:} & 82\\
\textbf{Covered lines:} & 1598\\
\textbf{Uncovered lines:} & 1760\\
\textbf{Coverable lines:} & 3358\\
\textbf{Total lines:} & 6092\\
\textbf{Line coverage:} & 47.5\% (1598 of 3358)\\
\textbf{Covered branches:} & 383\\
\textbf{Total branches:} & 995\\
\textbf{Branch coverage:} & 38.4\% (383 of 995)\\
\textbf{Covered methods:} & 220\\
\textbf{Total methods:} & 531\\
\textbf{Method coverage:} & 41.4\% (220 of 531)\\
\end{longtable}
\section{Risk Hotspots}
\begin{longtable}[l]{|l|l|l|r|}
\hline
\textbf{Assembly} & \textbf{Class} & \textbf{Method} & \textbf{Cyclomatic complexity}\\
\hline
DIKUArcade & DIKUArcade.Input.Languages.DanishKeyTransformer & TransformKey(...) & \textcolor{red}{194}\\
\hline
DIKUArcade & DIKUArcade.Physics.CollisionDetection & Aabb(...) & \textcolor{red}{48}\\
\hline
Breakout & Breakout.Players.Player & ProcessEvent(...) & \textcolor{red}{46}\\
\hline
\end{longtable}
\section{Coverage}
\begin{longtable}[l]{|l|r|r|r|r|r|r|r|}
\hline
\textbf{Name} & \textbf{Covered} & \textbf{Uncovered} & \textbf{Coverable} & \textbf{Total} & \textbf{Line coverage} & \textbf{Branch coverage} & \textbf{Method coverage}\\
\hline
\textbf{Breakout} & \textbf{1152} & \textbf{117} & \textbf{1269} & \textbf{2176} & \textbf{90.7\%} & \textbf{95.3\%} & \textbf{87.1\%}\\
\hline
Breakout.Balls.Ball & 9 & 3 & 12 & 32 & 75\% &  & 75\%\\
\hline
Breakout.Balls.BallCreator & 7 & 0 & 7 & 20 & 100\% &  & 100\%\\
\hline
Breakout.Blocks.Block & 19 & 3 & 22 & 46 & 86.3\% &  & 80\%\\
\hline
Breakout.Blocks.BlockCreator & 7 & 0 & 7 & 25 & 100\% & 100\% & 100\%\\
\hline
Breakout.Blocks.DefaultBlock & 9 & 0 & 9 & 21 & 100\% & 100\% & 100\%\\
\hline
Breakout.Blocks.Hardened & 15 & 1 & 16 & 31 & 93.7\% & 83.3\% & 100\%\\
\hline
Breakout.Blocks.PowerupBlock & 14 & 0 & 14 & 26 & 100\% & 100\% & 100\%\\
\hline
Breakout.Blocks.Unbreakable & 5 & 0 & 5 & 16 & 100\% &  & 100\%\\
\hline
Breakout.BreakoutBus & 14 & 0 & 14 & 27 & 100\% & 100\% & 100\%\\
\hline
Breakout.Collisions.BlockCollision & 38 & 0 & 38 & 53 & 100\% & 100\% & 100\%\\
\hline
Breakout.Collisions.PlayerCollision & 33 & 0 & 33 & 56 & 100\% & 100\% & 100\%\\
\hline
Breakout.Collisions.PowerUpCollision & 13 & 0 & 13 & 27 & 100\% & 100\% & 100\%\\
\hline
Breakout.Collisions.WallCollision & 38 & 0 & 38 & 53 & 100\% & 100\% & 100\%\\
\hline
Breakout.Constants & 2 & 0 & 2 & 11 & 100\% &  & 100\%\\
\hline
Breakout.Game & 0 & 24 & 24 & 49 & 0\% & 0\% & 0\%\\
\hline
Breakout.Health & 31 & 3 & 34 & 59 & 91.1\% & 100\% & 80\%\\
\hline
Breakout.Levels.LevelCreator & 53 & 0 & 53 & 90 & 100\% & 91.6\% & 100\%\\
\hline
Breakout.Levels.LevelManager & 87 & 12 & 99 & 159 & 87.8\% & 86.6\% & 93.7\%\\
\hline
Breakout.Levels.LevelReader & 76 & 0 & 76 & 111 & 100\% & 93.7\% & 100\%\\
\hline
Breakout.Players.Player & 70 & 6 & 76 & 112 & 92.1\% & 100\% & 80\%\\
\hline
Breakout.Points & 31 & 3 & 34 & 66 & 91.1\% & 100\% & 85.7\%\\
\hline
Breakout.Powerups.HardBall & 15 & 0 & 15 & 27 & 100\% &  & 100\%\\
\hline
Breakout.Powerups.LifeLoss & 9 & 0 & 9 & 19 & 100\% &  & 100\%\\
\hline
Breakout.Powerups.LifePlus & 10 & 0 & 10 & 21 & 100\% &  & 100\%\\
\hline
Breakout.Powerups.PlayerSpeed & 15 & 0 & 15 & 27 & 100\% &  & 100\%\\
\hline
Breakout.Powerups.Powerup & 8 & 0 & 8 & 23 & 100\% & 100\% & 100\%\\
\hline
Breakout.Powerups.PowerUpCreator & 34 & 0 & 34 & 56 & 100\% & 100\% & 100\%\\
\hline
Breakout.Powerups.SlimJim & 15 & 0 & 15 & 27 & 100\% &  & 100\%\\
\hline
Breakout.Powerups.Split & 9 & 0 & 9 & 19 & 100\% &  & 100\%\\
\hline
Breakout.Powerups.Wide & 15 & 0 & 15 & 27 & 100\% &  & 100\%\\
\hline
Breakout.Program & 0 & 5 & 5 & 9 & 0\% &  & 0\%\\
\hline
Breakout.States.GameLost & 74 & 15 & 89 & 139 & 83.1\% & 91.6\% & 77.7\%\\
\hline
Breakout.States.GamePaused & 73 & 8 & 81 & 129 & 90.1\% & 100\% & 81.8\%\\
\hline
Breakout.States.GameRunning & 98 & 6 & 104 & 167 & 94.2\% & 100\% & 93.3\%\\
\hline
Breakout.States.GameWon & 75 & 15 & 90 & 138 & 83.3\% & 91.6\% & 77.7\%\\
\hline
Breakout.States.MainMenu & 57 & 13 & 70 & 114 & 81.4\% & 91.6\% & 80\%\\
\hline
Breakout.States.StateMachine & 29 & 0 & 29 & 54 & 100\% & 100\% & 100\%\\
\hline
Breakout.States.StateTransformer & 9 & 0 & 9 & 27 & 100\% & 100\% & 100\%\\
\hline
Breakout.Timer & 36 & 0 & 36 & 63 & 100\% & 100\% & 100\%\\
\hline
\textbf{DIKUArcade} & \textbf{446} & \textbf{1643} & \textbf{2089} & \textbf{3916} & \textbf{21.3\%} & \textbf{10.8\%} & \textbf{19.7\%}\\
\hline
DIKUArcade.DIKUGame & 0 & 32 & 32 & 73 & 0\% & 0\% & 0\%\\
\hline
DIKUArcade.Entities.DynamicShape & 21 & 7 & 28 & 51 & 75\% &  & 71.4\%\\
\hline
DIKUArcade.Entities.Entity & 13 & 6 & 19 & 40 & 68.4\% &  & 71.4\%\\
\hline
DIKUArcade.Entities.EntityContainer & 0 & 63 & 63 & 132 & 0\% & 0\% & 0\%\\
\hline
DIKUArcade.Entities.EntityContainer$<$T$>$ & 39 & 12 & 51 & 113 & 76.4\% & 75\% & 73.3\%\\
\hline
DIKUArcade.Entities.Shape & 6 & 55 & 61 & 114 & 9.8\% & 25\% & 15\%\\
\hline
DIKUArcade.Entities.StationaryShape & 4 & 7 & 11 & 23 & 36.3\% &  & 33.3\%\\
\hline
DIKUArcade.Events.GameEventBus & 86 & 88 & 174 & 285 & 49.4\% & 31.6\% & 57.8\%\\
\hline
DIKUArcade.Events.GameEventQueue$<$T$>$ & 17 & 13 & 30 & 97 & 56.6\% & 100\% & 41.6\%\\
\hline
DIKUArcade.Events.Generic.GameEventBus$<$T$>$ & 0 & 174 & 174 & 287 & 0\% & 0\% & 0\%\\
\hline
DIKUArcade.Events.Generic.TimedGameEvent$<$T$>$ & 0 & 13 & 13 & 46 & 0\% &  & 0\%\\
\hline
DIKUArcade.Events.TimedGameEvent & 9 & 4 & 13 & 43 & 69.2\% &  & 75\%\\
\hline
DIKUArcade.Graphics.Animation & 0 & 15 & 15 & 44 & 0\% &  & 0\%\\
\hline
DIKUArcade.Graphics.AnimationContainer & 0 & 40 & 40 & 72 & 0\% & 0\% & 0\%\\
\hline
DIKUArcade.Graphics.Camera & 0 & 12 & 12 & 26 & 0\% &  & 0\%\\
\hline
DIKUArcade.Graphics.ChaseCamera & 0 & 19 & 19 & 50 & 0\% & 0\% & 0\%\\
\hline
DIKUArcade.Graphics.DynamicCamera & 0 & 46 & 46 & 79 & 0\% & 0\% & 0\%\\
\hline
DIKUArcade.Graphics.FollowCamera & 0 & 13 & 13 & 23 & 0\% & 0\% & 0\%\\
\hline
DIKUArcade.Graphics.Image & 3 & 12 & 15 & 28 & 20\% &  & 20\%\\
\hline
DIKUArcade.Graphics.ImageStride & 0 & 87 & 87 & 191 & 0\% & 0\% & 0\%\\
\hline
DIKUArcade.Graphics.NoImage & 0 & 3 & 3 & 11 & 0\% &  & 0\%\\
\hline
DIKUArcade.Graphics.StaticCamera & 0 & 4 & 4 & 14 & 0\% &  & 0\%\\
\hline
DIKUArcade.Graphics.Text & 79 & 62 & 141 & 300 & 56\% & 7.6\% & 47\%\\
\hline
DIKUArcade.Graphics.Texture & 38 & 92 & 130 & 226 & 29.2\% & 21.4\% & 37.5\%\\
\hline
DIKUArcade.GUI.Window & 6 & 172 & 178 & 377 & 3.3\% & 0\% & 3.8\%\\
\hline
DIKUArcade.GUI.WindowArgs & 0 & 7 & 7 & 27 & 0\% &  & 0\%\\
\hline
DIKUArcade.Input.Languages.DanishKeyTransformer & 0 & 125 & 125 & 155 & 0\% & 0\% & 0\%\\
\hline
DIKUArcade.Math.Vec2D & 0 & 39 & 39 & 61 & 0\% &  & 0\%\\
\hline
DIKUArcade.Math.Vec2F & 8 & 37 & 45 & 70 & 17.7\% &  & 21.4\%\\
\hline
DIKUArcade.Math.Vec2I & 0 & 36 & 36 & 57 & 0\% &  & 0\%\\
\hline
DIKUArcade.Math.Vec3D & 0 & 38 & 38 & 60 & 0\% &  & 0\%\\
\hline
DIKUArcade.Math.Vec3F & 0 & 38 & 38 & 60 & 0\% &  & 0\%\\
\hline
DIKUArcade.Math.Vec3I & 5 & 33 & 38 & 60 & 13.1\% &  & 9\%\\
\hline
DIKUArcade.Math.Vec4D & 0 & 40 & 40 & 63 & 0\% &  & 0\%\\
\hline
DIKUArcade.Math.Vec4F & 0 & 40 & 40 & 63 & 0\% &  & 0\%\\
\hline
DIKUArcade.Math.Vec4I & 0 & 40 & 40 & 63 & 0\% &  & 0\%\\
\hline
DIKUArcade.Physics.CollisionData & 3 & 0 & 3 & 23 & 100\% &  & 100\%\\
\hline
DIKUArcade.Physics.CollisionDetection & 84 & 27 & 111 & 184 & 75.6\% & 68.7\% & 50\%\\
\hline
DIKUArcade.Timers.GameTimer & 0 & 57 & 57 & 100 & 0\% & 0\% & 0\%\\
\hline
DIKUArcade.Timers.StaticTimer & 8 & 21 & 29 & 59 & 27.5\% & 0\% & 28.5\%\\
\hline
DIKUArcade.Timers.TimePeriod & 8 & 8 & 16 & 30 & 50\% & 16.6\% & 60\%\\
\hline
DIKUArcade.Utilities.FileIO & 9 & 0 & 9 & 23 & 100\% & 100\% & 100\%\\
\hline
DIKUArcade.Utilities.RandomGenerator & 0 & 6 & 6 & 13 & 0\% & 0\% & 0\%\\
\hline
\end{longtable}
\newpage
\section{Breakout.Balls.Ball}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.Balls.Ball\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/Breakout/Ball/Ball.cs}\end{minipage} \\
\textbf{Covered lines:} & 9\\
\textbf{Uncovered lines:} & 3\\
\textbf{Coverable lines:} & 12\\
\textbf{Total lines:} & 32\\
\textbf{Line coverage:} & 75\% (9 of 12)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 3\\
\textbf{Total methods:} & 4\\
\textbf{Method coverage:} & 75\% (3 of 4)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{get\_\_Shape()} & 100\% & 1 & 100\%\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{Move()} & 100\% & 1 & 100\%\\
\hline
\textbf{Render()} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/Breakout/Ball/Ball.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~namespace Breakout.Balls;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~/// <summary>~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~/// A ball entity that can move.~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~/// Static collision classes can be used to detect collisions with the ball and objects~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~ /// </summary>~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~public class Ball : Entity {~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~    private DynamicShape shape;~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    public DynamicShape _Shape {~\\
\cellcolor{green} & 1122 & \verb~12~ & & \verb~        get {~\\
\cellcolor{green} & 1122 & \verb~13~ & & \verb~            return shape;~\\
\cellcolor{green} & 1122 & \verb~14~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~    }~\\
\cellcolor{green} & 592 & \verb~16~ & & \verb~    public Ball(DynamicShape shape, IBaseImage image) : base(shape, image) {~\\
\cellcolor{green} & 296 & \verb~17~ & & \verb~        this.shape = shape;~\\
\cellcolor{green} & 296 & \verb~18~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~    /// Moves the ball along it's directional vector contained in shape.~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 78 & \verb~22~ & & \verb~    public void Move() {~\\
\cellcolor{green} & 78 & \verb~23~ & & \verb~        shape.Move();~\\
\cellcolor{green} & 78 & \verb~24~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~26~ & & \verb~    public void Render() {~\\
\cellcolor{red} & 0 & \verb~27~ & & \verb~        this.RenderEntity();~\\
\cellcolor{red} & 0 & \verb~28~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~}~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~~\\
\cellcolor{gray} &  & \verb~32~ & & \verb~~\\
\end{longtable}
\newpage
\section{Breakout.Balls.BallCreator}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.Balls.BallCreator\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/Breakout/Ball/BallCreator.cs}\end{minipage} \\
\textbf{Covered lines:} & 7\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 7\\
\textbf{Total lines:} & 20\\
\textbf{Line coverage:} & 100\% (7 of 7)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 1\\
\textbf{Total methods:} & 1\\
\textbf{Method coverage:} & 100\% (1 of 1)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{CreateBall(...)} & 100\% & 1 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/Breakout/Ball/BallCreator.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~namespace Breakout.Balls;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~/// <summary>~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~///  Creates a ball entity~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~/// </summary>~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~public static class BallCreator {~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    ///  Creates a ball using a position and a directional vector~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 277 & \verb~13~ & & \verb~    public static Ball CreateBall(Vec2F pos, Vec2F dir) {~\\
\cellcolor{green} & 277 & \verb~14~ & & \verb~        return new Ball(new DynamicShape(~\\
\cellcolor{green} & 277 & \verb~15~ & & \verb~            pos,~\\
\cellcolor{green} & 277 & \verb~16~ & & \verb~            new Vec2F(0.03f, 0.03f),~\\
\cellcolor{green} & 277 & \verb~17~ & & \verb~            dir),~\\
\cellcolor{green} & 277 & \verb~18~ & & \verb~        new Image(Path.Combine("..", "Breakout", "Assets", "Images", "ball2.png")));~\\
\cellcolor{green} & 277 & \verb~19~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.Blocks.Block}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.Blocks.Block\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/Breakout/Blocks/Block.cs}\end{minipage} \\
\textbf{Covered lines:} & 19\\
\textbf{Uncovered lines:} & 3\\
\textbf{Coverable lines:} & 22\\
\textbf{Total lines:} & 46\\
\textbf{Line coverage:} & 86.3\% (19 of 22)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 4\\
\textbf{Total methods:} & 5\\
\textbf{Method coverage:} & 80\% (4 of 5)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{get\_Value()} & 100\% & 1 & 100\%\\
\hline
\textbf{get\_Health()} & 100\% & 1 & 100\%\\
\hline
\textbf{GivePoints()} & 100\% & 1 & 100\%\\
\hline
\textbf{Render()} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/Breakout/Blocks/Block.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Events;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~namespace Breakout.Blocks;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~/// <summary>~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~/// An abstract block type~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~/// </summary>~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~public abstract class Block : Entity {~\\
\cellcolor{green} & 4412 & \verb~11~ & & \verb~    protected int value = 10;~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~    /// Amount of points given to player when block is destroyed.~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~    public int Value {~\\
\cellcolor{green} & 4 & \verb~16~ & & \verb~        get {~\\
\cellcolor{green} & 4 & \verb~17~ & & \verb~            return value;~\\
\cellcolor{green} & 4 & \verb~18~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~    }~\\
\cellcolor{green} & 4412 & \verb~20~ & & \verb~    protected int health = 1;~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~    public int Health {~\\
\cellcolor{green} & 34 & \verb~22~ & & \verb~        get {~\\
\cellcolor{green} & 34 & \verb~23~ & & \verb~            return health;~\\
\cellcolor{green} & 34 & \verb~24~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~    protected Vec2F position;~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~    public Block(Shape shape, string imageFile) :~\\
\cellcolor{green} & 4412 & \verb~28~ & & \verb~    base(shape, new Image(~\\
\cellcolor{green} & 8824 & \verb~29~ & & \verb~        Path.Combine("..", "Breakout", "Assets", "Images", imageFile))) {~\\
\cellcolor{green} & 4412 & \verb~30~ & & \verb~        position = new Vec2F(shape.Position.X, shape.Position.Y);~\\
\cellcolor{green} & 4412 & \verb~31~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~32~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~    /// Decreases Block health, if health is less than 1 the block is marked for deletion.~\\
\cellcolor{gray} &  & \verb~34~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~    public abstract void LoseHealth(int amount);~\\
\cellcolor{green} & 12 & \verb~36~ & & \verb~    protected void GivePoints() {~\\
\cellcolor{green} & 12 & \verb~37~ & & \verb~        BreakoutBus.GetBus().RegisterEvent(new GameEvent {~\\
\cellcolor{green} & 12 & \verb~38~ & & \verb~            EventType = GameEventType.StatusEvent,~\\
\cellcolor{green} & 12 & \verb~39~ & & \verb~            Message = "GET POINTS",~\\
\cellcolor{green} & 12 & \verb~40~ & & \verb~            IntArg1 = value~\\
\cellcolor{green} & 12 & \verb~41~ & & \verb~        });~\\
\cellcolor{green} & 12 & \verb~42~ & & \verb~    }~\\
\cellcolor{red} & 0 & \verb~43~ & & \verb~    public void Render() {~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~        RenderEntity();~\\
\cellcolor{red} & 0 & \verb~45~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~46~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.Blocks.BlockCreator}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.Blocks.BlockCreator\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/Breakout/Blocks/BlockCreator.cs}\end{minipage} \\
\textbf{Covered lines:} & 7\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 7\\
\textbf{Total lines:} & 25\\
\textbf{Line coverage:} & 100\% (7 of 7)\\
\textbf{Covered branches:} & 6\\
\textbf{Total branches:} & 6\\
\textbf{Branch coverage:} & 100\% (6 of 6)\\
\textbf{Covered methods:} & 1\\
\textbf{Total methods:} & 1\\
\textbf{Method coverage:} & 100\% (1 of 1)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{CreateBlock(...)} & 100\% & 6 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/Breakout/Blocks/BlockCreator.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~namespace Breakout.Blocks;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~/// <summary>~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~/// A class for creating block types depending on meta data.~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~/// </summary>~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~public static class BlockCreator {~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    /// Creates a block~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    /// <param name="shape">The shape of the block.</param>~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    /// <param name="image">Image file used for the block.</param>~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~    /// <param name="meta">Metadata that determines what type of block should be created.</param>~\\
\cellcolor{green} & 4384 & \verb~13~ & & \verb~    public static Block CreateBlock(Shape shape, string image, string meta) {~\\
\cellcolor{green} & 4384 & \verb~14~ & & \verb~        switch (meta) {~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~            case "Hardened":~\\
\cellcolor{green} & 13 & \verb~16~ & & \verb~                return new Hardened(shape, image);~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~            case "Unbreakable":~\\
\cellcolor{green} & 33 & \verb~18~ & & \verb~                return new Unbreakable(shape, image);~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~            case "PowerUp":~\\
\cellcolor{green} & 34 & \verb~20~ & & \verb~                return new PowerupBlock(shape, image);~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~            default:~\\
\cellcolor{green} & 4304 & \verb~22~ & & \verb~                return new DefaultBlock(shape, image);~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~        }~\\
\cellcolor{green} & 4384 & \verb~24~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.Blocks.DefaultBlock}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.Blocks.DefaultBlock\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/Breakout/Blocks/DefaultBlock.cs}\end{minipage} \\
\textbf{Covered lines:} & 9\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 9\\
\textbf{Total lines:} & 21\\
\textbf{Line coverage:} & 100\% (9 of 9)\\
\textbf{Covered branches:} & 2\\
\textbf{Total branches:} & 2\\
\textbf{Branch coverage:} & 100\% (2 of 2)\\
\textbf{Covered methods:} & 2\\
\textbf{Total methods:} & 2\\
\textbf{Method coverage:} & 100\% (2 of 2)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{LoseHealth(...)} & 100\% & 2 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/Breakout/Blocks/DefaultBlock.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Events;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~namespace Breakout.Blocks;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~/// <summary>~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~/// Default block has 1 health points and grants player 10 points when destroyed.~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~/// </summary>~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~public class DefaultBlock : Block {~\\
\cellcolor{green} & 8628 & \verb~9~ & & \verb~    public DefaultBlock(Shape shape, string imageFile) : base(shape, imageFile) {~\\
\cellcolor{green} & 4314 & \verb~10~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~    /// Decreases health, if health is 0 the block is marked for deletion.~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 8 & \verb~14~ & & \verb~    public override void LoseHealth(int amount) {~\\
\cellcolor{green} & 8 & \verb~15~ & & \verb~        health -= amount;~\\
\cellcolor{green} & 14 & \verb~16~ & & \verb~        if (health == 0) {~\\
\cellcolor{green} & 6 & \verb~17~ & & \verb~            DeleteEntity();~\\
\cellcolor{green} & 6 & \verb~18~ & & \verb~            GivePoints();~\\
\cellcolor{green} & 6 & \verb~19~ & & \verb~        }~\\
\cellcolor{green} & 8 & \verb~20~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.Blocks.Hardened}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.Blocks.Hardened\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/Breakout/Blocks/Hardened.cs}\end{minipage} \\
\textbf{Covered lines:} & 15\\
\textbf{Uncovered lines:} & 1\\
\textbf{Coverable lines:} & 16\\
\textbf{Total lines:} & 31\\
\textbf{Line coverage:} & 93.7\% (15 of 16)\\
\textbf{Covered branches:} & 5\\
\textbf{Total branches:} & 6\\
\textbf{Branch coverage:} & 83.3\% (5 of 6)\\
\textbf{Covered methods:} & 2\\
\textbf{Total methods:} & 2\\
\textbf{Method coverage:} & 100\% (2 of 2)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{LoseHealth(...)} & 83.33\% & 6 & 88.88\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/Breakout/Blocks/Hardened.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~namespace Breakout.Blocks;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~/// <summary>~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~/// Block has 2 health points and grants player 20 points when destroyed.~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~/// </summary>~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~public class Hardened : Block {~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    private string DamagedImg;~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    private string Damaged;~\\
\cellcolor{green} & 40 & \verb~12~ & & \verb~    public Hardened(Shape shape, string imageFile) : base(shape, imageFile) {~\\
\cellcolor{green} & 20 & \verb~13~ & & \verb~        position = new Vec2F(shape.Position.X, shape.Position.Y);~\\
\cellcolor{green} & 20 & \verb~14~ & & \verb~        DamagedImg = imageFile.Insert(imageFile.Length - 4, "-damaged");~\\
\cellcolor{green} & 20 & \verb~15~ & & \verb~        Damaged = Path.Combine("..", "Breakout", "Assets", "Images", DamagedImg);~\\
\cellcolor{green} & 20 & \verb~16~ & & \verb~        health = 2;~\\
\cellcolor{green} & 20 & \verb~17~ & & \verb~        value = 20;~\\
\cellcolor{green} & 20 & \verb~18~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~    /// Decreases Block health, if health is 0 the block is marked for deletion~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 6 & \verb~22~ & & \verb~    public override void LoseHealth(int amount) {~\\
\cellcolor{green} & 6 & \verb~23~ & & \verb~        health -= amount;~\\
\cellcolor{orange} & 6 & \verb~24~ & & \verb~        if (health == 1 && File.Exists(Damaged)) {~\\
\cellcolor{red} & 0 & \verb~25~ & & \verb~            Image = new Image(Damaged);~\\
\cellcolor{green} & 9 & \verb~26~ & & \verb~        } else if (health == 0) {~\\
\cellcolor{green} & 3 & \verb~27~ & & \verb~            DeleteEntity();~\\
\cellcolor{green} & 3 & \verb~28~ & & \verb~            GivePoints();~\\
\cellcolor{green} & 3 & \verb~29~ & & \verb~        }~\\
\cellcolor{green} & 6 & \verb~30~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.Blocks.PowerupBlock}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.Blocks.PowerupBlock\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/Breakout/Blocks/PowerUpBlock.cs}\end{minipage} \\
\textbf{Covered lines:} & 14\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 14\\
\textbf{Total lines:} & 26\\
\textbf{Line coverage:} & 100\% (14 of 14)\\
\textbf{Covered branches:} & 2\\
\textbf{Total branches:} & 2\\
\textbf{Branch coverage:} & 100\% (2 of 2)\\
\textbf{Covered methods:} & 2\\
\textbf{Total methods:} & 2\\
\textbf{Method coverage:} & 100\% (2 of 2)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{LoseHealth(...)} & 100\% & 2 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/Breakout/Blocks/PowerUpBlock.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Events;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~namespace Breakout.Blocks;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~/// <summary>~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~/// Has 1 health points and grants player 10 points when destroyed and drops a powerup/hazard.~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~/// </summary>~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~public class PowerupBlock : Block {~\\
\cellcolor{green} & 82 & \verb~8~ & & \verb~    public PowerupBlock(Shape shape, string imageFile) : base(shape, imageFile) {~\\
\cellcolor{green} & 41 & \verb~9~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    /// Decreases Block health, if health is 0 the block is marked for deletion~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~    /// and a power-up will be created~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 5 & \verb~14~ & & \verb~    public override void LoseHealth(int amount) {~\\
\cellcolor{green} & 5 & \verb~15~ & & \verb~        health -= amount;~\\
\cellcolor{green} & 8 & \verb~16~ & & \verb~        if (health == 0) {~\\
\cellcolor{green} & 3 & \verb~17~ & & \verb~            BreakoutBus.GetBus().RegisterEvent(new GameEvent {~\\
\cellcolor{green} & 3 & \verb~18~ & & \verb~                EventType = GameEventType.StatusEvent,~\\
\cellcolor{green} & 3 & \verb~19~ & & \verb~                Message = "SPAWN POWERUP",~\\
\cellcolor{green} & 3 & \verb~20~ & & \verb~                ObjectArg1 = (object) Shape.Position~\\
\cellcolor{green} & 3 & \verb~21~ & & \verb~            });~\\
\cellcolor{green} & 3 & \verb~22~ & & \verb~            DeleteEntity();~\\
\cellcolor{green} & 3 & \verb~23~ & & \verb~            GivePoints();~\\
\cellcolor{green} & 3 & \verb~24~ & & \verb~        }~\\
\cellcolor{green} & 5 & \verb~25~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.Blocks.Unbreakable}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.Blocks.Unbreakable\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/Breakout/Blocks/Unbreakable.cs}\end{minipage} \\
\textbf{Covered lines:} & 5\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 5\\
\textbf{Total lines:} & 16\\
\textbf{Line coverage:} & 100\% (5 of 5)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 2\\
\textbf{Total methods:} & 2\\
\textbf{Method coverage:} & 100\% (2 of 2)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{LoseHealth(...)} & 100\% & 1 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/Breakout/Blocks/Unbreakable.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~namespace Breakout.Blocks;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~/// <summary>~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~/// Unbreakable block, can't be destroyed~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~/// </summary>~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~public class Unbreakable : Block {~\\
\cellcolor{green} & 74 & \verb~8~ & & \verb~    public Unbreakable(Shape shape, string imageFile) : base(shape, imageFile) {~\\
\cellcolor{green} & 37 & \verb~9~ & & \verb~        position = new Vec2F(shape.Position.X, shape.Position.Y);~\\
\cellcolor{green} & 37 & \verb~10~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~    /// Does nothing, beacuse unbreakable blocks can't lose health and die~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 20 & \verb~14~ & & \verb~    public override void LoseHealth(int amount) {~\\
\cellcolor{green} & 20 & \verb~15~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.BreakoutBus}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.BreakoutBus\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/Breakout/BreakoutBus.cs}\end{minipage} \\
\textbf{Covered lines:} & 14\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 14\\
\textbf{Total lines:} & 27\\
\textbf{Line coverage:} & 100\% (14 of 14)\\
\textbf{Covered branches:} & 2\\
\textbf{Total branches:} & 2\\
\textbf{Branch coverage:} & 100\% (2 of 2)\\
\textbf{Covered methods:} & 1\\
\textbf{Total methods:} & 1\\
\textbf{Method coverage:} & 100\% (1 of 1)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{GetBus()} & 100\% & 2 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/Breakout/BreakoutBus.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Events;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~namespace Breakout;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~/// <summary>~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~/// A static eventBus used for registering and handling gameEvents~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~/// </summary>~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~public static class BreakoutBus {~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    private static GameEventBus eventBus;~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    /// Retrieves the static Eventbus, allowing for use of eventBus methods.~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 476 & \verb~12~ & & \verb~    public static GameEventBus GetBus() {~\\
\cellcolor{green} & 477 & \verb~13~ & & \verb~        if (BreakoutBus.eventBus == null) {~\\
\cellcolor{green} & 1 & \verb~14~ & & \verb~            BreakoutBus.eventBus = new GameEventBus();~\\
\cellcolor{green} & 1 & \verb~15~ & & \verb~            BreakoutBus.GetBus().InitializeEventBus(~\\
\cellcolor{green} & 1 & \verb~16~ & & \verb~                new List<GameEventType> {~\\
\cellcolor{green} & 1 & \verb~17~ & & \verb~                    GameEventType.InputEvent,~\\
\cellcolor{green} & 1 & \verb~18~ & & \verb~                    GameEventType.WindowEvent,~\\
\cellcolor{green} & 1 & \verb~19~ & & \verb~                    GameEventType.PlayerEvent,~\\
\cellcolor{green} & 1 & \verb~20~ & & \verb~                    GameEventType.GameStateEvent,~\\
\cellcolor{green} & 1 & \verb~21~ & & \verb~                    GameEventType.StatusEvent~\\
\cellcolor{green} & 1 & \verb~22~ & & \verb~                });~\\
\cellcolor{green} & 1 & \verb~23~ & & \verb~        }~\\
\cellcolor{green} & 476 & \verb~24~ & & \verb~        return BreakoutBus.eventBus;~\\
\cellcolor{green} & 476 & \verb~25~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~}~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~~\\
\end{longtable}
\newpage
\section{Breakout.Collisions.BlockCollision}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.Collisions.BlockCollision\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/Breakout/Collisions/BlockCollision.cs}\end{minipage} \\
\textbf{Covered lines:} & 38\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 38\\
\textbf{Total lines:} & 53\\
\textbf{Line coverage:} & 100\% (38 of 38)\\
\textbf{Covered branches:} & 12\\
\textbf{Total branches:} & 12\\
\textbf{Branch coverage:} & 100\% (12 of 12)\\
\textbf{Covered methods:} & 1\\
\textbf{Total methods:} & 1\\
\textbf{Method coverage:} & 100\% (1 of 1)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{Collide(...)} & 100\% & 12 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/Breakout/Collisions/BlockCollision.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using Breakout.Balls;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using Breakout.Blocks;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~using DIKUArcade.Physics;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~namespace Breakout.Collisions;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~/// <summary>~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~/// Handles collisions between balls and blocks~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~/// </summary>~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~public static class BlockCollision {~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~    /// Will check for collsions between ball and blocks,~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~    /// blocks lose health and ball direction is changed when collisions occur.~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 21 & \verb~15~ & & \verb~    public static void Collide(EntityContainer<Ball> balls, EntityContainer<Block> blocks, bool hardBalls) {~\\
\cellcolor{green} & 42 & \verb~16~ & & \verb~        balls.Iterate(ball => {~\\
\cellcolor{green} & 21 & \verb~17~ & & \verb~            // Iterating through every block deletes blocks marked for deletion~\\
\cellcolor{green} & 857 & \verb~18~ & & \verb~            blocks.Iterate(block => {~\\
\cellcolor{green} & 836 & \verb~19~ & & \verb~                CollisionData blockCollision = CollisionDetection.Aabb(ball._Shape, block.Shape);~\\
\cellcolor{green} & 839 & \verb~20~ & & \verb~                if (blockCollision.Collision) { // True if there is collision between the ball and block~\\
\cellcolor{green} & 4 & \verb~21~ & & \verb~                    if (hardBalls) {~\\
\cellcolor{green} & 21 & \verb~22~ & & \verb~                        // If hardball powerup is active block should be deleted~\\
\cellcolor{green} & 1 & \verb~23~ & & \verb~                        block.LoseHealth(block.Health);~\\
\cellcolor{green} & 1 & \verb~24~ & & \verb~                        block.DeleteEntity();~\\
\cellcolor{green} & 3 & \verb~25~ & & \verb~                    } else {~\\
\cellcolor{green} & 21 & \verb~26~ & & \verb~                        // If hardball isnt active the block should lose 1 health~\\
\cellcolor{green} & 2 & \verb~27~ & & \verb~                        block.LoseHealth(1);~\\
\cellcolor{green} & 2 & \verb~28~ & & \verb~                    }~\\
\cellcolor{green} & 3 & \verb~29~ & & \verb~                    CollisionDirection collisionDirection = blockCollision.CollisionDir;~\\
\cellcolor{green} & 3 & \verb~30~ & & \verb~                    Vec2F currentDirection = ball._Shape.Direction;~\\
\cellcolor{green} & 3 & \verb~31~ & & \verb~                    switch (collisionDirection) {~\\
\cellcolor{green} & 21 & \verb~32~ & & \verb~                        case CollisionDirection.CollisionDirUp:~\\
\cellcolor{green} & 21 & \verb~33~ & & \verb~                        case CollisionDirection.CollisionDirDown:~\\
\cellcolor{green} & 2 & \verb~34~ & & \verb~                            if (!hardBalls) {~\\
\cellcolor{green} & 21 & \verb~35~ & & \verb~                                // If hardball is active, ball shouldnt change direction.~\\
\cellcolor{green} & 1 & \verb~36~ & & \verb~                                ball._Shape.ChangeDirection(~\\
\cellcolor{green} & 1 & \verb~37~ & & \verb~                                    new Vec2F(currentDirection.X, -currentDirection.Y));~\\
\cellcolor{green} & 1 & \verb~38~ & & \verb~                            }~\\
\cellcolor{green} & 1 & \verb~39~ & & \verb~                            break;~\\
\cellcolor{green} & 21 & \verb~40~ & & \verb~                        case CollisionDirection.CollisionDirLeft:~\\
\cellcolor{green} & 21 & \verb~41~ & & \verb~                        case CollisionDirection.CollisionDirRight:~\\
\cellcolor{green} & 3 & \verb~42~ & & \verb~                            if (!hardBalls) {~\\
\cellcolor{green} & 21 & \verb~43~ & & \verb~                                // If hardball is active, ball shouldnt change direction.~\\
\cellcolor{green} & 1 & \verb~44~ & & \verb~                                ball._Shape.ChangeDirection(~\\
\cellcolor{green} & 1 & \verb~45~ & & \verb~                                    new Vec2F(-currentDirection.X, currentDirection.Y));~\\
\cellcolor{green} & 1 & \verb~46~ & & \verb~                            }~\\
\cellcolor{green} & 2 & \verb~47~ & & \verb~                            break;~\\
\cellcolor{green} & 21 & \verb~48~ & & \verb~                    }~\\
\cellcolor{green} & 3 & \verb~49~ & & \verb~                }~\\
\cellcolor{green} & 857 & \verb~50~ & & \verb~            });~\\
\cellcolor{green} & 42 & \verb~51~ & & \verb~        });~\\
\cellcolor{green} & 21 & \verb~52~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~53~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.Collisions.PlayerCollision}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.Collisions.PlayerCollision\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/Breakout/Collisions/PlayerCollision.cs}\end{minipage} \\
\textbf{Covered lines:} & 33\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 33\\
\textbf{Total lines:} & 56\\
\textbf{Line coverage:} & 100\% (33 of 33)\\
\textbf{Covered branches:} & 16\\
\textbf{Total branches:} & 16\\
\textbf{Branch coverage:} & 100\% (16 of 16)\\
\textbf{Covered methods:} & 1\\
\textbf{Total methods:} & 1\\
\textbf{Method coverage:} & 100\% (1 of 1)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{Collide(...)} & 100\% & 16 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/Breakout/Collisions/PlayerCollision.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using Breakout.Balls;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using Breakout.Players;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~using DIKUArcade.Physics;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~namespace Breakout.Collisions;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~/// <summary>~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~/// Handles collisions between balls and the player~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~/// </summary>~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~public static class PlayerCollision {~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~    /// Will check for collsions between ball and the player,~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~    /// depending on where the ball hit the player, the balls directional vector is changed.~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 45 & \verb~15~ & & \verb~    public static bool Collide(EntityContainer<Ball> balls, Player player) {~\\
\cellcolor{green} & 45 & \verb~16~ & & \verb~        bool hit = false;~\\
\cellcolor{green} & 45 & \verb~17~ & & \verb~        Vec2F vec = new Vec2F(0.0f, 0.015f);~\\
\cellcolor{green} & 45 & \verb~18~ & & \verb~        Vec2F vec20 = new Vec2F(-0.0051f, 0.01409f);~\\
\cellcolor{green} & 45 & \verb~19~ & & \verb~        Vec2F revVec20 = new Vec2F(0.0051f, 0.01409f);~\\
\cellcolor{green} & 45 & \verb~20~ & & \verb~        Vec2F vec45 = new Vec2F(-0.0106f, 0.0106f);~\\
\cellcolor{green} & 45 & \verb~21~ & & \verb~        Vec2F revVec45 = new Vec2F(0.0106f, 0.0106f);~\\
\cellcolor{green} & 45 & \verb~22~ & & \verb~        float playerposx = player.Shape.Position.X;~\\
\cellcolor{green} & 140 & \verb~23~ & & \verb~        balls.Iterate(ball => {~\\
\cellcolor{green} & 45 & \verb~24~ & & \verb~            // Iterating through every block~\\
\cellcolor{green} & 95 & \verb~25~ & & \verb~            CollisionData collision = CollisionDetection.Aabb(ball._Shape, player.Shape);~\\
\cellcolor{green} & 100 & \verb~26~ & & \verb~            if (collision.Collision) { // True if there is collision between the ball and player~\\
\cellcolor{green} & 5 & \verb~27~ & & \verb~                hit = true;~\\
\cellcolor{green} & 5 & \verb~28~ & & \verb~                float ballx = ball._Shape.Position.X + (ball._Shape.Extent.X / 2); //Middle of ball~\\
\cellcolor{green} & 5 & \verb~29~ & & \verb~                float playerExtentX = player.Shape.Extent.X;~\\
\cellcolor{green} & 6 & \verb~30~ & & \verb~                if (ballx < playerposx + (playerExtentX / 5)) {~\\
\cellcolor{green} & 1 & \verb~31~ & & \verb~                    ball._Shape.ChangeDirection(vec45);~\\
\cellcolor{green} & 5 & \verb~32~ & & \verb~                } else if (ballx < playerposx + (playerExtentX / 5) * 2 &&~\\
\cellcolor{green} & 5 & \verb~33~ & & \verb~                            ballx > playerposx + (player.Shape.Extent.X / 5)) {~\\
\cellcolor{green} & 1 & \verb~34~ & & \verb~                    ball._Shape.ChangeDirection(vec20);~\\
\cellcolor{green} & 4 & \verb~35~ & & \verb~                } else if (ballx < playerposx + (playerExtentX / 5) * 3 &&~\\
\cellcolor{green} & 4 & \verb~36~ & & \verb~                            ballx > playerposx + (playerExtentX / 5) * 2) {~\\
\cellcolor{green} & 1 & \verb~37~ & & \verb~                    ball._Shape.ChangeDirection(vec);~\\
\cellcolor{green} & 3 & \verb~38~ & & \verb~                } else if (ballx < playerposx + (playerExtentX / 5) * 4 &&~\\
\cellcolor{green} & 3 & \verb~39~ & & \verb~                            ballx > playerposx + (playerExtentX / 5) * 3) {~\\
\cellcolor{green} & 1 & \verb~40~ & & \verb~                    ball._Shape.ChangeDirection(revVec20);~\\
\cellcolor{green} & 2 & \verb~41~ & & \verb~                } else {~\\
\cellcolor{green} & 1 & \verb~42~ & & \verb~                    ball._Shape.ChangeDirection(revVec45);~\\
\cellcolor{green} & 1 & \verb~43~ & & \verb~                }~\\
\cellcolor{green} & 5 & \verb~44~ & & \verb~            }~\\
\cellcolor{green} & 140 & \verb~45~ & & \verb~        });~\\
\cellcolor{green} & 45 & \verb~46~ & & \verb~        return hit;~\\
\cellcolor{green} & 45 & \verb~47~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~48~ & & \verb~}~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~~\\
\cellcolor{gray} &  & \verb~50~ & & \verb~~\\
\cellcolor{gray} &  & \verb~51~ & & \verb~~\\
\cellcolor{gray} &  & \verb~52~ & & \verb~~\\
\cellcolor{gray} &  & \verb~53~ & & \verb~~\\
\cellcolor{gray} &  & \verb~54~ & & \verb~~\\
\cellcolor{gray} &  & \verb~55~ & & \verb~~\\
\cellcolor{gray} &  & \verb~56~ & & \verb~~\\
\end{longtable}
\newpage
\section{Breakout.Collisions.PowerUpCollision}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.Collisions.PowerUpCollision\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/Breakout/Collisions/PowerUpCollision.cs}\end{minipage} \\
\textbf{Covered lines:} & 13\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 13\\
\textbf{Total lines:} & 27\\
\textbf{Line coverage:} & 100\% (13 of 13)\\
\textbf{Covered branches:} & 2\\
\textbf{Total branches:} & 2\\
\textbf{Branch coverage:} & 100\% (2 of 2)\\
\textbf{Covered methods:} & 1\\
\textbf{Total methods:} & 1\\
\textbf{Method coverage:} & 100\% (1 of 1)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{Collide(...)} & 100\% & 2 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/Breakout/Collisions/PowerUpCollision.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using Breakout.Players;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Physics;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using Breakout.Powerups;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~namespace Breakout.Collisions;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~/// <summary>~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~/// Handles collisions between the player and powerups~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~/// </summary>~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~public static class PowerUpCollision {~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    /// Will check for collsions between powerup and the player,~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~    /// depending on where the ball hit the player, the balls directional vector is changed.~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 22 & \verb~14~ & & \verb~    public static bool Collide(EntityContainer<Powerup> powerups, Player player) {~\\
\cellcolor{green} & 22 & \verb~15~ & & \verb~        bool hit = false;~\\
\cellcolor{green} & 33 & \verb~16~ & & \verb~        powerups.Iterate(powerup => {~\\
\cellcolor{green} & 11 & \verb~17~ & & \verb~            CollisionData collision = CollisionDetection.Aabb(~\\
\cellcolor{green} & 11 & \verb~18~ & & \verb~                (DynamicShape) powerup.Shape, player.Shape);~\\
\cellcolor{green} & 21 & \verb~19~ & & \verb~            if (collision.Collision) {~\\
\cellcolor{green} & 10 & \verb~20~ & & \verb~                powerup.Effect();~\\
\cellcolor{green} & 10 & \verb~21~ & & \verb~                hit = true;~\\
\cellcolor{green} & 10 & \verb~22~ & & \verb~                powerup.DeleteEntity();~\\
\cellcolor{green} & 10 & \verb~23~ & & \verb~            }~\\
\cellcolor{green} & 33 & \verb~24~ & & \verb~        });~\\
\cellcolor{green} & 22 & \verb~25~ & & \verb~        return hit;~\\
\cellcolor{green} & 22 & \verb~26~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.Collisions.WallCollision}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.Collisions.WallCollision\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/Breakout/Collisions/WallCollision.cs}\end{minipage} \\
\textbf{Covered lines:} & 38\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 38\\
\textbf{Total lines:} & 53\\
\textbf{Line coverage:} & 100\% (38 of 38)\\
\textbf{Covered branches:} & 10\\
\textbf{Total branches:} & 10\\
\textbf{Branch coverage:} & 100\% (10 of 10)\\
\textbf{Covered methods:} & 5\\
\textbf{Total methods:} & 5\\
\textbf{Method coverage:} & 100\% (5 of 5)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{Collide(...)} & 100\% & 2 & 100\%\\
\hline
\textbf{CollideLeftWall(...)} & 100\% & 2 & 100\%\\
\hline
\textbf{CollideRightWall(...} & 100\% & 2 & 100\%\\
\hline
\textbf{CollideTopWall(...)} & 100\% & 2 & 100\%\\
\hline
\textbf{CollideBottom(...)} & 100\% & 2 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/Breakout/Collisions/WallCollision.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using Breakout.Balls;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Events;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~namespace Breakout.Collisions;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~/// <summary>~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~/// Handles collisions between balls and walls~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~/// </summary>~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~public static class WallCollision {~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    /// Will check for collsions between ball and walls.~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    /// If ball hits a wall it's send the opposite direction.~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~    /// If balls hits bottom, lose health event and a new ball event is send.~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 20 & \verb~14~ & & \verb~    public static void Collide(EntityContainer<Ball> balls) {~\\
\cellcolor{green} & 39 & \verb~15~ & & \verb~        balls.Iterate(ball => {~\\
\cellcolor{green} & 19 & \verb~16~ & & \verb~            CollideLeftWall(ball);~\\
\cellcolor{green} & 19 & \verb~17~ & & \verb~            CollideRightWall(ball);~\\
\cellcolor{green} & 19 & \verb~18~ & & \verb~            CollideTopWall(ball);~\\
\cellcolor{green} & 19 & \verb~19~ & & \verb~            CollideBottom(ball);~\\
\cellcolor{green} & 39 & \verb~20~ & & \verb~        });~\\
\cellcolor{green} & 25 & \verb~21~ & & \verb~        if (balls.CountEntities() == 0) {~\\
\cellcolor{green} & 5 & \verb~22~ & & \verb~            BreakoutBus.GetBus().RegisterEvent(new GameEvent {~\\
\cellcolor{green} & 5 & \verb~23~ & & \verb~                EventType = GameEventType.StatusEvent,~\\
\cellcolor{green} & 5 & \verb~24~ & & \verb~                Message = "LOSE HEALTH"~\\
\cellcolor{green} & 5 & \verb~25~ & & \verb~            });~\\
\cellcolor{green} & 5 & \verb~26~ & & \verb~            BreakoutBus.GetBus().RegisterEvent(new GameEvent {~\\
\cellcolor{green} & 5 & \verb~27~ & & \verb~                EventType = GameEventType.StatusEvent,~\\
\cellcolor{green} & 5 & \verb~28~ & & \verb~                Message = "NEW BALL"~\\
\cellcolor{green} & 5 & \verb~29~ & & \verb~            });~\\
\cellcolor{green} & 5 & \verb~30~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~~\\
\cellcolor{green} & 20 & \verb~32~ & & \verb~    }~\\
\cellcolor{green} & 19 & \verb~33~ & & \verb~    private static void CollideLeftWall(Ball ball) {~\\
\cellcolor{green} & 20 & \verb~34~ & & \verb~        if (ball._Shape.Position.X < 0) {~\\
\cellcolor{green} & 1 & \verb~35~ & & \verb~            ball._Shape.Direction.X = -ball._Shape.Direction.X;~\\
\cellcolor{green} & 1 & \verb~36~ & & \verb~        }~\\
\cellcolor{green} & 19 & \verb~37~ & & \verb~    }~\\
\cellcolor{green} & 19 & \verb~38~ & & \verb~    private static void CollideRightWall(Ball ball) {~\\
\cellcolor{green} & 20 & \verb~39~ & & \verb~        if (ball._Shape.Position.X + ball._Shape.Extent.X > 1) {~\\
\cellcolor{green} & 1 & \verb~40~ & & \verb~            ball._Shape.Direction.X = -ball._Shape.Direction.X;~\\
\cellcolor{green} & 1 & \verb~41~ & & \verb~        }~\\
\cellcolor{green} & 19 & \verb~42~ & & \verb~    }~\\
\cellcolor{green} & 19 & \verb~43~ & & \verb~    private static void CollideTopWall(Ball ball) {~\\
\cellcolor{green} & 20 & \verb~44~ & & \verb~        if (ball._Shape.Position.Y + ball._Shape.Extent.Y > 1) {~\\
\cellcolor{green} & 1 & \verb~45~ & & \verb~            ball._Shape.Direction.Y = -ball._Shape.Direction.Y;~\\
\cellcolor{green} & 1 & \verb~46~ & & \verb~        }~\\
\cellcolor{green} & 19 & \verb~47~ & & \verb~    }~\\
\cellcolor{green} & 19 & \verb~48~ & & \verb~    private static void CollideBottom(Ball ball) {~\\
\cellcolor{green} & 21 & \verb~49~ & & \verb~        if (ball._Shape.Position.Y <= 0.0 - ball._Shape.Extent.Y) {~\\
\cellcolor{green} & 2 & \verb~50~ & & \verb~            ball.DeleteEntity();~\\
\cellcolor{green} & 2 & \verb~51~ & & \verb~        }~\\
\cellcolor{green} & 19 & \verb~52~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~53~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.Constants}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.Constants\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/Breakout/Constants.cs}\end{minipage} \\
\textbf{Covered lines:} & 2\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 2\\
\textbf{Total lines:} & 11\\
\textbf{Line coverage:} & 100\% (2 of 2)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 1\\
\textbf{Total methods:} & 1\\
\textbf{Method coverage:} & 100\% (1 of 1)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.cctor()} & 100\% & 1 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/Breakout/Constants.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Utilities;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~namespace Breakout;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~/// <summary> Class for conatining constants </summary>~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~/// <remarks> Used for indicating path to assets </remarks>~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~public static class Constants {~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~    /// <summary> This is to get the path of the Breakout/Assets </summary>~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    /// <remarks> We need this for testing, to make sure we are using the same assets </remarks>~\\
\cellcolor{green} & 1 & \verb~9~ & & \verb~    public static readonly string MAIN_PATH =~\\
\cellcolor{green} & 1 & \verb~10~ & & \verb~        Path.Combine(Directory.GetParent(FileIO.GetProjectPath())!.FullName, "Breakout");~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.Game}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.Game\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/Breakout/Game.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 24\\
\textbf{Coverable lines:} & 24\\
\textbf{Total lines:} & 49\\
\textbf{Line coverage:} & 0\% (0 of 24)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 4\\
\textbf{Branch coverage:} & 0\% (0 of 4)\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 5\\
\textbf{Method coverage:} & 0\% (0 of 5)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{ProcessEvent(...)} & 0\% & 4 & 0\%\\
\hline
\textbf{KeyHandler(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Render()} & 100\% & 1 & 0\%\\
\hline
\textbf{Update()} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/Breakout/Game.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using Breakout.States;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Events;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using DIKUArcade.GUI;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~using DIKUArcade.Input;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~namespace Breakout;~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~/// <summary>~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~///  Class responsible for handling a statemachine and keyinputs~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~/// </summary>~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~public class Game : DIKUGame, IGameEventProcessor {~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~    private StateMachine stateMachine;~\\
\cellcolor{red} & 0 & \verb~13~ & & \verb~    public Game(WindowArgs windowArgs) : base(windowArgs) {~\\
\cellcolor{red} & 0 & \verb~14~ & & \verb~        window.SetKeyEventHandler(KeyHandler);~\\
\cellcolor{red} & 0 & \verb~15~ & & \verb~        BreakoutBus.GetBus().Subscribe(GameEventType.InputEvent, this);~\\
\cellcolor{red} & 0 & \verb~16~ & & \verb~        BreakoutBus.GetBus().Subscribe(GameEventType.WindowEvent, this);~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~18~ & & \verb~        stateMachine = new StateMachine();~\\
\cellcolor{red} & 0 & \verb~19~ & & \verb~        BreakoutBus.GetBus().Subscribe(GameEventType.GameStateEvent, stateMachine);~\\
\cellcolor{red} & 0 & \verb~20~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~    ///  processes windowevents, can close window~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~24~ & & \verb~    public void ProcessEvent(GameEvent gameEvent) {~\\
\cellcolor{red} & 0 & \verb~25~ & & \verb~        if (gameEvent.EventType == GameEventType.WindowEvent) {~\\
\cellcolor{red} & 0 & \verb~26~ & & \verb~            switch (gameEvent.StringArg1) {~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~                case "WINDOW CLOSE":~\\
\cellcolor{red} & 0 & \verb~28~ & & \verb~                    window.CloseWindow();~\\
\cellcolor{red} & 0 & \verb~29~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~31~ & & \verb~        }~\\
\cellcolor{red} & 0 & \verb~32~ & & \verb~    }~\\
\cellcolor{red} & 0 & \verb~33~ & & \verb~    private void KeyHandler(KeyboardAction action, KeyboardKey key) {~\\
\cellcolor{red} & 0 & \verb~34~ & & \verb~        stateMachine.ActiveState.HandleKeyEvent(action, key);~\\
\cellcolor{red} & 0 & \verb~35~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~    ///  Renders the active state~\\
\cellcolor{gray} &  & \verb~38~ & & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~39~ & & \verb~    public override void Render() {~\\
\cellcolor{red} & 0 & \verb~40~ & & \verb~        stateMachine.ActiveState.RenderState();~\\
\cellcolor{red} & 0 & \verb~41~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~42~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~43~ & & \verb~    ///  Updates the active state~\\
\cellcolor{gray} &  & \verb~44~ & & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~45~ & & \verb~    public override void Update() {~\\
\cellcolor{red} & 0 & \verb~46~ & & \verb~        BreakoutBus.GetBus().ProcessEventsSequentially();~\\
\cellcolor{red} & 0 & \verb~47~ & & \verb~        stateMachine.ActiveState.UpdateState();~\\
\cellcolor{red} & 0 & \verb~48~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.Health}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.Health\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/Breakout/Health.cs}\end{minipage} \\
\textbf{Covered lines:} & 31\\
\textbf{Uncovered lines:} & 3\\
\textbf{Coverable lines:} & 34\\
\textbf{Total lines:} & 59\\
\textbf{Line coverage:} & 91.1\% (31 of 34)\\
\textbf{Covered branches:} & 8\\
\textbf{Total branches:} & 8\\
\textbf{Branch coverage:} & 100\% (8 of 8)\\
\textbf{Covered methods:} & 4\\
\textbf{Total methods:} & 5\\
\textbf{Method coverage:} & 80\% (4 of 5)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{get\_\_Health()} & 100\% & 1 & 100\%\\
\hline
\textbf{.ctor()} & 100\% & 1 & 100\%\\
\hline
\textbf{ProcessEvent(...)} & 100\% & 6 & 100\%\\
\hline
\textbf{LoseHealth()} & 100\% & 2 & 100\%\\
\hline
\textbf{Render()} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/Breakout/Health.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Events;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~namespace Breakout;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~/// <summary>~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~/// Player health.~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~/// </summary>~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~public class Health : IGameEventProcessor {~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~    private int health;~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    private Text display;~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    public int _Health {~\\
\cellcolor{green} & 19 & \verb~12~ & & \verb~        get => health;~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~    }~\\
\cellcolor{green} & 128 & \verb~14~ & & \verb~    public Health() {~\\
\cellcolor{green} & 64 & \verb~15~ & & \verb~        health = 3;~\\
\cellcolor{green} & 64 & \verb~16~ & & \verb~        display = new Text($"Lives: {health}",~\\
\cellcolor{green} & 64 & \verb~17~ & & \verb~            new Vec2F(0.85f, -0.275f),~\\
\cellcolor{green} & 64 & \verb~18~ & & \verb~            new Vec2F(0.25f, 0.35f));~\\
\cellcolor{green} & 64 & \verb~19~ & & \verb~        display.SetColor(new Vec3I(255, 255, 255));~\\
\cellcolor{green} & 64 & \verb~20~ & & \verb~        BreakoutBus.GetBus().Subscribe(GameEventType.StatusEvent, this);~\\
\cellcolor{green} & 64 & \verb~21~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~    /// Uses StausEvents to either lose or get health.~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 552 & \verb~25~ & & \verb~    public void ProcessEvent(GameEvent gameEvent) {~\\
\cellcolor{green} & 1104 & \verb~26~ & & \verb~        if (gameEvent.EventType == GameEventType.StatusEvent) {~\\
\cellcolor{green} & 552 & \verb~27~ & & \verb~            switch (gameEvent.Message) {~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~                case "LOSE HEALTH":~\\
\cellcolor{green} & 58 & \verb~29~ & & \verb~                    LoseHealth();~\\
\cellcolor{green} & 58 & \verb~30~ & & \verb~                    display.SetText("Lives:" + health.ToString());~\\
\cellcolor{green} & 58 & \verb~31~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~32~ & & \verb~                case "GET HEALTH":~\\
\cellcolor{green} & 14 & \verb~33~ & & \verb~                    health += gameEvent.IntArg1;~\\
\cellcolor{green} & 14 & \verb~34~ & & \verb~                    display.SetText("Lives:" + health.ToString());~\\
\cellcolor{green} & 14 & \verb~35~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~            }~\\
\cellcolor{green} & 552 & \verb~37~ & & \verb~        }~\\
\cellcolor{green} & 552 & \verb~38~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~39~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~40~ & & \verb~    /// Decrements health if health is 0 state switches to game lost.~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 62 & \verb~42~ & & \verb~    public void LoseHealth() {~\\
\cellcolor{green} & 62 & \verb~43~ & & \verb~        health -= 1;~\\
\cellcolor{green} & 85 & \verb~44~ & & \verb~        if (health <= 0) {~\\
\cellcolor{green} & 23 & \verb~45~ & & \verb~            health = 0;~\\
\cellcolor{green} & 23 & \verb~46~ & & \verb~            BreakoutBus.GetBus().RegisterEvent(new GameEvent {~\\
\cellcolor{green} & 23 & \verb~47~ & & \verb~                EventType = GameEventType.GameStateEvent,~\\
\cellcolor{green} & 23 & \verb~48~ & & \verb~                Message = "CHANGE_STATE",~\\
\cellcolor{green} & 23 & \verb~49~ & & \verb~                StringArg1 = "GAME_LOST"~\\
\cellcolor{green} & 23 & \verb~50~ & & \verb~            });~\\
\cellcolor{green} & 23 & \verb~51~ & & \verb~        }~\\
\cellcolor{green} & 62 & \verb~52~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~53~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~54~ & & \verb~    /// Renders health text~\\
\cellcolor{gray} &  & \verb~55~ & & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~56~ & & \verb~    public void Render() {~\\
\cellcolor{red} & 0 & \verb~57~ & & \verb~        display.RenderText();~\\
\cellcolor{red} & 0 & \verb~58~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~59~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.Levels.LevelCreator}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.Levels.LevelCreator\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/Breakout/LevelLoading/LevelCreator.cs}\end{minipage} \\
\textbf{Covered lines:} & 53\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 53\\
\textbf{Total lines:} & 90\\
\textbf{Line coverage:} & 100\% (53 of 53)\\
\textbf{Covered branches:} & 11\\
\textbf{Total branches:} & 12\\
\textbf{Branch coverage:} & 91.6\% (11 of 12)\\
\textbf{Covered methods:} & 7\\
\textbf{Total methods:} & 7\\
\textbf{Method coverage:} & 100\% (7 of 7)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{get\_Blocks()} & 100\% & 1 & 100\%\\
\hline
\textbf{get\_Time()} & 100\% & 1 & 100\%\\
\hline
\textbf{get\_HasTimer()} & 100\% & 1 & 100\%\\
\hline
\textbf{.ctor()} & 100\% & 1 & 100\%\\
\hline
\textbf{CreateLevel(...)} & 100\% & 2 & 100\%\\
\hline
\textbf{CreateBlocks()} & 100\% & 6 & 100\%\\
\hline
\textbf{InitializeTimer()} & 75.00\% & 4 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/Breakout/LevelLoading/LevelCreator.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using Breakout.Blocks;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~namespace Breakout.Levels;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~/// <summary>~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~/// Used to create a level from a string levelfile. Uses a level reader to read level file.~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~/// </summary>~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~public class LevelCreator {~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    private string[] map;~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    private Dictionary<string, string> meta;~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~    private Dictionary<char, string> legend;~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~    private LevelReader levelReader;~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~    private int time;~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~    private bool hasTimer;~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~    private EntityContainer<Block> blocks;~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~    public EntityContainer<Block> Blocks {~\\
\cellcolor{green} & 57 & \verb~18~ & & \verb~        get {~\\
\cellcolor{green} & 57 & \verb~19~ & & \verb~            return blocks;~\\
\cellcolor{green} & 57 & \verb~20~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~    public int Time {~\\
\cellcolor{green} & 54 & \verb~23~ & & \verb~        get {~\\
\cellcolor{green} & 54 & \verb~24~ & & \verb~            return time;~\\
\cellcolor{green} & 54 & \verb~25~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~    public bool HasTimer {~\\
\cellcolor{green} & 3 & \verb~28~ & & \verb~        get {~\\
\cellcolor{green} & 3 & \verb~29~ & & \verb~            return hasTimer;~\\
\cellcolor{green} & 3 & \verb~30~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~    }~\\
\cellcolor{green} & 124 & \verb~32~ & & \verb~    public LevelCreator() {~\\
\cellcolor{green} & 62 & \verb~33~ & & \verb~        this.levelReader = new LevelReader();~\\
\cellcolor{green} & 62 & \verb~34~ & & \verb~        this.blocks = new EntityContainer<Block>(0);~\\
\cellcolor{green} & 62 & \verb~35~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~    /// Reads a file level and creates block in Level.~\\
\cellcolor{gray} &  & \verb~38~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~39~ & & \verb~    /// <param name="level">Level text file that will become the new playable level.</param>~\\
\cellcolor{green} & 58 & \verb~40~ & & \verb~    public bool CreateLevel(string level) {~\\
\cellcolor{green} & 58 & \verb~41~ & & \verb~        levelReader.ReadLevel(level);~\\
\cellcolor{green} & 114 & \verb~42~ & & \verb~        if (levelReader.MapValid()) { // LevelData contains map and legend~\\
\cellcolor{green} & 56 & \verb~43~ & & \verb~            this.map = levelReader.Map;~\\
\cellcolor{green} & 56 & \verb~44~ & & \verb~            this.meta = levelReader.Meta;~\\
\cellcolor{green} & 56 & \verb~45~ & & \verb~            this.legend = levelReader.Legend;~\\
\cellcolor{green} & 56 & \verb~46~ & & \verb~            CreateBlocks();~\\
\cellcolor{green} & 56 & \verb~47~ & & \verb~            InitializeTimer();~\\
\cellcolor{green} & 56 & \verb~48~ & & \verb~            return true;~\\
\cellcolor{green} & 2 & \verb~49~ & & \verb~        } else {~\\
\cellcolor{green} & 2 & \verb~50~ & & \verb~            return false;~\\
\cellcolor{gray} &  & \verb~51~ & & \verb~        }~\\
\cellcolor{green} & 58 & \verb~52~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~53~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~54~ & & \verb~    /// Uses map, legend and meta to draw blocks and apply metadata in the level.~\\
\cellcolor{gray} &  & \verb~55~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 56 & \verb~56~ & & \verb~    private void CreateBlocks() {~\\
\cellcolor{gray} &  & \verb~57~ & & \verb~        // map can be filled with blocks without crashing~\\
\cellcolor{green} & 56 & \verb~58~ & & \verb~        blocks = new EntityContainer<Block>(324);~\\
\cellcolor{gray} &  & \verb~59~ & & \verb~        // pos and extent for blocks~\\
\cellcolor{green} & 56 & \verb~60~ & & \verb~        float x = 1f / 12f;~\\
\cellcolor{green} & 56 & \verb~61~ & & \verb~        float y = (1f / 12f) / 2.5f;~\\
\cellcolor{gray} &  & \verb~62~ & & \verb~        string colour;~\\
\cellcolor{gray} &  & \verb~63~ & & \verb~        string metadata;~\\
\cellcolor{gray} &  & \verb~64~ & & \verb~        Shape shape;~\\
\cellcolor{gray} &  & \verb~65~ & & \verb~        Block block;~\\
\cellcolor{green} & 3970 & \verb~66~ & & \verb~        for (int i = 0; i < map.Length - 1; i++) {~\\
\cellcolor{green} & 48868 & \verb~67~ & & \verb~            for (int j = 0; j < map[i].Length; j++) {~\\
\cellcolor{green} & 15432 & \verb~68~ & & \verb~                shape = new StationaryShape(~\\
\cellcolor{green} & 15432 & \verb~69~ & & \verb~                    new Vec2F((x * (float) j), 1.0f - (y * (float) i)),~\\
\cellcolor{green} & 15432 & \verb~70~ & & \verb~                    new Vec2F(x, y));~\\
\cellcolor{green} & 19812 & \verb~71~ & & \verb~                if (legend.TryGetValue(map[i][j], out colour!)) {~\\
\cellcolor{green} & 4380 & \verb~72~ & & \verb~                    meta.TryGetValue(map[i][j].ToString(), out metadata!);~\\
\cellcolor{green} & 4380 & \verb~73~ & & \verb~                    block = BlockCreator.CreateBlock(shape, colour, metadata);~\\
\cellcolor{green} & 4380 & \verb~74~ & & \verb~                    blocks.AddEntity(block);~\\
\cellcolor{green} & 4380 & \verb~75~ & & \verb~                }~\\
\cellcolor{green} & 15432 & \verb~76~ & & \verb~            }~\\
\cellcolor{green} & 1286 & \verb~77~ & & \verb~        }~\\
\cellcolor{green} & 56 & \verb~78~ & & \verb~    }~\\
\cellcolor{green} & 56 & \verb~79~ & & \verb~    private void InitializeTimer() {~\\
\cellcolor{green} & 56 & \verb~80~ & & \verb~        string timeval = "";~\\
\cellcolor{green} & 56 & \verb~81~ & & \verb~        meta.TryGetValue("Time", out timeval);~\\
\cellcolor{orange} & 109 & \verb~82~ & & \verb~        if (timeval != "" && timeval != null) {~\\
\cellcolor{green} & 53 & \verb~83~ & & \verb~            hasTimer = true;~\\
\cellcolor{green} & 53 & \verb~84~ & & \verb~            time = int.Parse(timeval);~\\
\cellcolor{green} & 56 & \verb~85~ & & \verb~        } else {~\\
\cellcolor{green} & 3 & \verb~86~ & & \verb~            hasTimer = false;~\\
\cellcolor{green} & 3 & \verb~87~ & & \verb~            time = System.Int32.MaxValue;~\\
\cellcolor{green} & 3 & \verb~88~ & & \verb~        }~\\
\cellcolor{green} & 56 & \verb~89~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~90~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.Levels.LevelManager}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.Levels.LevelManager\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/Breakout/LevelLoading/LevelManager.cs}\end{minipage} \\
\textbf{Covered lines:} & 87\\
\textbf{Uncovered lines:} & 12\\
\textbf{Coverable lines:} & 99\\
\textbf{Total lines:} & 159\\
\textbf{Line coverage:} & 87.8\% (87 of 99)\\
\textbf{Covered branches:} & 26\\
\textbf{Total branches:} & 30\\
\textbf{Branch coverage:} & 86.6\% (26 of 30)\\
\textbf{Covered methods:} & 15\\
\textbf{Total methods:} & 16\\
\textbf{Method coverage:} & 93.7\% (15 of 16)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor()} & 100\% & 1 & 100\%\\
\hline
\textbf{get\_Player()} & 100\% & 1 & 100\%\\
\hline
\textbf{get\_Blocks()} & 100\% & 1 & 100\%\\
\hline
\textbf{get\_Balls()} & 100\% & 1 & 100\%\\
\hline
\textbf{get\_Powerups()} & 100\% & 1 & 100\%\\
\hline
\textbf{get\_LevelTimer()} & 100\% & 1 & 100\%\\
\hline
\textbf{get\_HardBalls()} & 100\% & 1 & 100\%\\
\hline
\textbf{NewLevel(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{ProcessEvent(...)} & 100\% & 18 & 100\%\\
\hline
\textbf{EmptyLevel()} & 75.00\% & 4 & 85.71\%\\
\hline
\textbf{MoveBalls()} & 100\% & 2 & 100\%\\
\hline
\textbf{MovePowerups()} & 50.0\% & 2 & 60.0\%\\
\hline
\textbf{CheckCollisions()} & 100\% & 1 & 100\%\\
\hline
\textbf{CheckTime()} & 100\% & 2 & 100\%\\
\hline
\textbf{Render()} & 0\% & 2 & 0\%\\
\hline
\textbf{Update()} & 100\% & 1 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/Breakout/LevelLoading/LevelManager.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using Breakout.Blocks;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Events;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using Breakout.Players;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~using Breakout.Collisions;~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~namespace Breakout.Levels;~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~using Breakout.Balls;~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~using Breakout.Powerups;~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~/// <summary>~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~/// Class that creates and manages game objects, such as blocks, balls and the player.~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~/// </summary>~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~public class LevelManager : IGameEventProcessor {~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~    private LevelCreator levelCreator;~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~    private EntityContainer<Block> blocks;~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~    private EntityContainer<Ball> balls;~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~    private EntityContainer<Powerup> powerups;~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~    private Player player;~\\
\cellcolor{green} & 58 & \verb~21~ & & \verb~    private bool hardBalls = false;~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~    private Timer levelTimer;~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~    public Player Player {~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~        // Used for testing~\\
\cellcolor{green} & 12 & \verb~25~ & & \verb~        get => player;~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~    public EntityContainer<Block> Blocks {~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~        // Used for testing~\\
\cellcolor{green} & 7 & \verb~29~ & & \verb~        get => blocks;~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~    public EntityContainer<Ball> Balls {~\\
\cellcolor{gray} &  & \verb~32~ & & \verb~        // Used for testing~\\
\cellcolor{green} & 10 & \verb~33~ & & \verb~        get => balls;~\\
\cellcolor{gray} &  & \verb~34~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~    public EntityContainer<Powerup> Powerups {~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~        // Used for testing~\\
\cellcolor{green} & 13 & \verb~37~ & & \verb~        get => powerups;~\\
\cellcolor{gray} &  & \verb~38~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~39~ & & \verb~    public Timer LevelTimer {~\\
\cellcolor{gray} &  & \verb~40~ & & \verb~        // Used for testing~\\
\cellcolor{green} & 1 & \verb~41~ & & \verb~        get => levelTimer;~\\
\cellcolor{gray} &  & \verb~42~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~43~ & & \verb~    public bool HardBalls {~\\
\cellcolor{gray} &  & \verb~44~ & & \verb~        // Used for testing~\\
\cellcolor{green} & 7 & \verb~45~ & & \verb~        get => hardBalls;~\\
\cellcolor{gray} &  & \verb~46~ & & \verb~    }~\\
\cellcolor{green} & 116 & \verb~47~ & & \verb~    public LevelManager() {~\\
\cellcolor{green} & 58 & \verb~48~ & & \verb~        levelCreator = new LevelCreator();~\\
\cellcolor{green} & 58 & \verb~49~ & & \verb~        player = new Player(~\\
\cellcolor{green} & 58 & \verb~50~ & & \verb~            new DynamicShape(new Vec2F(0.425f, 0.06f), new Vec2F(0.15f, 0.04f)),~\\
\cellcolor{green} & 58 & \verb~51~ & & \verb~            new Image(Path.Combine("..", "Breakout", "Assets", "Images", "player.png")));~\\
\cellcolor{green} & 58 & \verb~52~ & & \verb~        balls = new EntityContainer<Ball>(18);~\\
\cellcolor{green} & 58 & \verb~53~ & & \verb~        blocks = new EntityContainer<Block>(0);~\\
\cellcolor{gray} &  & \verb~54~ & & \verb~~\\
\cellcolor{green} & 58 & \verb~55~ & & \verb~        powerups = new EntityContainer<Powerup>(10);~\\
\cellcolor{green} & 58 & \verb~56~ & & \verb~        levelTimer = new Timer(new Vec2F(0.0f, -0.285f), 0);~\\
\cellcolor{green} & 58 & \verb~57~ & & \verb~        BreakoutBus.GetBus().Subscribe(GameEventType.StatusEvent, this);~\\
\cellcolor{green} & 58 & \verb~58~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~59~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~60~ & & \verb~    /// Removes balls and creates newlevel using string levelfile~\\
\cellcolor{gray} &  & \verb~61~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~62~ & & \verb~    /// <param name="level">Name of the level file that will be loaded</param>~\\
\cellcolor{green} & 51 & \verb~63~ & & \verb~    public void NewLevel(string level) {~\\
\cellcolor{green} & 51 & \verb~64~ & & \verb~        balls.ClearContainer(); // Reseting balls~\\
\cellcolor{green} & 51 & \verb~65~ & & \verb~        levelCreator.CreateLevel(level); // Creating new level~\\
\cellcolor{green} & 51 & \verb~66~ & & \verb~        blocks = levelCreator.Blocks; // Block container for new level becomes current block container~\\
\cellcolor{green} & 51 & \verb~67~ & & \verb~        balls.AddEntity(BallCreator.CreateBall(new Vec2F(0.45f, 0.2f), new Vec2F(0.001f, 0.015f)));~\\
\cellcolor{green} & 51 & \verb~68~ & & \verb~        levelTimer.SetTime(levelCreator.Time); // Timer for level is set~\\
\cellcolor{green} & 51 & \verb~69~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~70~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~71~ & & \verb~    /// Proceeses StatusEvents~\\
\cellcolor{gray} &  & \verb~72~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 767 & \verb~73~ & & \verb~    public void ProcessEvent(GameEvent gameEvent) {~\\
\cellcolor{green} & 1283 & \verb~74~ & & \verb~        if (gameEvent.EventType == GameEventType.StatusEvent) {~\\
\cellcolor{gray} &  & \verb~75~ & & \verb~            switch (gameEvent.Message) {~\\
\cellcolor{gray} &  & \verb~76~ & & \verb~                case "CLEAR":~\\
\cellcolor{green} & 156 & \verb~77~ & & \verb~                    blocks.ClearContainer();~\\
\cellcolor{green} & 156 & \verb~78~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~79~ & & \verb~                case "NEW BALL":~\\
\cellcolor{green} & 46 & \verb~80~ & & \verb~                    balls.AddEntity(BallCreator.CreateBall(new Vec2F(0.45f, 0.2f), new Vec2F(0.001f, 0.015f)));~\\
\cellcolor{green} & 46 & \verb~81~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~82~ & & \verb~                case "SPAWN POWERUP":~\\
\cellcolor{green} & 48 & \verb~83~ & & \verb~                    Vec2F pos = (Vec2F) gameEvent.ObjectArg1;~\\
\cellcolor{green} & 48 & \verb~84~ & & \verb~                    powerups.AddEntity(PowerUpCreator.CreatePowerUp(pos));~\\
\cellcolor{green} & 48 & \verb~85~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~86~ & & \verb~                case "HARD BALL":~\\
\cellcolor{green} & 42 & \verb~87~ & & \verb~                    if (gameEvent.StringArg1 == "START") {~\\
\cellcolor{green} & 20 & \verb~88~ & & \verb~                        hardBalls = true;~\\
\cellcolor{green} & 24 & \verb~89~ & & \verb~                    } else if (gameEvent.StringArg1 == "END") {~\\
\cellcolor{green} & 2 & \verb~90~ & & \verb~                        hardBalls = false;~\\
\cellcolor{green} & 2 & \verb~91~ & & \verb~                    }~\\
\cellcolor{green} & 22 & \verb~92~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~93~ & & \verb~                case "SPLIT":~\\
\cellcolor{green} & 168 & \verb~94~ & & \verb~                    balls.Iterate(ball => {~\\
\cellcolor{green} & 219 & \verb~95~ & & \verb~                        if (balls.CountEntities() < 18) { // amount of balls that can be added is capped to 18~\\
\cellcolor{green} & 87 & \verb~96~ & & \verb~                            pos = ball.Shape.Position;~\\
\cellcolor{green} & 36 & \verb~97~ & & \verb~                            // 2 balls are added that go in different directions~\\
\cellcolor{green} & 87 & \verb~98~ & & \verb~                            balls.AddEntity(BallCreator.CreateBall(pos, new Vec2F(-0.0106f, 0.0106f)));~\\
\cellcolor{green} & 87 & \verb~99~ & & \verb~                            balls.AddEntity(BallCreator.CreateBall(pos, new Vec2F(0.0106f, 0.0106f)));~\\
\cellcolor{green} & 87 & \verb~100~ & & \verb~                        }~\\
\cellcolor{green} & 168 & \verb~101~ & & \verb~                    });~\\
\cellcolor{green} & 36 & \verb~102~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~103~ & & \verb~            }~\\
\cellcolor{green} & 516 & \verb~104~ & & \verb~        }~\\
\cellcolor{green} & 767 & \verb~105~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~106~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~107~ & & \verb~    /// Checks wheter if the level is containing any blocks that arent unbreakable.~\\
\cellcolor{gray} &  & \verb~108~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~109~ & & \verb~    /// <returns>false if level has blocks other than unbreakable blocks, else true.</returns>~\\
\cellcolor{green} & 12 & \verb~110~ & & \verb~    public bool EmptyLevel() {~\\
\cellcolor{green} & 44 & \verb~111~ & & \verb~        foreach (Block block in blocks) {~\\
\cellcolor{orange} & 8 & \verb~112~ & & \verb~            if (block is not Unbreakable) {~\\
\cellcolor{green} & 4 & \verb~113~ & & \verb~                return false;~\\
\cellcolor{gray} &  & \verb~114~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~115~ & & \verb~        }~\\
\cellcolor{green} & 8 & \verb~116~ & & \verb~        return true;~\\
\cellcolor{green} & 12 & \verb~117~ & & \verb~    }~\\
\cellcolor{green} & 14 & \verb~118~ & & \verb~    private void MoveBalls() {~\\
\cellcolor{green} & 75 & \verb~119~ & & \verb~        foreach (Ball ball in balls) {~\\
\cellcolor{green} & 11 & \verb~120~ & & \verb~            ball.Move();~\\
\cellcolor{green} & 11 & \verb~121~ & & \verb~        }~\\
\cellcolor{green} & 14 & \verb~122~ & & \verb~    }~\\
\cellcolor{green} & 14 & \verb~123~ & & \verb~    private void MovePowerups() {~\\
\cellcolor{orange} & 42 & \verb~124~ & & \verb~        foreach (Powerup powerup in powerups) {~\\
\cellcolor{red} & 0 & \verb~125~ & & \verb~            powerup.Move();~\\
\cellcolor{red} & 0 & \verb~126~ & & \verb~        }~\\
\cellcolor{green} & 14 & \verb~127~ & & \verb~    }~\\
\cellcolor{green} & 14 & \verb~128~ & & \verb~    private void CheckCollisions() {~\\
\cellcolor{green} & 14 & \verb~129~ & & \verb~        PlayerCollision.Collide(balls, player);~\\
\cellcolor{green} & 14 & \verb~130~ & & \verb~        BlockCollision.Collide(balls, blocks, hardBalls);~\\
\cellcolor{green} & 14 & \verb~131~ & & \verb~        WallCollision.Collide(balls);~\\
\cellcolor{green} & 14 & \verb~132~ & & \verb~        PowerUpCollision.Collide(powerups, player);~\\
\cellcolor{green} & 14 & \verb~133~ & & \verb~    }~\\
\cellcolor{green} & 14 & \verb~134~ & & \verb~    private void CheckTime() {~\\
\cellcolor{green} & 17 & \verb~135~ & & \verb~        if (levelTimer.TimeLeft < 1) {~\\
\cellcolor{green} & 3 & \verb~136~ & & \verb~            BreakoutBus.GetBus().RegisterEvent(new GameEvent {~\\
\cellcolor{green} & 3 & \verb~137~ & & \verb~                EventType = GameEventType.GameStateEvent,~\\
\cellcolor{green} & 3 & \verb~138~ & & \verb~                Message = "CHANGE_STATE",~\\
\cellcolor{green} & 3 & \verb~139~ & & \verb~                StringArg1 = "GAME_LOST"~\\
\cellcolor{green} & 3 & \verb~140~ & & \verb~            });~\\
\cellcolor{green} & 3 & \verb~141~ & & \verb~        }~\\
\cellcolor{green} & 14 & \verb~142~ & & \verb~    }~\\
\cellcolor{red} & 0 & \verb~143~ & & \verb~    public void Render() {~\\
\cellcolor{red} & 0 & \verb~144~ & & \verb~        player.Render();~\\
\cellcolor{red} & 0 & \verb~145~ & & \verb~        blocks.RenderEntities();~\\
\cellcolor{red} & 0 & \verb~146~ & & \verb~        balls.RenderEntities();~\\
\cellcolor{red} & 0 & \verb~147~ & & \verb~        powerups.RenderEntities();~\\
\cellcolor{red} & 0 & \verb~148~ & & \verb~        if (levelCreator.HasTimer) {~\\
\cellcolor{red} & 0 & \verb~149~ & & \verb~            levelTimer.Render();~\\
\cellcolor{red} & 0 & \verb~150~ & & \verb~        }~\\
\cellcolor{red} & 0 & \verb~151~ & & \verb~    }~\\
\cellcolor{green} & 14 & \verb~152~ & & \verb~    public void Update() {~\\
\cellcolor{green} & 14 & \verb~153~ & & \verb~        CheckCollisions();~\\
\cellcolor{green} & 14 & \verb~154~ & & \verb~        CheckTime();~\\
\cellcolor{green} & 14 & \verb~155~ & & \verb~        player.Move();~\\
\cellcolor{green} & 14 & \verb~156~ & & \verb~        MoveBalls();~\\
\cellcolor{green} & 14 & \verb~157~ & & \verb~        MovePowerups();~\\
\cellcolor{green} & 14 & \verb~158~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~159~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.Levels.LevelReader}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.Levels.LevelReader\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/Breakout/LevelLoading/LevelReader.cs}\end{minipage} \\
\textbf{Covered lines:} & 76\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 76\\
\textbf{Total lines:} & 111\\
\textbf{Line coverage:} & 100\% (76 of 76)\\
\textbf{Covered branches:} & 30\\
\textbf{Total branches:} & 32\\
\textbf{Branch coverage:} & 93.7\% (30 of 32)\\
\textbf{Covered methods:} & 8\\
\textbf{Total methods:} & 8\\
\textbf{Method coverage:} & 100\% (8 of 8)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{get\_Legend()} & 100\% & 1 & 100\%\\
\hline
\textbf{get\_Meta()} & 100\% & 1 & 100\%\\
\hline
\textbf{.ctor()} & 100\% & 1 & 100\%\\
\hline
\textbf{ReadLevel(...)} & 100\% & 2 & 100\%\\
\hline
\textbf{MapValid()} & 100\% & 6 & 100\%\\
\hline
\textbf{ReadMap()} & 83.33\% & 6 & 100\%\\
\hline
\textbf{ReadMeta()} & 100\% & 10 & 100\%\\
\hline
\textbf{ReadLegend()} & 87.50\% & 8 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/Breakout/LevelLoading/LevelReader.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~namespace Breakout.Levels;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~/// <summary>~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~/// A levelReader used in Level to extract Map, Meta and Legend from a txt file.~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~/// </summary>~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~public class LevelReader {~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~    private string path;~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    private string[] txtlines;~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    private Dictionary<string, string> meta;~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~    private Dictionary<char, string> legend;~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~    public string[] Map;~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~    public Dictionary<char, string> Legend {~\\
\cellcolor{green} & 394 & \verb~16~ & & \verb~        get => legend;~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~    public Dictionary<string, string> Meta {~\\
\cellcolor{green} & 379 & \verb~19~ & & \verb~        get => meta;~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~    }~\\
\cellcolor{green} & 138 & \verb~21~ & & \verb~    public LevelReader() {~\\
\cellcolor{green} & 69 & \verb~22~ & & \verb~        this.path = Path.Combine(Constants.MAIN_PATH, "Assets", "Levels");~\\
\cellcolor{green} & 69 & \verb~23~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~    /// Will try to read a level file. Reads mapdata, leveldata and metadata.~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~    /// <param name="level">the name of the level file that will be read</param>~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~    /// <returns>false if level file could not be read, else true.</returns>~\\
\cellcolor{green} & 72 & \verb~29~ & & \verb~    public bool ReadLevel(string level) {~\\
\cellcolor{green} & 72 & \verb~30~ & & \verb~        string txtfile = Path.Combine(path, level);~\\
\cellcolor{green} & 140 & \verb~31~ & & \verb~        if (File.Exists(txtfile)) {~\\
\cellcolor{green} & 68 & \verb~32~ & & \verb~            this.txtlines = File.ReadAllLines(txtfile);~\\
\cellcolor{green} & 68 & \verb~33~ & & \verb~            ReadMap();~\\
\cellcolor{green} & 68 & \verb~34~ & & \verb~            ReadMeta();~\\
\cellcolor{green} & 68 & \verb~35~ & & \verb~            ReadLegend();~\\
\cellcolor{green} & 68 & \verb~36~ & & \verb~            return true;~\\
\cellcolor{green} & 4 & \verb~37~ & & \verb~        } else {~\\
\cellcolor{green} & 4 & \verb~38~ & & \verb~            return false;~\\
\cellcolor{gray} &  & \verb~39~ & & \verb~        }~\\
\cellcolor{green} & 72 & \verb~40~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~42~ & & \verb~    /// Checks if current level is valid i.e that it contains a map, legendata and metadata.~\\
\cellcolor{gray} &  & \verb~43~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~44~ & & \verb~    /// <returns>true if level has map, meta and legendata, else false.</returns>~\\
\cellcolor{green} & 58 & \verb~45~ & & \verb~    public bool MapValid() {~\\
\cellcolor{green} & 114 & \verb~46~ & & \verb~        if (Map != null && Legend != null && Meta != null) {~\\
\cellcolor{green} & 56 & \verb~47~ & & \verb~            return true;~\\
\cellcolor{green} & 2 & \verb~48~ & & \verb~        } else {~\\
\cellcolor{green} & 2 & \verb~49~ & & \verb~            return false;~\\
\cellcolor{gray} &  & \verb~50~ & & \verb~        }~\\
\cellcolor{green} & 58 & \verb~51~ & & \verb~    }~\\
\cellcolor{green} & 68 & \verb~52~ & & \verb~    private void ReadMap() {~\\
\cellcolor{orange} & 68 & \verb~53~ & & \verb~        if (Array.IndexOf(txtlines, "Map:") == -1 ||~\\
\cellcolor{green} & 69 & \verb~54~ & & \verb~            Array.IndexOf(txtlines, "Map/") == -1) {~\\
\cellcolor{gray} &  & \verb~55~ & & \verb~            // txt file dosent contain a start or end to Map section.~\\
\cellcolor{green} & 1 & \verb~56~ & & \verb~            Map = null;~\\
\cellcolor{green} & 68 & \verb~57~ & & \verb~        } else {~\\
\cellcolor{green} & 67 & \verb~58~ & & \verb~            int MapStart = Array.IndexOf(txtlines, "Map:");~\\
\cellcolor{green} & 67 & \verb~59~ & & \verb~            int MapEnd = Array.IndexOf(txtlines, "Map/");~\\
\cellcolor{green} & 67 & \verb~60~ & & \verb~            Map = new string[MapEnd - 2];~\\
\cellcolor{green} & 4952 & \verb~61~ & & \verb~            for (int i = MapStart + 1; i < MapEnd - 1; i++) {~\\
\cellcolor{green} & 1606 & \verb~62~ & & \verb~                Map[i - 1] = txtlines[i];~\\
\cellcolor{green} & 1606 & \verb~63~ & & \verb~            }~\\
\cellcolor{green} & 67 & \verb~64~ & & \verb~        }~\\
\cellcolor{green} & 68 & \verb~65~ & & \verb~    }~\\
\cellcolor{green} & 68 & \verb~66~ & & \verb~    private void ReadMeta() {~\\
\cellcolor{green} & 68 & \verb~67~ & & \verb~        if (Array.IndexOf(txtlines, "Meta:") == -1 ||~\\
\cellcolor{green} & 69 & \verb~68~ & & \verb~            Array.IndexOf(txtlines, "Meta/") == -1) {~\\
\cellcolor{gray} &  & \verb~69~ & & \verb~            // txt file dosent contain a start or end to Meta section.~\\
\cellcolor{green} & 1 & \verb~70~ & & \verb~            meta = null;~\\
\cellcolor{green} & 68 & \verb~71~ & & \verb~        } else {~\\
\cellcolor{green} & 67 & \verb~72~ & & \verb~            int MetaStart = Array.IndexOf(txtlines, "Meta:");~\\
\cellcolor{green} & 67 & \verb~73~ & & \verb~            int MetaEnd = Array.IndexOf(txtlines, "Meta/");~\\
\cellcolor{green} & 67 & \verb~74~ & & \verb~            meta = new Dictionary<string, string>();~\\
\cellcolor{green} & 905 & \verb~75~ & & \verb~            for (int i = MetaStart + 1; i < MetaEnd; i++) {~\\
\cellcolor{green} & 257 & \verb~76~ & & \verb~                string[] parts = txtlines[i].Split(": ");~\\
\cellcolor{green} & 514 & \verb~77~ & & \verb~                if (parts.Length == 2) {~\\
\cellcolor{gray} &  & \verb~78~ & & \verb~                    // meta section contains ": " and can be spilt in 2~\\
\cellcolor{green} & 257 & \verb~79~ & & \verb~                    string key = parts[0];~\\
\cellcolor{green} & 257 & \verb~80~ & & \verb~                    string value = parts[1];~\\
\cellcolor{green} & 385 & \verb~81~ & & \verb~                    if (value.Length == 1) {~\\
\cellcolor{gray} &  & \verb~82~ & & \verb~                        // value is a block symbol therefore switched around~\\
\cellcolor{green} & 128 & \verb~83~ & & \verb~                        Meta[value] = key;~\\
\cellcolor{green} & 257 & \verb~84~ & & \verb~                    } else {~\\
\cellcolor{green} & 129 & \verb~85~ & & \verb~                        Meta[key] = value;~\\
\cellcolor{green} & 129 & \verb~86~ & & \verb~                    }~\\
\cellcolor{green} & 257 & \verb~87~ & & \verb~                }~\\
\cellcolor{green} & 257 & \verb~88~ & & \verb~            }~\\
\cellcolor{green} & 67 & \verb~89~ & & \verb~        }~\\
\cellcolor{green} & 68 & \verb~90~ & & \verb~    }~\\
\cellcolor{green} & 68 & \verb~91~ & & \verb~    private void ReadLegend() {~\\
\cellcolor{orange} & 68 & \verb~92~ & & \verb~        if (Array.IndexOf(txtlines, "Legend:") == -1 ||~\\
\cellcolor{green} & 69 & \verb~93~ & & \verb~            Array.IndexOf(txtlines, "Legend/") == -1) {~\\
\cellcolor{gray} &  & \verb~94~ & & \verb~            // txt file dosent contain a start or end to Legend section.~\\
\cellcolor{green} & 1 & \verb~95~ & & \verb~            legend = null;~\\
\cellcolor{green} & 68 & \verb~96~ & & \verb~        } else {~\\
\cellcolor{green} & 67 & \verb~97~ & & \verb~            int legendStart = Array.IndexOf(txtlines, "Legend:");~\\
\cellcolor{green} & 67 & \verb~98~ & & \verb~            int legendEnd = Array.IndexOf(txtlines, "Legend/");~\\
\cellcolor{green} & 67 & \verb~99~ & & \verb~            legend = new Dictionary<char, string>();~\\
\cellcolor{green} & 947 & \verb~100~ & & \verb~            for (int i = legendStart + 1; i < legendEnd; i++) {~\\
\cellcolor{green} & 271 & \verb~101~ & & \verb~                char symbol = txtlines[i][0];~\\
\cellcolor{green} & 271 & \verb~102~ & & \verb~                string imagefile = txtlines[i].Substring(3);~\\
\cellcolor{green} & 271 & \verb~103~ & & \verb~                string imagepath = Path.Combine(~\\
\cellcolor{green} & 271 & \verb~104~ & & \verb~                    path.Replace(@"Levels", "Images/"), imagefile);~\\
\cellcolor{green} & 542 & \verb~105~ & & \verb~                if (File.Exists(imagepath)) {~\\
\cellcolor{green} & 271 & \verb~106~ & & \verb~                    Legend[symbol] = imagefile;~\\
\cellcolor{green} & 271 & \verb~107~ & & \verb~                }~\\
\cellcolor{green} & 271 & \verb~108~ & & \verb~            }~\\
\cellcolor{green} & 67 & \verb~109~ & & \verb~        }~\\
\cellcolor{green} & 68 & \verb~110~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~111~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.Players.Player}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.Players.Player\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/Breakout/Player/Player.cs}\end{minipage} \\
\textbf{Covered lines:} & 70\\
\textbf{Uncovered lines:} & 6\\
\textbf{Coverable lines:} & 76\\
\textbf{Total lines:} & 112\\
\textbf{Line coverage:} & 92.1\% (70 of 76)\\
\textbf{Covered branches:} & 54\\
\textbf{Total branches:} & 54\\
\textbf{Branch coverage:} & 100\% (54 of 54)\\
\textbf{Covered methods:} & 8\\
\textbf{Total methods:} & 10\\
\textbf{Method coverage:} & 80\% (8 of 10)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{get\_\_Shape()} & 100\% & 1 & 0\%\\
\hline
\textbf{get\_MovementSpeed()} & 100\% & 1 & 100\%\\
\hline
\textbf{ProcessEvent(...)} & 100\% & 46 & 100\%\\
\hline
\textbf{UpdateDirection()} & 100\% & 1 & 100\%\\
\hline
\textbf{Move()} & 100\% & 4 & 100\%\\
\hline
\textbf{SetMoveLeft(...)} & 100\% & 2 & 100\%\\
\hline
\textbf{SetMoveRight(...)} & 100\% & 2 & 100\%\\
\hline
\textbf{GetPosition()} & 100\% & 1 & 100\%\\
\hline
\textbf{Render()} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/Breakout/Player/Player.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Events;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~namespace Breakout.Players;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~/// <summary>~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~///  A player entity that can move around~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~/// </summary>~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~public class Player : Entity, IGameEventProcessor {~\\
\cellcolor{green} & 84 & \verb~10~ & & \verb~    private float moveLeft = 0.0f;~\\
\cellcolor{green} & 84 & \verb~11~ & & \verb~    private float moveRight = 0.0f;~\\
\cellcolor{green} & 84 & \verb~12~ & & \verb~    private float movementSpeed = 0.01f;~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~    private DynamicShape shape;~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~    public DynamicShape _Shape {~\\
\cellcolor{red} & 0 & \verb~15~ & & \verb~        get {~\\
\cellcolor{red} & 0 & \verb~16~ & & \verb~            return shape;~\\
\cellcolor{red} & 0 & \verb~17~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~    public float MovementSpeed {~\\
\cellcolor{green} & 6 & \verb~20~ & & \verb~        get => movementSpeed; set => movementSpeed = value;~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~~\\
\cellcolor{green} & 168 & \verb~23~ & & \verb~    public Player(DynamicShape shape, IBaseImage image) : base(shape, image) {~\\
\cellcolor{green} & 84 & \verb~24~ & & \verb~        this.shape = base.Shape.AsDynamicShape();~\\
\cellcolor{green} & 84 & \verb~25~ & & \verb~        BreakoutBus.GetBus().Subscribe(GameEventType.PlayerEvent, this);~\\
\cellcolor{green} & 84 & \verb~26~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~    ///  processes playerEvents such as power-ups and movement events~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 331 & \verb~30~ & & \verb~    public void ProcessEvent(GameEvent gameEvent) {~\\
\cellcolor{green} & 662 & \verb~31~ & & \verb~        if (gameEvent.EventType == GameEventType.PlayerEvent) {~\\
\cellcolor{green} & 331 & \verb~32~ & & \verb~            switch (gameEvent.Message) {~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~                case "MOVE LEFT":~\\
\cellcolor{green} & 65 & \verb~34~ & & \verb~                    SetMoveLeft(true);~\\
\cellcolor{green} & 65 & \verb~35~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~                case "MOVE RIGHT":~\\
\cellcolor{green} & 67 & \verb~37~ & & \verb~                    SetMoveRight(true);~\\
\cellcolor{green} & 67 & \verb~38~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~39~ & & \verb~                case "RELEASE LEFT":~\\
\cellcolor{green} & 62 & \verb~40~ & & \verb~                    SetMoveLeft(false);~\\
\cellcolor{green} & 62 & \verb~41~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~42~ & & \verb~                case "RELEASE RIGHT":~\\
\cellcolor{green} & 63 & \verb~43~ & & \verb~                    SetMoveRight(false);~\\
\cellcolor{green} & 63 & \verb~44~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~45~ & & \verb~                case "SLIM JIM":~\\
\cellcolor{green} & 47 & \verb~46~ & & \verb~                    if (gameEvent.StringArg1 == "START") {~\\
\cellcolor{green} & 23 & \verb~47~ & & \verb~                        shape.Extent.X = 0.075f;~\\
\cellcolor{green} & 25 & \verb~48~ & & \verb~                    } else if (gameEvent.StringArg1 == "END") {~\\
\cellcolor{green} & 1 & \verb~49~ & & \verb~                        shape.Extent.X = 0.15f;~\\
\cellcolor{green} & 1 & \verb~50~ & & \verb~                    }~\\
\cellcolor{green} & 24 & \verb~51~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~52~ & & \verb~                case "WIDE":~\\
\cellcolor{green} & 53 & \verb~53~ & & \verb~                    if (gameEvent.StringArg1 == "START") {~\\
\cellcolor{green} & 26 & \verb~54~ & & \verb~                        shape.Extent.X = 0.30f;~\\
\cellcolor{green} & 28 & \verb~55~ & & \verb~                    } else if (gameEvent.StringArg1 == "END") {~\\
\cellcolor{green} & 1 & \verb~56~ & & \verb~                        shape.Extent.X = 0.15f;~\\
\cellcolor{green} & 1 & \verb~57~ & & \verb~                    }~\\
\cellcolor{green} & 27 & \verb~58~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~59~ & & \verb~                case "SPEED":~\\
\cellcolor{green} & 43 & \verb~60~ & & \verb~                    if (gameEvent.StringArg1 == "START") {~\\
\cellcolor{green} & 21 & \verb~61~ & & \verb~                        movementSpeed = 0.02f;~\\
\cellcolor{green} & 23 & \verb~62~ & & \verb~                    } else if (gameEvent.StringArg1 == "END") {~\\
\cellcolor{green} & 1 & \verb~63~ & & \verb~                        movementSpeed = 0.01f;~\\
\cellcolor{green} & 1 & \verb~64~ & & \verb~                    }~\\
\cellcolor{green} & 22 & \verb~65~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~66~ & & \verb~            }~\\
\cellcolor{green} & 331 & \verb~67~ & & \verb~        }~\\
\cellcolor{green} & 331 & \verb~68~ & & \verb~    }~\\
\cellcolor{green} & 257 & \verb~69~ & & \verb~    private void UpdateDirection() {~\\
\cellcolor{green} & 257 & \verb~70~ & & \verb~        shape.Direction.X = moveLeft + moveRight;~\\
\cellcolor{green} & 257 & \verb~71~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~72~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~73~ & & \verb~    ///  Moves player based on directional vector~\\
\cellcolor{gray} &  & \verb~74~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 39 & \verb~75~ & & \verb~    public void Move() {~\\
\cellcolor{green} & 39 & \verb~76~ & & \verb~        shape.Move();~\\
\cellcolor{green} & 42 & \verb~77~ & & \verb~        if (shape.Position.X <= 0.0f) {~\\
\cellcolor{green} & 3 & \verb~78~ & & \verb~            shape.Position.X = 0.0f;~\\
\cellcolor{green} & 42 & \verb~79~ & & \verb~        } else if ((shape.Position.X + shape.Extent.X) >= 1.0f) {~\\
\cellcolor{green} & 3 & \verb~80~ & & \verb~            shape.Position.X = 1.0f - shape.Extent.X;~\\
\cellcolor{green} & 3 & \verb~81~ & & \verb~        }~\\
\cellcolor{green} & 39 & \verb~82~ & & \verb~    }~\\
\cellcolor{green} & 127 & \verb~83~ & & \verb~    private void SetMoveLeft(bool val) {~\\
\cellcolor{green} & 192 & \verb~84~ & & \verb~        if (val) {~\\
\cellcolor{green} & 65 & \verb~85~ & & \verb~            moveLeft = -movementSpeed;~\\
\cellcolor{green} & 127 & \verb~86~ & & \verb~        } else {~\\
\cellcolor{green} & 62 & \verb~87~ & & \verb~            moveLeft = 0.0f;~\\
\cellcolor{green} & 62 & \verb~88~ & & \verb~        }~\\
\cellcolor{green} & 127 & \verb~89~ & & \verb~        UpdateDirection();~\\
\cellcolor{green} & 127 & \verb~90~ & & \verb~    }~\\
\cellcolor{green} & 130 & \verb~91~ & & \verb~    private void SetMoveRight(bool val) {~\\
\cellcolor{green} & 197 & \verb~92~ & & \verb~        if (val) {~\\
\cellcolor{green} & 67 & \verb~93~ & & \verb~            moveRight = movementSpeed;~\\
\cellcolor{green} & 130 & \verb~94~ & & \verb~        } else {~\\
\cellcolor{green} & 63 & \verb~95~ & & \verb~            moveRight = 0.0f;~\\
\cellcolor{green} & 63 & \verb~96~ & & \verb~        }~\\
\cellcolor{green} & 130 & \verb~97~ & & \verb~        UpdateDirection();~\\
\cellcolor{green} & 130 & \verb~98~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~99~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~100~ & & \verb~    ///  Gets vector position of the player~\\
\cellcolor{gray} &  & \verb~101~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 16 & \verb~102~ & & \verb~    public Vec2F GetPosition() {~\\
\cellcolor{green} & 16 & \verb~103~ & & \verb~        Vec2F position = new Vec2F(shape.Position.X, shape.Position.Y);~\\
\cellcolor{green} & 16 & \verb~104~ & & \verb~        return (position);~\\
\cellcolor{green} & 16 & \verb~105~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~106~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~107~ & & \verb~    ///  Renders the player~\\
\cellcolor{gray} &  & \verb~108~ & & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~109~ & & \verb~    public void Render() {~\\
\cellcolor{red} & 0 & \verb~110~ & & \verb~        RenderEntity();~\\
\cellcolor{red} & 0 & \verb~111~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~112~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.Points}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.Points\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/Breakout/Points.cs}\end{minipage} \\
\textbf{Covered lines:} & 31\\
\textbf{Uncovered lines:} & 3\\
\textbf{Coverable lines:} & 34\\
\textbf{Total lines:} & 66\\
\textbf{Line coverage:} & 91.1\% (31 of 34)\\
\textbf{Covered branches:} & 6\\
\textbf{Total branches:} & 6\\
\textbf{Branch coverage:} & 100\% (6 of 6)\\
\textbf{Covered methods:} & 6\\
\textbf{Total methods:} & 7\\
\textbf{Method coverage:} & 85.7\% (6 of 7)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor()} & 100\% & 1 & 100\%\\
\hline
\textbf{GetInstance()} & 100\% & 2 & 100\%\\
\hline
\textbf{ProcessEvent(...)} & 100\% & 4 & 100\%\\
\hline
\textbf{ResetPoints()} & 100\% & 1 & 100\%\\
\hline
\textbf{GetPoints()} & 100\% & 1 & 100\%\\
\hline
\textbf{UpdateText()} & 100\% & 1 & 100\%\\
\hline
\textbf{Render()} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/Breakout/Points.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Events;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~namespace Breakout;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~/// <summary>~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~/// In-game points to be rendered on screen.~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~/// </summary>~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~public class Points : IGameEventProcessor {~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~    private static Points instance = null;~\\
\cellcolor{green} & 74 & \verb~10~ & & \verb~    private int points = 0;~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    private Text pointText;~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~    private Vec3I white;~\\
\cellcolor{green} & 148 & \verb~13~ & & \verb~    public Points() {~\\
\cellcolor{green} & 74 & \verb~14~ & & \verb~        BreakoutBus.GetBus().Subscribe(GameEventType.StatusEvent, this);~\\
\cellcolor{green} & 74 & \verb~15~ & & \verb~        pointText = new Text($"Points: {points}",~\\
\cellcolor{green} & 74 & \verb~16~ & & \verb~            new Vec2F(0.4f, -0.285f), new Vec2F(0.25f, 0.35f));~\\
\cellcolor{green} & 74 & \verb~17~ & & \verb~        white = new Vec3I(255, 255, 255);~\\
\cellcolor{green} & 74 & \verb~18~ & & \verb~        pointText.SetColor(white);~\\
\cellcolor{green} & 74 & \verb~19~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~    /// Retrieves or creates and instance of points~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 360 & \verb~23~ & & \verb~    public static Points GetInstance() {~\\
\cellcolor{green} & 434 & \verb~24~ & & \verb~        if (Points.instance == null) {~\\
\cellcolor{green} & 74 & \verb~25~ & & \verb~            Points.instance = new Points();~\\
\cellcolor{green} & 74 & \verb~26~ & & \verb~        }~\\
\cellcolor{green} & 360 & \verb~27~ & & \verb~        return Points.instance;~\\
\cellcolor{green} & 360 & \verb~28~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~    /// Procceses statusevents to get points~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 259 & \verb~32~ & & \verb~    public void ProcessEvent(GameEvent gameEvent) {~\\
\cellcolor{green} & 518 & \verb~33~ & & \verb~        if (gameEvent.EventType == GameEventType.StatusEvent) {~\\
\cellcolor{green} & 259 & \verb~34~ & & \verb~            switch (gameEvent.Message) {~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~                case "GET POINTS":~\\
\cellcolor{green} & 45 & \verb~36~ & & \verb~                    points += gameEvent.IntArg1;~\\
\cellcolor{green} & 45 & \verb~37~ & & \verb~                    UpdateText();~\\
\cellcolor{green} & 45 & \verb~38~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~39~ & & \verb~            }~\\
\cellcolor{green} & 259 & \verb~40~ & & \verb~        }~\\
\cellcolor{green} & 259 & \verb~41~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~42~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~43~ & & \verb~    /// Resets point score~\\
\cellcolor{gray} &  & \verb~44~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 74 & \verb~45~ & & \verb~    public void ResetPoints() {~\\
\cellcolor{green} & 74 & \verb~46~ & & \verb~        Points.instance = null;~\\
\cellcolor{green} & 74 & \verb~47~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~48~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~    /// Gets the point score~\\
\cellcolor{gray} &  & \verb~50~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 237 & \verb~51~ & & \verb~    public int GetPoints() {~\\
\cellcolor{green} & 237 & \verb~52~ & & \verb~        return points;~\\
\cellcolor{green} & 237 & \verb~53~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~54~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~55~ & & \verb~    /// Updates points text to be rendered on screen.~\\
\cellcolor{gray} &  & \verb~56~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 45 & \verb~57~ & & \verb~    private void UpdateText() {~\\
\cellcolor{green} & 45 & \verb~58~ & & \verb~        pointText.SetText($"Points: {points}");~\\
\cellcolor{green} & 45 & \verb~59~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~60~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~61~ & & \verb~    /// Renders Points on screen.~\\
\cellcolor{gray} &  & \verb~62~ & & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~63~ & & \verb~    public void Render() {~\\
\cellcolor{red} & 0 & \verb~64~ & & \verb~        pointText.RenderText();~\\
\cellcolor{red} & 0 & \verb~65~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~66~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.Powerups.HardBall}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.Powerups.HardBall\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/Breakout/Powerups/HardBall.cs}\end{minipage} \\
\textbf{Covered lines:} & 15\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 15\\
\textbf{Total lines:} & 27\\
\textbf{Line coverage:} & 100\% (15 of 15)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 2\\
\textbf{Total methods:} & 2\\
\textbf{Method coverage:} & 100\% (2 of 2)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{Effect()} & 100\% & 1 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/Breakout/Powerups/HardBall.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Events;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using DIKUArcade.Timers;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~namespace Breakout.Powerups;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~/// <summary>~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~/// Balls destroy blocks regardless of health and don't change direction when hitting blocks.~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~/// The powerup is timed and therefore temporary~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~/// </summary>~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~public class HardBall : Powerup {~\\
\cellcolor{green} & 16 & \verb~12~ & & \verb~    public HardBall(DynamicShape shape) : base(shape, new Image(~\\
\cellcolor{green} & 32 & \verb~13~ & & \verb~        Path.Combine("..", "Breakout", "Assets", "Images", "ExtraBallPowerUp.png"))) {~\\
\cellcolor{green} & 16 & \verb~14~ & & \verb~    }~\\
\cellcolor{green} & 2 & \verb~15~ & & \verb~    public override void Effect() {~\\
\cellcolor{green} & 2 & \verb~16~ & & \verb~        BreakoutBus.GetBus().RegisterEvent(new GameEvent {~\\
\cellcolor{green} & 2 & \verb~17~ & & \verb~            EventType = GameEventType.StatusEvent,~\\
\cellcolor{green} & 2 & \verb~18~ & & \verb~            Message = "HARD BALL",~\\
\cellcolor{green} & 2 & \verb~19~ & & \verb~            StringArg1 = "START"~\\
\cellcolor{green} & 2 & \verb~20~ & & \verb~        });~\\
\cellcolor{green} & 2 & \verb~21~ & & \verb~        BreakoutBus.GetBus().RegisterTimedEvent(new GameEvent {~\\
\cellcolor{green} & 2 & \verb~22~ & & \verb~            EventType = GameEventType.StatusEvent,~\\
\cellcolor{green} & 2 & \verb~23~ & & \verb~            Message = "HARD BALL",~\\
\cellcolor{green} & 2 & \verb~24~ & & \verb~            StringArg1 = "END"~\\
\cellcolor{green} & 2 & \verb~25~ & & \verb~        }, TimePeriod.NewSeconds(10.0));~\\
\cellcolor{green} & 2 & \verb~26~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.Powerups.LifeLoss}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.Powerups.LifeLoss\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/Breakout/Powerups/Hazards/LifeLoss.cs}\end{minipage} \\
\textbf{Covered lines:} & 9\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 9\\
\textbf{Total lines:} & 19\\
\textbf{Line coverage:} & 100\% (9 of 9)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 2\\
\textbf{Total methods:} & 2\\
\textbf{Method coverage:} & 100\% (2 of 2)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{Effect()} & 100\% & 1 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/Breakout/Powerups/Hazards/LifeLoss.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Events;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~namespace Breakout.Powerups;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~/// <summary>~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~/// When picked up, the powerup sends and event making~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~/// </summary>~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~public class LifeLoss : Powerup {~\\
\cellcolor{green} & 15 & \verb~10~ & & \verb~    public LifeLoss(DynamicShape shape) : base(shape, new Image(~\\
\cellcolor{green} & 30 & \verb~11~ & & \verb~        Path.Combine("..", "Breakout", "Assets", "Images", "LoseLife.png"))) {~\\
\cellcolor{green} & 15 & \verb~12~ & & \verb~    }~\\
\cellcolor{green} & 1 & \verb~13~ & & \verb~    public override void Effect() {~\\
\cellcolor{green} & 1 & \verb~14~ & & \verb~        BreakoutBus.GetBus().RegisterEvent(new GameEvent {~\\
\cellcolor{green} & 1 & \verb~15~ & & \verb~            EventType = GameEventType.StatusEvent,~\\
\cellcolor{green} & 1 & \verb~16~ & & \verb~            Message = "LOSE HEALTH",~\\
\cellcolor{green} & 1 & \verb~17~ & & \verb~        });~\\
\cellcolor{green} & 1 & \verb~18~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.Powerups.LifePlus}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.Powerups.LifePlus\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/Breakout/Powerups/LifePlus.cs}\end{minipage} \\
\textbf{Covered lines:} & 10\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 10\\
\textbf{Total lines:} & 21\\
\textbf{Line coverage:} & 100\% (10 of 10)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 2\\
\textbf{Total methods:} & 2\\
\textbf{Method coverage:} & 100\% (2 of 2)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{Effect()} & 100\% & 1 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/Breakout/Powerups/LifePlus.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Events;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~namespace Breakout.Powerups;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~/// <summary>~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~/// When picked up, the powerup sends an event making health increase~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~/// </summary>~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~public class LifePlus : Powerup {~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    public LifePlus(DynamicShape shape) :~\\
\cellcolor{green} & 13 & \verb~11~ & & \verb~        base(shape, new Image(~\\
\cellcolor{green} & 26 & \verb~12~ & & \verb~            Path.Combine("..", "Breakout", "Assets", "Images", "LifePickUp.png"))) {~\\
\cellcolor{green} & 13 & \verb~13~ & & \verb~    }~\\
\cellcolor{green} & 1 & \verb~14~ & & \verb~    public override void Effect() {~\\
\cellcolor{green} & 1 & \verb~15~ & & \verb~        BreakoutBus.GetBus().RegisterEvent(new GameEvent {~\\
\cellcolor{green} & 1 & \verb~16~ & & \verb~            EventType = GameEventType.StatusEvent,~\\
\cellcolor{green} & 1 & \verb~17~ & & \verb~            Message = "GET HEALTH",~\\
\cellcolor{green} & 1 & \verb~18~ & & \verb~            IntArg1 = 1~\\
\cellcolor{green} & 1 & \verb~19~ & & \verb~        });~\\
\cellcolor{green} & 1 & \verb~20~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.Powerups.PlayerSpeed}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.Powerups.PlayerSpeed\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/Breakout/Powerups/PlayerSpeed.cs}\end{minipage} \\
\textbf{Covered lines:} & 15\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 15\\
\textbf{Total lines:} & 27\\
\textbf{Line coverage:} & 100\% (15 of 15)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 2\\
\textbf{Total methods:} & 2\\
\textbf{Method coverage:} & 100\% (2 of 2)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{Effect()} & 100\% & 1 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/Breakout/Powerups/PlayerSpeed.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Events;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using DIKUArcade.Timers;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~namespace Breakout.Powerups;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~/// <summary>~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~/// When picked up, player movement speed increases by sending a PlayerEvent.~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~/// The powerup is timed and therefore temporary~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~/// </summary>~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~public class PlayerSpeed : Powerup {~\\
\cellcolor{green} & 8 & \verb~12~ & & \verb~    public PlayerSpeed(DynamicShape shape) : base(shape, new Image(~\\
\cellcolor{green} & 16 & \verb~13~ & & \verb~        Path.Combine("..", "Breakout", "Assets", "Images", "DoubleSpeedPowerUp.png"))) {~\\
\cellcolor{green} & 8 & \verb~14~ & & \verb~    }~\\
\cellcolor{green} & 1 & \verb~15~ & & \verb~    public override void Effect() {~\\
\cellcolor{green} & 1 & \verb~16~ & & \verb~        BreakoutBus.GetBus().RegisterEvent(new GameEvent {~\\
\cellcolor{green} & 1 & \verb~17~ & & \verb~            EventType = GameEventType.PlayerEvent,~\\
\cellcolor{green} & 1 & \verb~18~ & & \verb~            Message = "SPEED",~\\
\cellcolor{green} & 1 & \verb~19~ & & \verb~            StringArg1 = "START"~\\
\cellcolor{green} & 1 & \verb~20~ & & \verb~        });~\\
\cellcolor{green} & 1 & \verb~21~ & & \verb~        BreakoutBus.GetBus().RegisterTimedEvent(new GameEvent {~\\
\cellcolor{green} & 1 & \verb~22~ & & \verb~            EventType = GameEventType.PlayerEvent,~\\
\cellcolor{green} & 1 & \verb~23~ & & \verb~            Message = "SPEED",~\\
\cellcolor{green} & 1 & \verb~24~ & & \verb~            StringArg1 = "END"~\\
\cellcolor{green} & 1 & \verb~25~ & & \verb~        }, TimePeriod.NewSeconds(10.0));~\\
\cellcolor{green} & 1 & \verb~26~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.Powerups.Powerup}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.Powerups.Powerup\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/Breakout/Powerups/Powerup.cs}\end{minipage} \\
\textbf{Covered lines:} & 8\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 8\\
\textbf{Total lines:} & 23\\
\textbf{Line coverage:} & 100\% (8 of 8)\\
\textbf{Covered branches:} & 2\\
\textbf{Total branches:} & 2\\
\textbf{Branch coverage:} & 100\% (2 of 2)\\
\textbf{Covered methods:} & 2\\
\textbf{Total methods:} & 2\\
\textbf{Method coverage:} & 100\% (2 of 2)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{Move()} & 100\% & 2 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/Breakout/Powerups/Powerup.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~namespace Breakout.Powerups;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~/// <summary>~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~/// An abstract powerup which allows powerups to move and activate an effect.~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~/// </summary>~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~public abstract class Powerup : Entity {~\\
\cellcolor{green} & 188 & \verb~8~ & & \verb~    public Powerup(DynamicShape shape, IBaseImage image) : base(shape, image) {~\\
\cellcolor{green} & 94 & \verb~9~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    /// Moves the powerup~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 5 & \verb~13~ & & \verb~    public void Move() {~\\
\cellcolor{green} & 5 & \verb~14~ & & \verb~        this.Shape.Move();~\\
\cellcolor{green} & 6 & \verb~15~ & & \verb~        if (Shape.Position.Y <= 0.0 - Shape.Extent.Y) {~\\
\cellcolor{green} & 1 & \verb~16~ & & \verb~            DeleteEntity();~\\
\cellcolor{green} & 1 & \verb~17~ & & \verb~        }~\\
\cellcolor{green} & 5 & \verb~18~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~    /// Activates powerup effect, by sending a GameEvent.~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~    public abstract void Effect();~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.Powerups.PowerUpCreator}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.Powerups.PowerUpCreator\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/Breakout/Powerups/PowerupCreator.cs}\end{minipage} \\
\textbf{Covered lines:} & 34\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 34\\
\textbf{Total lines:} & 56\\
\textbf{Line coverage:} & 100\% (34 of 34)\\
\textbf{Covered branches:} & 7\\
\textbf{Total branches:} & 7\\
\textbf{Branch coverage:} & 100\% (7 of 7)\\
\textbf{Covered methods:} & 2\\
\textbf{Total methods:} & 2\\
\textbf{Method coverage:} & 100\% (2 of 2)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.cctor()} & 100\% & 1 & 100\%\\
\hline
\textbf{CreatePowerUp(...)} & 100\% & 7 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/Breakout/Powerups/PowerupCreator.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~namespace Breakout.Powerups;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~/// <summary>~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~///  Creates a Powerup~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~/// </summary>~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~public static class PowerUpCreator {~\\
\cellcolor{green} & 1 & \verb~10~ & & \verb~    private static Vec2F extent = new Vec2F(0.03f, 0.03f);~\\
\cellcolor{green} & 1 & \verb~11~ & & \verb~    private static Vec2F dir = new Vec2F(0.00f, -0.01f);~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~    ///  Creates a random powerup~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 81 & \verb~15~ & & \verb~    public static Powerup CreatePowerUp(Vec2F pos) {~\\
\cellcolor{green} & 81 & \verb~16~ & & \verb~        Random random = new Random();~\\
\cellcolor{green} & 81 & \verb~17~ & & \verb~        switch (random.Next(1, 8)) {~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~            case 1:~\\
\cellcolor{green} & 11 & \verb~19~ & & \verb~                return new LifePlus(new DynamicShape(~\\
\cellcolor{green} & 11 & \verb~20~ & & \verb~                pos,~\\
\cellcolor{green} & 11 & \verb~21~ & & \verb~                extent,~\\
\cellcolor{green} & 11 & \verb~22~ & & \verb~                dir));~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~            case 2:~\\
\cellcolor{green} & 14 & \verb~24~ & & \verb~                return new LifeLoss(new DynamicShape(~\\
\cellcolor{green} & 14 & \verb~25~ & & \verb~                pos,~\\
\cellcolor{green} & 14 & \verb~26~ & & \verb~                extent,~\\
\cellcolor{green} & 14 & \verb~27~ & & \verb~                dir));~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~            case 3:~\\
\cellcolor{green} & 12 & \verb~29~ & & \verb~                return new Wide(new DynamicShape(~\\
\cellcolor{green} & 12 & \verb~30~ & & \verb~                pos,~\\
\cellcolor{green} & 12 & \verb~31~ & & \verb~                extent,~\\
\cellcolor{green} & 12 & \verb~32~ & & \verb~                dir));~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~            case 4:~\\
\cellcolor{green} & 10 & \verb~34~ & & \verb~                return new SlimJim(new DynamicShape(~\\
\cellcolor{green} & 10 & \verb~35~ & & \verb~                pos,~\\
\cellcolor{green} & 10 & \verb~36~ & & \verb~                extent,~\\
\cellcolor{green} & 10 & \verb~37~ & & \verb~                dir));~\\
\cellcolor{gray} &  & \verb~38~ & & \verb~            case 5:~\\
\cellcolor{green} & 6 & \verb~39~ & & \verb~                return new PlayerSpeed(new DynamicShape(~\\
\cellcolor{green} & 6 & \verb~40~ & & \verb~                pos,~\\
\cellcolor{green} & 6 & \verb~41~ & & \verb~                extent,~\\
\cellcolor{green} & 6 & \verb~42~ & & \verb~                dir));~\\
\cellcolor{gray} &  & \verb~43~ & & \verb~            case 6:~\\
\cellcolor{green} & 15 & \verb~44~ & & \verb~                return new Split(new DynamicShape(~\\
\cellcolor{green} & 15 & \verb~45~ & & \verb~                pos,~\\
\cellcolor{green} & 15 & \verb~46~ & & \verb~                extent,~\\
\cellcolor{green} & 15 & \verb~47~ & & \verb~                dir));~\\
\cellcolor{gray} &  & \verb~48~ & & \verb~            default:~\\
\cellcolor{green} & 13 & \verb~49~ & & \verb~                return new HardBall(new DynamicShape(~\\
\cellcolor{green} & 13 & \verb~50~ & & \verb~                pos,~\\
\cellcolor{green} & 13 & \verb~51~ & & \verb~                extent,~\\
\cellcolor{green} & 13 & \verb~52~ & & \verb~                dir));~\\
\cellcolor{gray} &  & \verb~53~ & & \verb~        }~\\
\cellcolor{green} & 81 & \verb~54~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~55~ & & \verb~}~\\
\cellcolor{gray} &  & \verb~56~ & & \verb~~\\
\end{longtable}
\newpage
\section{Breakout.Powerups.SlimJim}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.Powerups.SlimJim\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/Breakout/Powerups/Hazards/SlimJim.cs}\end{minipage} \\
\textbf{Covered lines:} & 15\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 15\\
\textbf{Total lines:} & 27\\
\textbf{Line coverage:} & 100\% (15 of 15)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 2\\
\textbf{Total methods:} & 2\\
\textbf{Method coverage:} & 100\% (2 of 2)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{Effect()} & 100\% & 1 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/Breakout/Powerups/Hazards/SlimJim.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Events;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using DIKUArcade.Timers;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~namespace Breakout.Powerups;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~/// <summary>~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~/// When picked up, player size is decreased by sending out a PlayerEvent.~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~/// The powerup is timed and therefore temporary~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~/// </summary>~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~public class SlimJim : Powerup {~\\
\cellcolor{green} & 12 & \verb~12~ & & \verb~    public SlimJim(DynamicShape shape) : base(shape, new Image(~\\
\cellcolor{green} & 24 & \verb~13~ & & \verb~        Path.Combine("..", "Breakout", "Assets", "Images", "SlimJim.png"))) {~\\
\cellcolor{green} & 12 & \verb~14~ & & \verb~    }~\\
\cellcolor{green} & 1 & \verb~15~ & & \verb~    public override void Effect() {~\\
\cellcolor{green} & 1 & \verb~16~ & & \verb~        BreakoutBus.GetBus().RegisterEvent(new GameEvent {~\\
\cellcolor{green} & 1 & \verb~17~ & & \verb~            EventType = GameEventType.PlayerEvent,~\\
\cellcolor{green} & 1 & \verb~18~ & & \verb~            Message = "SLIM JIM",~\\
\cellcolor{green} & 1 & \verb~19~ & & \verb~            StringArg1 = "START"~\\
\cellcolor{green} & 1 & \verb~20~ & & \verb~        });~\\
\cellcolor{green} & 1 & \verb~21~ & & \verb~        BreakoutBus.GetBus().RegisterTimedEvent(new GameEvent {~\\
\cellcolor{green} & 1 & \verb~22~ & & \verb~            EventType = GameEventType.PlayerEvent,~\\
\cellcolor{green} & 1 & \verb~23~ & & \verb~            Message = "SLIM JIM",~\\
\cellcolor{green} & 1 & \verb~24~ & & \verb~            StringArg1 = "END"~\\
\cellcolor{green} & 1 & \verb~25~ & & \verb~        }, TimePeriod.NewSeconds(10.0));~\\
\cellcolor{green} & 1 & \verb~26~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.Powerups.Split}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.Powerups.Split\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/Breakout/Powerups/Split.cs}\end{minipage} \\
\textbf{Covered lines:} & 9\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 9\\
\textbf{Total lines:} & 19\\
\textbf{Line coverage:} & 100\% (9 of 9)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 2\\
\textbf{Total methods:} & 2\\
\textbf{Method coverage:} & 100\% (2 of 2)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{Effect()} & 100\% & 1 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/Breakout/Powerups/Split.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Events;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~namespace Breakout.Powerups;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~/// <summary>~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~/// Ball splits into 3 balls going different directions.~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~/// </summary>~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~public class Split : Powerup {~\\
\cellcolor{green} & 16 & \verb~10~ & & \verb~    public Split(DynamicShape shape) : base(shape, new Image(~\\
\cellcolor{green} & 32 & \verb~11~ & & \verb~        Path.Combine("..", "Breakout", "Assets", "Images", "SplitPowerUp.png"))) {~\\
\cellcolor{green} & 16 & \verb~12~ & & \verb~    }~\\
\cellcolor{green} & 2 & \verb~13~ & & \verb~    public override void Effect() {~\\
\cellcolor{green} & 2 & \verb~14~ & & \verb~        BreakoutBus.GetBus().RegisterEvent(new GameEvent {~\\
\cellcolor{green} & 2 & \verb~15~ & & \verb~            EventType = GameEventType.StatusEvent,~\\
\cellcolor{green} & 2 & \verb~16~ & & \verb~            Message = "SPLIT",~\\
\cellcolor{green} & 2 & \verb~17~ & & \verb~        });~\\
\cellcolor{green} & 2 & \verb~18~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.Powerups.Wide}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.Powerups.Wide\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/Breakout/Powerups/Wide.cs}\end{minipage} \\
\textbf{Covered lines:} & 15\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 15\\
\textbf{Total lines:} & 27\\
\textbf{Line coverage:} & 100\% (15 of 15)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 2\\
\textbf{Total methods:} & 2\\
\textbf{Method coverage:} & 100\% (2 of 2)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{Effect()} & 100\% & 1 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/Breakout/Powerups/Wide.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Events;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using DIKUArcade.Timers;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~namespace Breakout.Powerups;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~/// <summary>~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~/// When picked up, player size is increased by sending out a PlayerEvent.~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~/// The powerup is timed and therefore temporary~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~/// </summary>~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~public class Wide : Powerup {~\\
\cellcolor{green} & 14 & \verb~12~ & & \verb~    public Wide(DynamicShape shape) : base(shape, new Image(~\\
\cellcolor{green} & 28 & \verb~13~ & & \verb~        Path.Combine("..", "Breakout", "Assets", "Images", "WidePowerUp.png"))) {~\\
\cellcolor{green} & 14 & \verb~14~ & & \verb~    }~\\
\cellcolor{green} & 2 & \verb~15~ & & \verb~    public override void Effect() {~\\
\cellcolor{green} & 2 & \verb~16~ & & \verb~        BreakoutBus.GetBus().RegisterEvent(new GameEvent {~\\
\cellcolor{green} & 2 & \verb~17~ & & \verb~            EventType = GameEventType.PlayerEvent,~\\
\cellcolor{green} & 2 & \verb~18~ & & \verb~            Message = "WIDE",~\\
\cellcolor{green} & 2 & \verb~19~ & & \verb~            StringArg1 = "START"~\\
\cellcolor{green} & 2 & \verb~20~ & & \verb~        });~\\
\cellcolor{green} & 2 & \verb~21~ & & \verb~        BreakoutBus.GetBus().RegisterTimedEvent(new GameEvent {~\\
\cellcolor{green} & 2 & \verb~22~ & & \verb~            EventType = GameEventType.PlayerEvent,~\\
\cellcolor{green} & 2 & \verb~23~ & & \verb~            Message = "WIDE",~\\
\cellcolor{green} & 2 & \verb~24~ & & \verb~            StringArg1 = "END"~\\
\cellcolor{green} & 2 & \verb~25~ & & \verb~        }, TimePeriod.NewSeconds(10.0));~\\
\cellcolor{green} & 2 & \verb~26~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.Program}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.Program\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/Breakout/Program.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 5\\
\textbf{Coverable lines:} & 5\\
\textbf{Total lines:} & 9\\
\textbf{Line coverage:} & 0\% (0 of 5)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 1\\
\textbf{Method coverage:} & 0\% (0 of 1)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{Main(...)} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/Breakout/Program.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.GUI;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~namespace Breakout;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~class Program {~\\
\cellcolor{red} & 0 & \verb~4~ & & \verb~    static void Main(string[] args) {~\\
\cellcolor{red} & 0 & \verb~5~ & & \verb~            var windowArgs = new WindowArgs() {Title = "Breakout"};~\\
\cellcolor{red} & 0 & \verb~6~ & & \verb~            var game = new Game(windowArgs);~\\
\cellcolor{red} & 0 & \verb~7~ & & \verb~            game.Run();~\\
\cellcolor{red} & 0 & \verb~8~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.States.GameLost}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.States.GameLost\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/Breakout/States/GameLost.cs}\end{minipage} \\
\textbf{Covered lines:} & 74\\
\textbf{Uncovered lines:} & 15\\
\textbf{Coverable lines:} & 89\\
\textbf{Total lines:} & 139\\
\textbf{Line coverage:} & 83.1\% (74 of 89)\\
\textbf{Covered branches:} & 11\\
\textbf{Total branches:} & 12\\
\textbf{Branch coverage:} & 91.6\% (11 of 12)\\
\textbf{Covered methods:} & 7\\
\textbf{Total methods:} & 9\\
\textbf{Method coverage:} & 77.7\% (7 of 9)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor()} & 100\% & 1 & 100\%\\
\hline
\textbf{get\_ActiveMenuButton} & 100\% & 1 & 100\%\\
\hline
\textbf{GetInstance()} & 100\% & 2 & 100\%\\
\hline
\textbf{InitializeGameState(} & 100\% & 1 & 100\%\\
\hline
\textbf{ResetState()} & 100\% & 1 & 100\%\\
\hline
\textbf{UpdateState()} & 100\% & 1 & 0\%\\
\hline
\textbf{RenderState()} & 100\% & 1 & 0\%\\
\hline
\textbf{HandleKeyEvent(...)} & 100\% & 2 & 100\%\\
\hline
\textbf{KeyPress(...)} & 87.50\% & 8 & 76.00\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/Breakout/States/GameLost.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Events;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using DIKUArcade.Input;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~using DIKUArcade.State;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~namespace Breakout.States;~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~/// <summary>~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~///  A state for when the game is lost~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~/// </summary>~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~public class GameLost : IGameState {~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~    private static GameLost instance = null;~\\
\cellcolor{green} & 213 & \verb~14~ & & \verb~    private Points points = null!;~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~    private Entity background;~\\
\cellcolor{green} & 213 & \verb~16~ & & \verb~    private Text[] menuButtons = new Text[2];~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~    private Text gameOverText;~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~    private Text pointsText;~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~    private int pointsValue;~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~    private int activeMenuButton;~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~    public int ActiveMenuButton {~\\
\cellcolor{green} & 3 & \verb~22~ & & \verb~        get => activeMenuButton;~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~    private const int MAIN_MENU = 0;~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~    private const int QUIT = 1;~\\
\cellcolor{green} & 213 & \verb~26~ & & \verb~    private Vec3I white = new Vec3I(255, 255, 255);~\\
\cellcolor{green} & 213 & \verb~27~ & & \verb~    private Vec3I red = new Vec3I(255, 0, 0);~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~    ///  Gets or creates an instance of the GameLost state~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 415 & \verb~31~ & & \verb~    public static GameLost GetInstance() {~\\
\cellcolor{green} & 621 & \verb~32~ & & \verb~        if (GameLost.instance == null) {~\\
\cellcolor{green} & 206 & \verb~33~ & & \verb~            GameLost.instance = new GameLost();~\\
\cellcolor{green} & 206 & \verb~34~ & & \verb~            GameLost.instance.InitializeGameState();~\\
\cellcolor{green} & 206 & \verb~35~ & & \verb~        }~\\
\cellcolor{green} & 415 & \verb~36~ & & \verb~        return GameLost.instance;~\\
\cellcolor{green} & 415 & \verb~37~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~38~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~39~ & & \verb~    ///  Inizializes the Game state, this functions as a constructor for the state~\\
\cellcolor{gray} &  & \verb~40~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 208 & \verb~41~ & & \verb~    public void InitializeGameState() {~\\
\cellcolor{green} & 208 & \verb~42~ & & \verb~        points = Points.GetInstance();~\\
\cellcolor{green} & 208 & \verb~43~ & & \verb~        pointsValue = points.GetPoints();~\\
\cellcolor{gray} &  & \verb~44~ & & \verb~~\\
\cellcolor{green} & 208 & \verb~45~ & & \verb~        background = new Entity(~\\
\cellcolor{green} & 208 & \verb~46~ & & \verb~            new StationaryShape(~\\
\cellcolor{green} & 208 & \verb~47~ & & \verb~                new Vec2F(0.0f, 0.0f),~\\
\cellcolor{green} & 208 & \verb~48~ & & \verb~                new Vec2F(1.0f, 1.0f)),~\\
\cellcolor{green} & 208 & \verb~49~ & & \verb~                new Image(Path.Combine(~\\
\cellcolor{green} & 208 & \verb~50~ & & \verb~                "..", "Breakout", "Assets", "Images", "SpaceBackground.png")));~\\
\cellcolor{green} & 208 & \verb~51~ & & \verb~        gameOverText = new Text(~\\
\cellcolor{green} & 208 & \verb~52~ & & \verb~            "Game over",~\\
\cellcolor{green} & 208 & \verb~53~ & & \verb~            new Vec2F(0.30f, 0.17f),~\\
\cellcolor{green} & 208 & \verb~54~ & & \verb~            new Vec2F(0.7f, 0.7f)~\\
\cellcolor{green} & 208 & \verb~55~ & & \verb~            );~\\
\cellcolor{gray} &  & \verb~56~ & & \verb~~\\
\cellcolor{green} & 208 & \verb~57~ & & \verb~        pointsText = new Text(~\\
\cellcolor{green} & 208 & \verb~58~ & & \verb~            $"Points: {pointsValue}",~\\
\cellcolor{green} & 208 & \verb~59~ & & \verb~            new Vec2F(0.41f, 0.32f),~\\
\cellcolor{green} & 208 & \verb~60~ & & \verb~            new Vec2F(0.4f, 0.4f)~\\
\cellcolor{green} & 208 & \verb~61~ & & \verb~        );~\\
\cellcolor{gray} &  & \verb~62~ & & \verb~~\\
\cellcolor{green} & 208 & \verb~63~ & & \verb~        gameOverText.SetColor(white);~\\
\cellcolor{green} & 208 & \verb~64~ & & \verb~        pointsText.SetColor(white);~\\
\cellcolor{gray} &  & \verb~65~ & & \verb~~\\
\cellcolor{green} & 208 & \verb~66~ & & \verb~        menuButtons[MAIN_MENU] = new Text(~\\
\cellcolor{green} & 208 & \verb~67~ & & \verb~            "Main Menu",~\\
\cellcolor{green} & 208 & \verb~68~ & & \verb~            new Vec2F(0.39f, 0.1f),~\\
\cellcolor{green} & 208 & \verb~69~ & & \verb~            new Vec2F(0.4f, 0.4f)~\\
\cellcolor{green} & 208 & \verb~70~ & & \verb~            );~\\
\cellcolor{gray} &  & \verb~71~ & & \verb~~\\
\cellcolor{green} & 208 & \verb~72~ & & \verb~        menuButtons[QUIT] = new Text(~\\
\cellcolor{green} & 208 & \verb~73~ & & \verb~            "Quit game",~\\
\cellcolor{green} & 208 & \verb~74~ & & \verb~            new Vec2F(0.4f, 0f),~\\
\cellcolor{green} & 208 & \verb~75~ & & \verb~            new Vec2F(0.4f, 0.4f)~\\
\cellcolor{green} & 208 & \verb~76~ & & \verb~            );~\\
\cellcolor{green} & 208 & \verb~77~ & & \verb~        activeMenuButton = MAIN_MENU;~\\
\cellcolor{green} & 208 & \verb~78~ & & \verb~        menuButtons[MAIN_MENU].SetColor(red);~\\
\cellcolor{green} & 208 & \verb~79~ & & \verb~        menuButtons[QUIT].SetColor(white);~\\
\cellcolor{green} & 208 & \verb~80~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~81~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~82~ & & \verb~    /// Resets the state~\\
\cellcolor{gray} &  & \verb~83~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 205 & \verb~84~ & & \verb~    public void ResetState() {~\\
\cellcolor{green} & 205 & \verb~85~ & & \verb~        GameLost.instance = null;~\\
\cellcolor{green} & 205 & \verb~86~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~87~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~88~ & & \verb~    ///  Updates the state, this an empty method~\\
\cellcolor{gray} &  & \verb~89~ & & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~90~ & & \verb~    public void UpdateState() {~\\
\cellcolor{red} & 0 & \verb~91~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~92~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~93~ & & \verb~    ///  Renders objects in the state~\\
\cellcolor{gray} &  & \verb~94~ & & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~95~ & & \verb~    public void RenderState() {~\\
\cellcolor{red} & 0 & \verb~96~ & & \verb~        background.RenderEntity();~\\
\cellcolor{red} & 0 & \verb~97~ & & \verb~        gameOverText.RenderText();~\\
\cellcolor{red} & 0 & \verb~98~ & & \verb~        menuButtons[QUIT].RenderText();~\\
\cellcolor{red} & 0 & \verb~99~ & & \verb~        menuButtons[MAIN_MENU].RenderText();~\\
\cellcolor{red} & 0 & \verb~100~ & & \verb~        pointsText.RenderText();~\\
\cellcolor{red} & 0 & \verb~101~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~102~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~103~ & & \verb~    ///  Handles key input events such as key presses and key realising~\\
\cellcolor{gray} &  & \verb~104~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 4 & \verb~105~ & & \verb~    public void HandleKeyEvent(KeyboardAction action, KeyboardKey key) {~\\
\cellcolor{green} & 8 & \verb~106~ & & \verb~        if (action == KeyboardAction.KeyPress) {~\\
\cellcolor{green} & 4 & \verb~107~ & & \verb~            KeyPress(key);~\\
\cellcolor{green} & 4 & \verb~108~ & & \verb~        }~\\
\cellcolor{green} & 4 & \verb~109~ & & \verb~    }~\\
\cellcolor{green} & 4 & \verb~110~ & & \verb~    private void KeyPress(KeyboardKey key) {~\\
\cellcolor{green} & 4 & \verb~111~ & & \verb~        switch (key) {~\\
\cellcolor{gray} &  & \verb~112~ & & \verb~            case KeyboardKey.Up:~\\
\cellcolor{green} & 2 & \verb~113~ & & \verb~                activeMenuButton = MAIN_MENU;~\\
\cellcolor{green} & 2 & \verb~114~ & & \verb~                menuButtons[MAIN_MENU].SetColor(red);~\\
\cellcolor{green} & 2 & \verb~115~ & & \verb~                menuButtons[QUIT].SetColor(white);~\\
\cellcolor{green} & 2 & \verb~116~ & & \verb~                break;~\\
\cellcolor{gray} &  & \verb~117~ & & \verb~            case KeyboardKey.Down:~\\
\cellcolor{green} & 1 & \verb~118~ & & \verb~                activeMenuButton = QUIT;~\\
\cellcolor{green} & 1 & \verb~119~ & & \verb~                menuButtons[QUIT].SetColor(red);~\\
\cellcolor{green} & 1 & \verb~120~ & & \verb~                menuButtons[MAIN_MENU].SetColor(white);~\\
\cellcolor{green} & 1 & \verb~121~ & & \verb~                break;~\\
\cellcolor{gray} &  & \verb~122~ & & \verb~            case KeyboardKey.Enter:~\\
\cellcolor{orange} & 2 & \verb~123~ & & \verb~                if (ActiveMenuButton == MAIN_MENU) {~\\
\cellcolor{green} & 1 & \verb~124~ & & \verb~                    BreakoutBus.GetBus().RegisterEvent(new GameEvent {~\\
\cellcolor{green} & 1 & \verb~125~ & & \verb~                        EventType = GameEventType.GameStateEvent,~\\
\cellcolor{green} & 1 & \verb~126~ & & \verb~                        Message = "CHANGE_STATE",~\\
\cellcolor{green} & 1 & \verb~127~ & & \verb~                        StringArg1 = "MAIN_MENU"~\\
\cellcolor{green} & 1 & \verb~128~ & & \verb~                    });~\\
\cellcolor{green} & 1 & \verb~129~ & & \verb~                } else {~\\
\cellcolor{red} & 0 & \verb~130~ & & \verb~                    BreakoutBus.GetBus().RegisterEvent(new GameEvent {~\\
\cellcolor{red} & 0 & \verb~131~ & & \verb~                        EventType = GameEventType.WindowEvent,~\\
\cellcolor{red} & 0 & \verb~132~ & & \verb~                        Message = "CLOSE_GAME",~\\
\cellcolor{red} & 0 & \verb~133~ & & \verb~                        StringArg1 = "WINDOW CLOSE"~\\
\cellcolor{red} & 0 & \verb~134~ & & \verb~                    });~\\
\cellcolor{red} & 0 & \verb~135~ & & \verb~                }~\\
\cellcolor{green} & 1 & \verb~136~ & & \verb~                break;~\\
\cellcolor{gray} &  & \verb~137~ & & \verb~        }~\\
\cellcolor{green} & 4 & \verb~138~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~139~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.States.GamePaused}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.States.GamePaused\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/Breakout/States/GamePaused.cs}\end{minipage} \\
\textbf{Covered lines:} & 73\\
\textbf{Uncovered lines:} & 8\\
\textbf{Coverable lines:} & 81\\
\textbf{Total lines:} & 129\\
\textbf{Line coverage:} & 90.1\% (73 of 81)\\
\textbf{Covered branches:} & 12\\
\textbf{Total branches:} & 12\\
\textbf{Branch coverage:} & 100\% (12 of 12)\\
\textbf{Covered methods:} & 9\\
\textbf{Total methods:} & 11\\
\textbf{Method coverage:} & 81.8\% (9 of 11)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{get\_Background()} & 100\% & 1 & 100\%\\
\hline
\textbf{.ctor()} & 100\% & 1 & 100\%\\
\hline
\textbf{get\_PauseText()} & 100\% & 1 & 100\%\\
\hline
\textbf{get\_ActiveMenuButton} & 100\% & 1 & 100\%\\
\hline
\textbf{GetInstance()} & 100\% & 2 & 100\%\\
\hline
\textbf{InitializeGameState(} & 100\% & 1 & 100\%\\
\hline
\textbf{ResetState()} & 100\% & 1 & 100\%\\
\hline
\textbf{UpdateState()} & 100\% & 1 & 0\%\\
\hline
\textbf{RenderState()} & 100\% & 1 & 0\%\\
\hline
\textbf{HandleKeyEvent(...)} & 100\% & 2 & 100\%\\
\hline
\textbf{KeyPress(...)} & 100\% & 8 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/Breakout/States/GamePaused.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Events;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using DIKUArcade.Input;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~using DIKUArcade.State;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~namespace Breakout.States;~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~/// <summary>~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~///  A state for when the game is paused~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~/// </summary>~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~public class GamePaused : IGameState {~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~    private static GamePaused instance = null;~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~    private Entity background;~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~    public Entity Background {~\\
\cellcolor{green} & 1 & \verb~17~ & & \verb~        get => background;~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~    }~\\
\cellcolor{green} & 38 & \verb~19~ & & \verb~    private Text[] menuButtons = new Text[2];~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~    private Text pauseText;~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~    public Text PauseText {~\\
\cellcolor{green} & 1 & \verb~22~ & & \verb~        get => pauseText;~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~    private int activeMenuButton;~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~    public int ActiveMenuButton {~\\
\cellcolor{green} & 5 & \verb~26~ & & \verb~        get => activeMenuButton;~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~    private const int CONTINUE = 0;~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~    private const int MAIN_MENU = 1;~\\
\cellcolor{green} & 38 & \verb~30~ & & \verb~    private Vec3I white = new Vec3I(255, 255, 255);~\\
\cellcolor{green} & 38 & \verb~31~ & & \verb~    private Vec3I red = new Vec3I(255, 0, 0);~\\
\cellcolor{gray} &  & \verb~32~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~    ///  Gets or creates an instance of the GamePaused state~\\
\cellcolor{gray} &  & \verb~34~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 49 & \verb~35~ & & \verb~    public static GamePaused GetInstance() {~\\
\cellcolor{green} & 74 & \verb~36~ & & \verb~        if (GamePaused.instance == null) {~\\
\cellcolor{green} & 25 & \verb~37~ & & \verb~            GamePaused.instance = new GamePaused();~\\
\cellcolor{green} & 25 & \verb~38~ & & \verb~            GamePaused.instance.InitializeGameState();~\\
\cellcolor{green} & 25 & \verb~39~ & & \verb~        }~\\
\cellcolor{green} & 49 & \verb~40~ & & \verb~        return GamePaused.instance;~\\
\cellcolor{green} & 49 & \verb~41~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~42~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~43~ & & \verb~    ///  Inizializes the Game state, this functions as a constructor for the state~\\
\cellcolor{gray} &  & \verb~44~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 30 & \verb~45~ & & \verb~    public void InitializeGameState() {~\\
\cellcolor{green} & 30 & \verb~46~ & & \verb~        background = new Entity(~\\
\cellcolor{green} & 30 & \verb~47~ & & \verb~            new StationaryShape(~\\
\cellcolor{green} & 30 & \verb~48~ & & \verb~                new Vec2F(0.0f, 0.0f),~\\
\cellcolor{green} & 30 & \verb~49~ & & \verb~                new Vec2F(1.0f, 1.0f)),~\\
\cellcolor{green} & 30 & \verb~50~ & & \verb~                new Image(Path.Combine(~\\
\cellcolor{green} & 30 & \verb~51~ & & \verb~                "..", "Breakout", "Assets", "Images", "SpaceBackground.png")));~\\
\cellcolor{green} & 30 & \verb~52~ & & \verb~        pauseText = new Text(~\\
\cellcolor{green} & 30 & \verb~53~ & & \verb~            "Paused",~\\
\cellcolor{green} & 30 & \verb~54~ & & \verb~            new Vec2F(0.375f, 0.05f),~\\
\cellcolor{green} & 30 & \verb~55~ & & \verb~            new Vec2F(0.7f, 0.7f)~\\
\cellcolor{green} & 30 & \verb~56~ & & \verb~            );~\\
\cellcolor{green} & 30 & \verb~57~ & & \verb~        activeMenuButton = CONTINUE;~\\
\cellcolor{green} & 30 & \verb~58~ & & \verb~        menuButtons[CONTINUE] = new Text(~\\
\cellcolor{green} & 30 & \verb~59~ & & \verb~            "Continue",~\\
\cellcolor{green} & 30 & \verb~60~ & & \verb~            new Vec2F(0.42f, 0.2f),~\\
\cellcolor{green} & 30 & \verb~61~ & & \verb~            new Vec2F(0.4f, 0.4f)~\\
\cellcolor{green} & 30 & \verb~62~ & & \verb~            );~\\
\cellcolor{green} & 30 & \verb~63~ & & \verb~        menuButtons[MAIN_MENU] = new Text(~\\
\cellcolor{green} & 30 & \verb~64~ & & \verb~            "Main Menu",~\\
\cellcolor{green} & 30 & \verb~65~ & & \verb~            new Vec2F(0.4f, 0.1f),~\\
\cellcolor{green} & 30 & \verb~66~ & & \verb~            new Vec2F(0.4f, 0.4f)~\\
\cellcolor{green} & 30 & \verb~67~ & & \verb~            );~\\
\cellcolor{green} & 30 & \verb~68~ & & \verb~        pauseText.SetColor(white);~\\
\cellcolor{green} & 30 & \verb~69~ & & \verb~        menuButtons[CONTINUE].SetColor(red);~\\
\cellcolor{green} & 30 & \verb~70~ & & \verb~        menuButtons[MAIN_MENU].SetColor(white);~\\
\cellcolor{green} & 30 & \verb~71~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~72~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~73~ & & \verb~    /// Resets the state~\\
\cellcolor{gray} &  & \verb~74~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 25 & \verb~75~ & & \verb~    public void ResetState() {~\\
\cellcolor{green} & 25 & \verb~76~ & & \verb~        GamePaused.instance = null;~\\
\cellcolor{green} & 25 & \verb~77~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~78~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~79~ & & \verb~    ///  Updates the state, this an empty method~\\
\cellcolor{gray} &  & \verb~80~ & & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~81~ & & \verb~    public void UpdateState() {~\\
\cellcolor{red} & 0 & \verb~82~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~83~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~84~ & & \verb~    ///  Renders objects in the state~\\
\cellcolor{gray} &  & \verb~85~ & & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~86~ & & \verb~    public void RenderState() {~\\
\cellcolor{red} & 0 & \verb~87~ & & \verb~        background.RenderEntity();~\\
\cellcolor{red} & 0 & \verb~88~ & & \verb~        pauseText.RenderText();~\\
\cellcolor{red} & 0 & \verb~89~ & & \verb~        menuButtons[CONTINUE].RenderText();~\\
\cellcolor{red} & 0 & \verb~90~ & & \verb~        menuButtons[MAIN_MENU].RenderText();~\\
\cellcolor{red} & 0 & \verb~91~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~92~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~93~ & & \verb~    ///  Handles key input events such as key presses and key realising~\\
\cellcolor{gray} &  & \verb~94~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 7 & \verb~95~ & & \verb~    public void HandleKeyEvent(KeyboardAction action, KeyboardKey key) {~\\
\cellcolor{green} & 14 & \verb~96~ & & \verb~        if (action == KeyboardAction.KeyPress) {~\\
\cellcolor{green} & 7 & \verb~97~ & & \verb~            KeyPress(key);~\\
\cellcolor{green} & 7 & \verb~98~ & & \verb~        }~\\
\cellcolor{green} & 7 & \verb~99~ & & \verb~    }~\\
\cellcolor{green} & 7 & \verb~100~ & & \verb~    private void KeyPress(KeyboardKey key) {~\\
\cellcolor{green} & 7 & \verb~101~ & & \verb~        switch (key) {~\\
\cellcolor{gray} &  & \verb~102~ & & \verb~            case KeyboardKey.Up:~\\
\cellcolor{green} & 2 & \verb~103~ & & \verb~                activeMenuButton = CONTINUE;~\\
\cellcolor{green} & 2 & \verb~104~ & & \verb~                menuButtons[CONTINUE].SetColor(red);~\\
\cellcolor{green} & 2 & \verb~105~ & & \verb~                menuButtons[MAIN_MENU].SetColor(white);~\\
\cellcolor{green} & 2 & \verb~106~ & & \verb~                break;~\\
\cellcolor{gray} &  & \verb~107~ & & \verb~            case KeyboardKey.Down:~\\
\cellcolor{green} & 3 & \verb~108~ & & \verb~                activeMenuButton = MAIN_MENU;~\\
\cellcolor{green} & 3 & \verb~109~ & & \verb~                menuButtons[CONTINUE].SetColor(white);~\\
\cellcolor{green} & 3 & \verb~110~ & & \verb~                menuButtons[MAIN_MENU].SetColor(red);~\\
\cellcolor{green} & 3 & \verb~111~ & & \verb~                break;~\\
\cellcolor{gray} &  & \verb~112~ & & \verb~            case KeyboardKey.Enter:~\\
\cellcolor{green} & 3 & \verb~113~ & & \verb~                if (activeMenuButton == CONTINUE) {~\\
\cellcolor{green} & 1 & \verb~114~ & & \verb~                    BreakoutBus.GetBus().RegisterEvent(new GameEvent {~\\
\cellcolor{green} & 1 & \verb~115~ & & \verb~                        EventType = GameEventType.GameStateEvent,~\\
\cellcolor{green} & 1 & \verb~116~ & & \verb~                        Message = "RESUME_STATE",~\\
\cellcolor{green} & 1 & \verb~117~ & & \verb~                        StringArg1 = "GAME_RUNNING"~\\
\cellcolor{green} & 1 & \verb~118~ & & \verb~                    });~\\
\cellcolor{green} & 2 & \verb~119~ & & \verb~                } else {~\\
\cellcolor{green} & 1 & \verb~120~ & & \verb~                    BreakoutBus.GetBus().RegisterEvent(new GameEvent {~\\
\cellcolor{green} & 1 & \verb~121~ & & \verb~                        EventType = GameEventType.GameStateEvent,~\\
\cellcolor{green} & 1 & \verb~122~ & & \verb~                        Message = "CHANGE_STATE",~\\
\cellcolor{green} & 1 & \verb~123~ & & \verb~                        StringArg1 = "MAIN_MENU"~\\
\cellcolor{green} & 1 & \verb~124~ & & \verb~                    });~\\
\cellcolor{green} & 1 & \verb~125~ & & \verb~                }~\\
\cellcolor{green} & 2 & \verb~126~ & & \verb~                break;~\\
\cellcolor{gray} &  & \verb~127~ & & \verb~        }~\\
\cellcolor{green} & 7 & \verb~128~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~129~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.States.GameRunning}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.States.GameRunning\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/Breakout/States/GameRunning.cs}\end{minipage} \\
\textbf{Covered lines:} & 98\\
\textbf{Uncovered lines:} & 6\\
\textbf{Coverable lines:} & 104\\
\textbf{Total lines:} & 167\\
\textbf{Line coverage:} & 94.2\% (98 of 104)\\
\textbf{Covered branches:} & 36\\
\textbf{Total branches:} & 36\\
\textbf{Branch coverage:} & 100\% (36 of 36)\\
\textbf{Covered methods:} & 14\\
\textbf{Total methods:} & 15\\
\textbf{Method coverage:} & 93.3\% (14 of 15)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor()} & 100\% & 1 & 100\%\\
\hline
\textbf{get\_Health()} & 100\% & 1 & 100\%\\
\hline
\textbf{get\_Background()} & 100\% & 1 & 100\%\\
\hline
\textbf{get\_Levellst()} & 100\% & 1 & 100\%\\
\hline
\textbf{get\_Points()} & 100\% & 1 & 100\%\\
\hline
\textbf{get\_LevelManager()} & 100\% & 1 & 100\%\\
\hline
\textbf{GetInstance()} & 100\% & 2 & 100\%\\
\hline
\textbf{InitializeGameState(} & 100\% & 1 & 100\%\\
\hline
\textbf{ResetState()} & 100\% & 1 & 100\%\\
\hline
\textbf{RenderState()} & 100\% & 1 & 0\%\\
\hline
\textbf{LoadLevels()} & 100\% & 6 & 100\%\\
\hline
\textbf{UpdateState()} & 100\% & 1 & 100\%\\
\hline
\textbf{HandleKeyEvent(...)} & 100\% & 4 & 100\%\\
\hline
\textbf{KeyPress(...)} & 100\% & 14 & 100\%\\
\hline
\textbf{KeyRelease(...)} & 100\% & 10 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/Breakout/States/GameRunning.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using Breakout.Levels;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Events;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~using DIKUArcade.Input;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~using DIKUArcade.State;~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~namespace Breakout.States;~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~/// <summary>~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~///  A state for when the game is running.~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~/// </summary>~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~public class GameRunning : IGameState {~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~    private static GameRunning instance = null;~\\
\cellcolor{green} & 51 & \verb~16~ & & \verb~    private LevelManager levelManager = null!;~\\
\cellcolor{green} & 51 & \verb~17~ & & \verb~    private Points points = null!;~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~    private Health health;~\\
\cellcolor{green} & 51 & \verb~19~ & & \verb~    private Entity background = null!;~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~    private List<string> levelslst;~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~    // Public getters for testing~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~    public Health Health {~\\
\cellcolor{green} & 2 & \verb~23~ & & \verb~        get => health;~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~    public Entity Background {~\\
\cellcolor{green} & 4 & \verb~26~ & & \verb~        get => background;~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~    public List<string> Levellst {~\\
\cellcolor{green} & 279 & \verb~29~ & & \verb~        get => levelslst;~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~    public Points Points {~\\
\cellcolor{green} & 4 & \verb~32~ & & \verb~        get => points;~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~34~ & & \verb~    public LevelManager LevelManager {~\\
\cellcolor{green} & 77 & \verb~35~ & & \verb~        get => levelManager;~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~38~ & & \verb~    ///  Gets or creates an instance of the GameRunning state~\\
\cellcolor{gray} &  & \verb~39~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 86 & \verb~40~ & & \verb~    public static GameRunning GetInstance() {~\\
\cellcolor{green} & 118 & \verb~41~ & & \verb~        if (GameRunning.instance == null) {~\\
\cellcolor{green} & 32 & \verb~42~ & & \verb~            GameRunning.instance = new GameRunning();~\\
\cellcolor{green} & 32 & \verb~43~ & & \verb~            GameRunning.instance.InitializeGameState();~\\
\cellcolor{green} & 32 & \verb~44~ & & \verb~        }~\\
\cellcolor{green} & 86 & \verb~45~ & & \verb~        return GameRunning.instance;~\\
\cellcolor{green} & 86 & \verb~46~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~47~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~48~ & & \verb~    ///  Inizializes the Game state, this functions as a constructor for the state~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 42 & \verb~50~ & & \verb~    public void InitializeGameState() {~\\
\cellcolor{green} & 42 & \verb~51~ & & \verb~        background = new Entity(~\\
\cellcolor{green} & 42 & \verb~52~ & & \verb~            new StationaryShape(~\\
\cellcolor{green} & 42 & \verb~53~ & & \verb~                new Vec2F(0.0f, 0.0f),~\\
\cellcolor{green} & 42 & \verb~54~ & & \verb~                new Vec2F(1.0f, 1.0f)),~\\
\cellcolor{green} & 42 & \verb~55~ & & \verb~                new Image(Path.Combine(~\\
\cellcolor{green} & 42 & \verb~56~ & & \verb~                "..", "Breakout", "Assets", "Images", "SpaceBackground.png")));~\\
\cellcolor{green} & 42 & \verb~57~ & & \verb~        levelManager = new LevelManager();~\\
\cellcolor{green} & 42 & \verb~58~ & & \verb~        levelslst = new List<string>();~\\
\cellcolor{green} & 42 & \verb~59~ & & \verb~        Levellst.Add("level1.txt");~\\
\cellcolor{green} & 42 & \verb~60~ & & \verb~        Levellst.Add("level2.txt");~\\
\cellcolor{green} & 42 & \verb~61~ & & \verb~        Levellst.Add("level3.txt");~\\
\cellcolor{green} & 42 & \verb~62~ & & \verb~        Levellst.Add("level4.txt");~\\
\cellcolor{green} & 42 & \verb~63~ & & \verb~        Levellst.Add("wall.txt");~\\
\cellcolor{green} & 42 & \verb~64~ & & \verb~        LevelManager.NewLevel(Levellst[0]);~\\
\cellcolor{green} & 42 & \verb~65~ & & \verb~        points = Points.GetInstance();~\\
\cellcolor{green} & 42 & \verb~66~ & & \verb~        health = new Health();~\\
\cellcolor{green} & 42 & \verb~67~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~68~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~69~ & & \verb~    /// Resets the state~\\
\cellcolor{gray} &  & \verb~70~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 31 & \verb~71~ & & \verb~    public void ResetState() {~\\
\cellcolor{green} & 31 & \verb~72~ & & \verb~        GameRunning.instance = null;~\\
\cellcolor{green} & 31 & \verb~73~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~74~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~75~ & & \verb~    ///  Renders objects in the state~\\
\cellcolor{gray} &  & \verb~76~ & & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~77~ & & \verb~    public void RenderState() {~\\
\cellcolor{red} & 0 & \verb~78~ & & \verb~        background.RenderEntity();~\\
\cellcolor{red} & 0 & \verb~79~ & & \verb~        levelManager.Render();~\\
\cellcolor{red} & 0 & \verb~80~ & & \verb~        points.Render();~\\
\cellcolor{red} & 0 & \verb~81~ & & \verb~        health.Render();~\\
\cellcolor{red} & 0 & \verb~82~ & & \verb~    }~\\
\cellcolor{green} & 11 & \verb~83~ & & \verb~    private void LoadLevels() {~\\
\cellcolor{green} & 15 & \verb~84~ & & \verb~        if (levelslst.Count == 0) { // No levels left to load.~\\
\cellcolor{green} & 4 & \verb~85~ & & \verb~            BreakoutBus.GetBus().RegisterEvent(new GameEvent {~\\
\cellcolor{green} & 4 & \verb~86~ & & \verb~                EventType = GameEventType.GameStateEvent,~\\
\cellcolor{green} & 4 & \verb~87~ & & \verb~                Message = "CHANGE_STATE",~\\
\cellcolor{green} & 4 & \verb~88~ & & \verb~                StringArg1 = "GAME_WON"~\\
\cellcolor{green} & 4 & \verb~89~ & & \verb~            });~\\
\cellcolor{green} & 4 & \verb~90~ & & \verb~            return;~\\
\cellcolor{green} & 12 & \verb~91~ & & \verb~        } else if (LevelManager.EmptyLevel()) {~\\
\cellcolor{gray} &  & \verb~92~ & & \verb~            // If level contains no blocks except unbreakable blocks~\\
\cellcolor{green} & 5 & \verb~93~ & & \verb~            levelslst.RemoveAt(0); // Removes current level from level list~\\
\cellcolor{green} & 5 & \verb~94~ & & \verb~            if (Levellst.Count > 0) // Shouldnt try to access index 0 in an empty list~\\
\cellcolor{green} & 4 & \verb~95~ & & \verb~                levelManager.NewLevel(Levellst[0]);~\\
\cellcolor{green} & 5 & \verb~96~ & & \verb~        }~\\
\cellcolor{green} & 11 & \verb~97~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~98~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~99~ & & \verb~    ///  Updates the state and loads new levelslst when the level is empty~\\
\cellcolor{gray} &  & \verb~100~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 11 & \verb~101~ & & \verb~    public void UpdateState() {~\\
\cellcolor{green} & 11 & \verb~102~ & & \verb~        levelManager.Update();~\\
\cellcolor{green} & 11 & \verb~103~ & & \verb~        LoadLevels();~\\
\cellcolor{green} & 11 & \verb~104~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~105~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~106~ & & \verb~    ///  Handles key input events such as key presses and key realising~\\
\cellcolor{gray} &  & \verb~107~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 22 & \verb~108~ & & \verb~    public void HandleKeyEvent(KeyboardAction action, KeyboardKey key) {~\\
\cellcolor{green} & 22 & \verb~109~ & & \verb~        switch (action) {~\\
\cellcolor{gray} &  & \verb~110~ & & \verb~            case KeyboardAction.KeyPress:~\\
\cellcolor{green} & 16 & \verb~111~ & & \verb~                KeyPress(key);~\\
\cellcolor{green} & 16 & \verb~112~ & & \verb~                break;~\\
\cellcolor{gray} &  & \verb~113~ & & \verb~            case KeyboardAction.KeyRelease:~\\
\cellcolor{green} & 6 & \verb~114~ & & \verb~                KeyRelease(key);~\\
\cellcolor{green} & 6 & \verb~115~ & & \verb~                break;~\\
\cellcolor{gray} &  & \verb~116~ & & \verb~        }~\\
\cellcolor{green} & 22 & \verb~117~ & & \verb~    }~\\
\cellcolor{green} & 16 & \verb~118~ & & \verb~    private void KeyPress(KeyboardKey key) {~\\
\cellcolor{green} & 16 & \verb~119~ & & \verb~        switch (key) {~\\
\cellcolor{gray} &  & \verb~120~ & & \verb~            case KeyboardKey.Left:~\\
\cellcolor{gray} &  & \verb~121~ & & \verb~            case KeyboardKey.A:~\\
\cellcolor{green} & 2 & \verb~122~ & & \verb~                BreakoutBus.GetBus().RegisterEvent(new GameEvent {~\\
\cellcolor{green} & 2 & \verb~123~ & & \verb~                    EventType = GameEventType.PlayerEvent,~\\
\cellcolor{green} & 2 & \verb~124~ & & \verb~                    Message = "MOVE LEFT"~\\
\cellcolor{green} & 2 & \verb~125~ & & \verb~                });~\\
\cellcolor{green} & 2 & \verb~126~ & & \verb~                break;~\\
\cellcolor{gray} &  & \verb~127~ & & \verb~            case KeyboardKey.Right:~\\
\cellcolor{gray} &  & \verb~128~ & & \verb~            case KeyboardKey.D:~\\
\cellcolor{green} & 2 & \verb~129~ & & \verb~                BreakoutBus.GetBus().RegisterEvent(new GameEvent {~\\
\cellcolor{green} & 2 & \verb~130~ & & \verb~                    EventType = GameEventType.PlayerEvent,~\\
\cellcolor{green} & 2 & \verb~131~ & & \verb~                    Message = "MOVE RIGHT"~\\
\cellcolor{green} & 2 & \verb~132~ & & \verb~                });~\\
\cellcolor{green} & 2 & \verb~133~ & & \verb~                break;~\\
\cellcolor{gray} &  & \verb~134~ & & \verb~            case KeyboardKey.Escape:~\\
\cellcolor{green} & 1 & \verb~135~ & & \verb~                BreakoutBus.GetBus().RegisterEvent(new GameEvent {~\\
\cellcolor{green} & 1 & \verb~136~ & & \verb~                    EventType = GameEventType.GameStateEvent,~\\
\cellcolor{green} & 1 & \verb~137~ & & \verb~                    Message = "CHANGE_STATE",~\\
\cellcolor{green} & 1 & \verb~138~ & & \verb~                    StringArg1 = "GAME_PAUSED"~\\
\cellcolor{green} & 1 & \verb~139~ & & \verb~                });~\\
\cellcolor{green} & 1 & \verb~140~ & & \verb~                break;~\\
\cellcolor{gray} &  & \verb~141~ & & \verb~            case KeyboardKey.K:~\\
\cellcolor{green} & 11 & \verb~142~ & & \verb~                BreakoutBus.GetBus().RegisterEvent(new GameEvent {~\\
\cellcolor{green} & 11 & \verb~143~ & & \verb~                    EventType = GameEventType.StatusEvent,~\\
\cellcolor{green} & 11 & \verb~144~ & & \verb~                    Message = "CLEAR",~\\
\cellcolor{green} & 11 & \verb~145~ & & \verb~                });~\\
\cellcolor{green} & 11 & \verb~146~ & & \verb~                break;~\\
\cellcolor{gray} &  & \verb~147~ & & \verb~        }~\\
\cellcolor{green} & 16 & \verb~148~ & & \verb~    }~\\
\cellcolor{green} & 6 & \verb~149~ & & \verb~    private void KeyRelease(KeyboardKey key) {~\\
\cellcolor{green} & 6 & \verb~150~ & & \verb~        switch (key) {~\\
\cellcolor{gray} &  & \verb~151~ & & \verb~            case KeyboardKey.Left:~\\
\cellcolor{gray} &  & \verb~152~ & & \verb~            case KeyboardKey.A:~\\
\cellcolor{green} & 2 & \verb~153~ & & \verb~                BreakoutBus.GetBus().RegisterEvent(new GameEvent {~\\
\cellcolor{green} & 2 & \verb~154~ & & \verb~                    EventType = GameEventType.PlayerEvent,~\\
\cellcolor{green} & 2 & \verb~155~ & & \verb~                    Message = "RELEASE LEFT"~\\
\cellcolor{green} & 2 & \verb~156~ & & \verb~                });~\\
\cellcolor{green} & 2 & \verb~157~ & & \verb~                break;~\\
\cellcolor{gray} &  & \verb~158~ & & \verb~            case KeyboardKey.Right:~\\
\cellcolor{gray} &  & \verb~159~ & & \verb~            case KeyboardKey.D:~\\
\cellcolor{green} & 2 & \verb~160~ & & \verb~                BreakoutBus.GetBus().RegisterEvent(new GameEvent {~\\
\cellcolor{green} & 2 & \verb~161~ & & \verb~                    EventType = GameEventType.PlayerEvent,~\\
\cellcolor{green} & 2 & \verb~162~ & & \verb~                    Message = "RELEASE RIGHT"~\\
\cellcolor{green} & 2 & \verb~163~ & & \verb~                });~\\
\cellcolor{green} & 2 & \verb~164~ & & \verb~                break;~\\
\cellcolor{gray} &  & \verb~165~ & & \verb~        }~\\
\cellcolor{green} & 6 & \verb~166~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~167~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.States.GameWon}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.States.GameWon\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/Breakout/States/GameWon.cs}\end{minipage} \\
\textbf{Covered lines:} & 75\\
\textbf{Uncovered lines:} & 15\\
\textbf{Coverable lines:} & 90\\
\textbf{Total lines:} & 138\\
\textbf{Line coverage:} & 83.3\% (75 of 90)\\
\textbf{Covered branches:} & 11\\
\textbf{Total branches:} & 12\\
\textbf{Branch coverage:} & 91.6\% (11 of 12)\\
\textbf{Covered methods:} & 7\\
\textbf{Total methods:} & 9\\
\textbf{Method coverage:} & 77.7\% (7 of 9)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor()} & 100\% & 1 & 100\%\\
\hline
\textbf{get\_ActiveMenuButton} & 100\% & 1 & 100\%\\
\hline
\textbf{GetInstance()} & 100\% & 2 & 100\%\\
\hline
\textbf{InitializeGameState(} & 100\% & 1 & 100\%\\
\hline
\textbf{ResetState()} & 100\% & 1 & 100\%\\
\hline
\textbf{UpdateState()} & 100\% & 1 & 0\%\\
\hline
\textbf{RenderState()} & 100\% & 1 & 0\%\\
\hline
\textbf{HandleKeyEvent(...)} & 100\% & 2 & 100\%\\
\hline
\textbf{KeyPress(...)} & 87.50\% & 8 & 76.00\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/Breakout/States/GameWon.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Events;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using DIKUArcade.Input;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~using DIKUArcade.State;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~namespace Breakout.States;~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~/// <summary>~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~///  A state for when the game is won~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~/// </summary>~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~public class GameWon : IGameState {~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~    private static GameWon instance = null;~\\
\cellcolor{green} & 20 & \verb~14~ & & \verb~    private Points points = null!;~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~    private Entity background;~\\
\cellcolor{green} & 20 & \verb~16~ & & \verb~    private Text[] menuButtons = new Text[2];~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~    private Text gameOverText;~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~    private Text pointsText;~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~    private int pointsValue;~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~    private int activeMenuButton;~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~    public int ActiveMenuButton {~\\
\cellcolor{green} & 3 & \verb~22~ & & \verb~        get => activeMenuButton;~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~    private const int MAIN_MENU = 0;~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~    private const int QUIT = 1;~\\
\cellcolor{green} & 20 & \verb~26~ & & \verb~    private Vec3I white = new Vec3I(255, 255, 255);~\\
\cellcolor{green} & 20 & \verb~27~ & & \verb~    private Vec3I red = new Vec3I(255, 0, 0);~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~    ///  Gets or creates an instance of the GameWon state~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 31 & \verb~31~ & & \verb~    public static GameWon GetInstance() {~\\
\cellcolor{green} & 46 & \verb~32~ & & \verb~        if (GameWon.instance == null) {~\\
\cellcolor{green} & 15 & \verb~33~ & & \verb~            GameWon.instance = new GameWon();~\\
\cellcolor{green} & 15 & \verb~34~ & & \verb~            GameWon.instance.InitializeGameState();~\\
\cellcolor{green} & 15 & \verb~35~ & & \verb~        }~\\
\cellcolor{green} & 31 & \verb~36~ & & \verb~        return GameWon.instance;~\\
\cellcolor{green} & 31 & \verb~37~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~38~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~39~ & & \verb~    ///  Inizializes the Game state, this functions as a constructor for the state~\\
\cellcolor{gray} &  & \verb~40~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 17 & \verb~41~ & & \verb~    public void InitializeGameState() {~\\
\cellcolor{green} & 17 & \verb~42~ & & \verb~        points = Points.GetInstance();~\\
\cellcolor{green} & 17 & \verb~43~ & & \verb~        pointsValue = points.GetPoints();~\\
\cellcolor{gray} &  & \verb~44~ & & \verb~~\\
\cellcolor{green} & 17 & \verb~45~ & & \verb~        background = new Entity(~\\
\cellcolor{green} & 17 & \verb~46~ & & \verb~            new StationaryShape(~\\
\cellcolor{green} & 17 & \verb~47~ & & \verb~                new Vec2F(0.0f, 0.0f),~\\
\cellcolor{green} & 17 & \verb~48~ & & \verb~                new Vec2F(1.0f, 1.0f)),~\\
\cellcolor{green} & 17 & \verb~49~ & & \verb~                new Image(Path.Combine(~\\
\cellcolor{green} & 17 & \verb~50~ & & \verb~                "..", "Breakout", "Assets", "Images", "SpaceBackground.png")));~\\
\cellcolor{gray} &  & \verb~51~ & & \verb~~\\
\cellcolor{green} & 17 & \verb~52~ & & \verb~        gameOverText = new Text(~\\
\cellcolor{green} & 17 & \verb~53~ & & \verb~            "Game Won",~\\
\cellcolor{green} & 17 & \verb~54~ & & \verb~            new Vec2F(0.30f, 0.17f),~\\
\cellcolor{green} & 17 & \verb~55~ & & \verb~            new Vec2F(0.7f, 0.7f)~\\
\cellcolor{green} & 17 & \verb~56~ & & \verb~            );~\\
\cellcolor{green} & 17 & \verb~57~ & & \verb~        pointsText = new Text(~\\
\cellcolor{green} & 17 & \verb~58~ & & \verb~            $"Points: {pointsValue}",~\\
\cellcolor{green} & 17 & \verb~59~ & & \verb~            new Vec2F(0.41f, 0.32f),~\\
\cellcolor{green} & 17 & \verb~60~ & & \verb~            new Vec2F(0.4f, 0.4f)~\\
\cellcolor{green} & 17 & \verb~61~ & & \verb~        );~\\
\cellcolor{green} & 17 & \verb~62~ & & \verb~        menuButtons[MAIN_MENU] = new Text(~\\
\cellcolor{green} & 17 & \verb~63~ & & \verb~            "Main Menu",~\\
\cellcolor{green} & 17 & \verb~64~ & & \verb~            new Vec2F(0.39f, 0.1f),~\\
\cellcolor{green} & 17 & \verb~65~ & & \verb~            new Vec2F(0.4f, 0.4f)~\\
\cellcolor{green} & 17 & \verb~66~ & & \verb~            );~\\
\cellcolor{gray} &  & \verb~67~ & & \verb~~\\
\cellcolor{green} & 17 & \verb~68~ & & \verb~        menuButtons[QUIT] = new Text(~\\
\cellcolor{green} & 17 & \verb~69~ & & \verb~            "Quit game",~\\
\cellcolor{green} & 17 & \verb~70~ & & \verb~            new Vec2F(0.4f, 0f),~\\
\cellcolor{green} & 17 & \verb~71~ & & \verb~            new Vec2F(0.4f, 0.4f)~\\
\cellcolor{green} & 17 & \verb~72~ & & \verb~            );~\\
\cellcolor{green} & 17 & \verb~73~ & & \verb~        gameOverText.SetColor(white);~\\
\cellcolor{green} & 17 & \verb~74~ & & \verb~        pointsText.SetColor(white);~\\
\cellcolor{green} & 17 & \verb~75~ & & \verb~        activeMenuButton = MAIN_MENU;~\\
\cellcolor{green} & 17 & \verb~76~ & & \verb~        menuButtons[MAIN_MENU].SetColor(red);~\\
\cellcolor{green} & 17 & \verb~77~ & & \verb~        menuButtons[QUIT].SetColor(white);~\\
\cellcolor{green} & 17 & \verb~78~ & & \verb~        points = Points.GetInstance();~\\
\cellcolor{green} & 17 & \verb~79~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~80~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~81~ & & \verb~    /// Resets the state~\\
\cellcolor{gray} &  & \verb~82~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 14 & \verb~83~ & & \verb~    public void ResetState() {~\\
\cellcolor{green} & 14 & \verb~84~ & & \verb~        GameWon.instance = null;~\\
\cellcolor{green} & 14 & \verb~85~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~86~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~87~ & & \verb~    ///  Updates the state, this an empty method~\\
\cellcolor{gray} &  & \verb~88~ & & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~89~ & & \verb~    public void UpdateState() {~\\
\cellcolor{red} & 0 & \verb~90~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~91~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~92~ & & \verb~    ///  Renders objects in the state~\\
\cellcolor{gray} &  & \verb~93~ & & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~94~ & & \verb~    public void RenderState() {~\\
\cellcolor{red} & 0 & \verb~95~ & & \verb~        background.RenderEntity();~\\
\cellcolor{red} & 0 & \verb~96~ & & \verb~        gameOverText.RenderText();~\\
\cellcolor{red} & 0 & \verb~97~ & & \verb~        menuButtons[QUIT].RenderText();~\\
\cellcolor{red} & 0 & \verb~98~ & & \verb~        menuButtons[MAIN_MENU].RenderText();~\\
\cellcolor{red} & 0 & \verb~99~ & & \verb~        pointsText.RenderText();~\\
\cellcolor{red} & 0 & \verb~100~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~101~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~102~ & & \verb~    ///  Handles key input events such as key presses and key realising~\\
\cellcolor{gray} &  & \verb~103~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 4 & \verb~104~ & & \verb~    public void HandleKeyEvent(KeyboardAction action, KeyboardKey key) {~\\
\cellcolor{green} & 8 & \verb~105~ & & \verb~        if (action == KeyboardAction.KeyPress) {~\\
\cellcolor{green} & 4 & \verb~106~ & & \verb~            KeyPress(key);~\\
\cellcolor{green} & 4 & \verb~107~ & & \verb~        }~\\
\cellcolor{green} & 4 & \verb~108~ & & \verb~    }~\\
\cellcolor{green} & 4 & \verb~109~ & & \verb~    private void KeyPress(KeyboardKey key) {~\\
\cellcolor{green} & 4 & \verb~110~ & & \verb~        switch (key) {~\\
\cellcolor{gray} &  & \verb~111~ & & \verb~            case KeyboardKey.Up:~\\
\cellcolor{green} & 2 & \verb~112~ & & \verb~                activeMenuButton = MAIN_MENU;~\\
\cellcolor{green} & 2 & \verb~113~ & & \verb~                menuButtons[MAIN_MENU].SetColor(red);~\\
\cellcolor{green} & 2 & \verb~114~ & & \verb~                menuButtons[QUIT].SetColor(white);~\\
\cellcolor{green} & 2 & \verb~115~ & & \verb~                break;~\\
\cellcolor{gray} &  & \verb~116~ & & \verb~            case KeyboardKey.Down:~\\
\cellcolor{green} & 1 & \verb~117~ & & \verb~                activeMenuButton = QUIT;~\\
\cellcolor{green} & 1 & \verb~118~ & & \verb~                menuButtons[QUIT].SetColor(red);~\\
\cellcolor{green} & 1 & \verb~119~ & & \verb~                menuButtons[MAIN_MENU].SetColor(white);~\\
\cellcolor{green} & 1 & \verb~120~ & & \verb~                break;~\\
\cellcolor{gray} &  & \verb~121~ & & \verb~            case KeyboardKey.Enter:~\\
\cellcolor{orange} & 2 & \verb~122~ & & \verb~                if (ActiveMenuButton == MAIN_MENU) {~\\
\cellcolor{green} & 1 & \verb~123~ & & \verb~                    BreakoutBus.GetBus().RegisterEvent(new GameEvent {~\\
\cellcolor{green} & 1 & \verb~124~ & & \verb~                        EventType = GameEventType.GameStateEvent,~\\
\cellcolor{green} & 1 & \verb~125~ & & \verb~                        Message = "CHANGE_STATE",~\\
\cellcolor{green} & 1 & \verb~126~ & & \verb~                        StringArg1 = "MAIN_MENU"~\\
\cellcolor{green} & 1 & \verb~127~ & & \verb~                    });~\\
\cellcolor{green} & 1 & \verb~128~ & & \verb~                } else {~\\
\cellcolor{red} & 0 & \verb~129~ & & \verb~                    BreakoutBus.GetBus().RegisterEvent(new GameEvent {~\\
\cellcolor{red} & 0 & \verb~130~ & & \verb~                        EventType = GameEventType.WindowEvent,~\\
\cellcolor{red} & 0 & \verb~131~ & & \verb~                        Message = "CLOSE_GAME",~\\
\cellcolor{red} & 0 & \verb~132~ & & \verb~                        StringArg1 = "WINDOW CLOSE"~\\
\cellcolor{red} & 0 & \verb~133~ & & \verb~                    });~\\
\cellcolor{red} & 0 & \verb~134~ & & \verb~                }~\\
\cellcolor{green} & 1 & \verb~135~ & & \verb~                break;~\\
\cellcolor{gray} &  & \verb~136~ & & \verb~        }~\\
\cellcolor{green} & 4 & \verb~137~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~138~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.States.MainMenu}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.States.MainMenu\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/Breakout/States/MainMenu.cs}\end{minipage} \\
\textbf{Covered lines:} & 57\\
\textbf{Uncovered lines:} & 13\\
\textbf{Coverable lines:} & 70\\
\textbf{Total lines:} & 114\\
\textbf{Line coverage:} & 81.4\% (57 of 70)\\
\textbf{Covered branches:} & 11\\
\textbf{Total branches:} & 12\\
\textbf{Branch coverage:} & 91.6\% (11 of 12)\\
\textbf{Covered methods:} & 8\\
\textbf{Total methods:} & 10\\
\textbf{Method coverage:} & 80\% (8 of 10)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{get\_BackGround()} & 100\% & 1 & 100\%\\
\hline
\textbf{.ctor()} & 100\% & 1 & 100\%\\
\hline
\textbf{get\_ActiveMenuButton} & 100\% & 1 & 100\%\\
\hline
\textbf{GetInstance()} & 100\% & 2 & 100\%\\
\hline
\textbf{InitializeGameState(} & 100\% & 1 & 100\%\\
\hline
\textbf{ResetState()} & 100\% & 1 & 100\%\\
\hline
\textbf{UpdateState()} & 100\% & 1 & 0\%\\
\hline
\textbf{RenderState()} & 100\% & 1 & 0\%\\
\hline
\textbf{HandleKeyEvent(...)} & 100\% & 2 & 100\%\\
\hline
\textbf{KeyPress(...)} & 87.50\% & 8 & 76.00\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/Breakout/States/MainMenu.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Events;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using DIKUArcade.Input;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~using DIKUArcade.State;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~namespace Breakout.States;~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~/// <summary>~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~///  A main menu state~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~/// </summary>~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~public class MainMenu : IGameState {~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~    private static MainMenu instance = null;~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~    private Entity backGround;~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~    public Entity BackGround {~\\
\cellcolor{green} & 1 & \verb~16~ & & \verb~        get => backGround;~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~    }~\\
\cellcolor{green} & 76 & \verb~18~ & & \verb~    private Text[] menuButtons = new Text[2];~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~    private int activeMenuButton;~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~    public int ActiveMenuButton {~\\
\cellcolor{green} & 5 & \verb~21~ & & \verb~        get => activeMenuButton;~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~    private const int NEW_GAME = 0;~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~    private const int QUIT = 1;~\\
\cellcolor{green} & 76 & \verb~25~ & & \verb~    private Vec3I white = new Vec3I(255, 255, 255);~\\
\cellcolor{green} & 76 & \verb~26~ & & \verb~    private Vec3I red = new Vec3I(255, 0, 0);~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~    ///  Gets or creates an instance of the MainMenu state~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 162 & \verb~30~ & & \verb~    public static MainMenu GetInstance() {~\\
\cellcolor{green} & 226 & \verb~31~ & & \verb~        if (MainMenu.instance == null) {~\\
\cellcolor{green} & 64 & \verb~32~ & & \verb~            MainMenu.instance = new MainMenu();~\\
\cellcolor{green} & 64 & \verb~33~ & & \verb~            MainMenu.instance.InitializeGameState();~\\
\cellcolor{green} & 64 & \verb~34~ & & \verb~        }~\\
\cellcolor{green} & 162 & \verb~35~ & & \verb~        return MainMenu.instance;~\\
\cellcolor{green} & 162 & \verb~36~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~38~ & & \verb~    ///  Inizializes the Game state, this functions as a constructor for the state~\\
\cellcolor{gray} &  & \verb~39~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 68 & \verb~40~ & & \verb~    public void InitializeGameState() {~\\
\cellcolor{green} & 68 & \verb~41~ & & \verb~        backGround = new Entity(~\\
\cellcolor{green} & 68 & \verb~42~ & & \verb~            new StationaryShape(~\\
\cellcolor{green} & 68 & \verb~43~ & & \verb~                new Vec2F(0.0f, 0.0f),~\\
\cellcolor{green} & 68 & \verb~44~ & & \verb~                new Vec2F(1.0f, 1.0f)),~\\
\cellcolor{green} & 68 & \verb~45~ & & \verb~                new Image(Path.Combine(~\\
\cellcolor{green} & 68 & \verb~46~ & & \verb~                "..", "Breakout", "Assets", "Images", "BreakoutTitleScreen.png")));~\\
\cellcolor{green} & 68 & \verb~47~ & & \verb~        menuButtons[NEW_GAME] = new Text("New Game",~\\
\cellcolor{green} & 68 & \verb~48~ & & \verb~            new Vec2F(0.375f, 0.2f),~\\
\cellcolor{green} & 68 & \verb~49~ & & \verb~            new Vec2F(0.4f, 0.4f));~\\
\cellcolor{green} & 68 & \verb~50~ & & \verb~        menuButtons[QUIT] = new Text("Quit",~\\
\cellcolor{green} & 68 & \verb~51~ & & \verb~            new Vec2F(0.46f, 0.1f),~\\
\cellcolor{green} & 68 & \verb~52~ & & \verb~            new Vec2F(0.4f, 0.4f));~\\
\cellcolor{green} & 68 & \verb~53~ & & \verb~        activeMenuButton = NEW_GAME;~\\
\cellcolor{green} & 68 & \verb~54~ & & \verb~        menuButtons[NEW_GAME].SetColor(red);~\\
\cellcolor{green} & 68 & \verb~55~ & & \verb~        menuButtons[QUIT].SetColor(white);~\\
\cellcolor{green} & 68 & \verb~56~ & & \verb~        Points.GetInstance().ResetPoints();~\\
\cellcolor{green} & 68 & \verb~57~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~58~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~59~ & & \verb~    /// Resets the state~\\
\cellcolor{gray} &  & \verb~60~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 63 & \verb~61~ & & \verb~    public void ResetState() {~\\
\cellcolor{green} & 63 & \verb~62~ & & \verb~        MainMenu.instance = null;~\\
\cellcolor{green} & 63 & \verb~63~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~64~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~65~ & & \verb~    ///  Updates the state, this an empty method~\\
\cellcolor{gray} &  & \verb~66~ & & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~67~ & & \verb~    public void UpdateState() {~\\
\cellcolor{red} & 0 & \verb~68~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~69~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~70~ & & \verb~    ///  Renders objects in the state~\\
\cellcolor{gray} &  & \verb~71~ & & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~72~ & & \verb~    public void RenderState() {~\\
\cellcolor{red} & 0 & \verb~73~ & & \verb~        backGround.RenderEntity();~\\
\cellcolor{red} & 0 & \verb~74~ & & \verb~        menuButtons[NEW_GAME].RenderText();~\\
\cellcolor{red} & 0 & \verb~75~ & & \verb~        menuButtons[QUIT].RenderText();~\\
\cellcolor{red} & 0 & \verb~76~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~77~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~78~ & & \verb~    ///  Handles key input events such as key presses and key realising~\\
\cellcolor{gray} &  & \verb~79~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 5 & \verb~80~ & & \verb~    public void HandleKeyEvent(KeyboardAction action, KeyboardKey key) {~\\
\cellcolor{green} & 10 & \verb~81~ & & \verb~        if (action == KeyboardAction.KeyPress) {~\\
\cellcolor{green} & 5 & \verb~82~ & & \verb~            KeyPress(key);~\\
\cellcolor{green} & 5 & \verb~83~ & & \verb~        }~\\
\cellcolor{green} & 5 & \verb~84~ & & \verb~    }~\\
\cellcolor{green} & 5 & \verb~85~ & & \verb~    private void KeyPress(KeyboardKey key) {~\\
\cellcolor{green} & 5 & \verb~86~ & & \verb~        switch (key) {~\\
\cellcolor{gray} &  & \verb~87~ & & \verb~            case KeyboardKey.Up:~\\
\cellcolor{green} & 2 & \verb~88~ & & \verb~                activeMenuButton = NEW_GAME;~\\
\cellcolor{green} & 2 & \verb~89~ & & \verb~                menuButtons[NEW_GAME].SetColor(red);~\\
\cellcolor{green} & 2 & \verb~90~ & & \verb~                menuButtons[QUIT].SetColor(white);~\\
\cellcolor{green} & 2 & \verb~91~ & & \verb~                break;~\\
\cellcolor{gray} &  & \verb~92~ & & \verb~            case KeyboardKey.Down:~\\
\cellcolor{green} & 2 & \verb~93~ & & \verb~                activeMenuButton = QUIT;~\\
\cellcolor{green} & 2 & \verb~94~ & & \verb~                menuButtons[NEW_GAME].SetColor(white);~\\
\cellcolor{green} & 2 & \verb~95~ & & \verb~                menuButtons[QUIT].SetColor(red);~\\
\cellcolor{green} & 2 & \verb~96~ & & \verb~                break;~\\
\cellcolor{gray} &  & \verb~97~ & & \verb~            case KeyboardKey.Enter:~\\
\cellcolor{orange} & 2 & \verb~98~ & & \verb~                if (activeMenuButton == NEW_GAME) {~\\
\cellcolor{green} & 1 & \verb~99~ & & \verb~                    BreakoutBus.GetBus().RegisterEvent(new GameEvent {~\\
\cellcolor{green} & 1 & \verb~100~ & & \verb~                        EventType = GameEventType.GameStateEvent,~\\
\cellcolor{green} & 1 & \verb~101~ & & \verb~                        Message = "CHANGE_STATE",~\\
\cellcolor{green} & 1 & \verb~102~ & & \verb~                        StringArg1 = "GAME_RUNNING"~\\
\cellcolor{green} & 1 & \verb~103~ & & \verb~                    });~\\
\cellcolor{green} & 1 & \verb~104~ & & \verb~                } else {~\\
\cellcolor{red} & 0 & \verb~105~ & & \verb~                    BreakoutBus.GetBus().RegisterEvent(new GameEvent {~\\
\cellcolor{red} & 0 & \verb~106~ & & \verb~                        EventType = GameEventType.WindowEvent,~\\
\cellcolor{red} & 0 & \verb~107~ & & \verb~                        Message = "CLOSE_GAME",~\\
\cellcolor{red} & 0 & \verb~108~ & & \verb~                        StringArg1 = "WINDOW CLOSE"~\\
\cellcolor{red} & 0 & \verb~109~ & & \verb~                    });~\\
\cellcolor{red} & 0 & \verb~110~ & & \verb~                }~\\
\cellcolor{green} & 1 & \verb~111~ & & \verb~                break;~\\
\cellcolor{gray} &  & \verb~112~ & & \verb~        }~\\
\cellcolor{green} & 5 & \verb~113~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~114~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.States.StateMachine}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.States.StateMachine\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/Breakout/States/StateMachine.cs}\end{minipage} \\
\textbf{Covered lines:} & 29\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 29\\
\textbf{Total lines:} & 54\\
\textbf{Line coverage:} & 100\% (29 of 29)\\
\textbf{Covered branches:} & 12\\
\textbf{Total branches:} & 12\\
\textbf{Branch coverage:} & 100\% (12 of 12)\\
\textbf{Covered methods:} & 4\\
\textbf{Total methods:} & 4\\
\textbf{Method coverage:} & 100\% (4 of 4)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{get\_ActiveState()} & 100\% & 1 & 100\%\\
\hline
\textbf{.ctor()} & 100\% & 1 & 100\%\\
\hline
\textbf{ProcessEvent(...)} & 100\% & 6 & 100\%\\
\hline
\textbf{SwitchState(...)} & 100\% & 6 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/Breakout/States/StateMachine.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Events;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.State;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~namespace Breakout.States;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~/// <summary>~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~///  A StateMachine that changes between IGameStates~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~/// </summary>~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~public class StateMachine : IGameEventProcessor {~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    public IGameState ActiveState {~\\
\cellcolor{green} & 1083 & \verb~9~ & & \verb~        get; private set;~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    }~\\
\cellcolor{green} & 62 & \verb~11~ & & \verb~    public StateMachine() {~\\
\cellcolor{green} & 31 & \verb~12~ & & \verb~        BreakoutBus.GetBus().Subscribe(GameEventType.GameStateEvent, this);~\\
\cellcolor{green} & 31 & \verb~13~ & & \verb~        ActiveState = MainMenu.GetInstance();~\\
\cellcolor{green} & 31 & \verb~14~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~    ///  Recieves GameStateEvents and can either resume a state or create a new state.~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 357 & \verb~18~ & & \verb~    public void ProcessEvent(GameEvent gameEvent) {~\\
\cellcolor{green} & 714 & \verb~19~ & & \verb~        if (gameEvent.EventType == GameEventType.GameStateEvent) {~\\
\cellcolor{green} & 357 & \verb~20~ & & \verb~            switch (gameEvent.Message) {~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~                case ("RESUME_STATE"):~\\
\cellcolor{green} & 20 & \verb~22~ & & \verb~                    SwitchState(StateTransformer.TransformStringToState(gameEvent.StringArg1));~\\
\cellcolor{green} & 20 & \verb~23~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~                case ("CHANGE_STATE"): // creates a new state~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~                    // Resumes a state and makes it the ActiveState~\\
\cellcolor{green} & 337 & \verb~26~ & & \verb~                    SwitchState(StateTransformer.TransformStringToState(gameEvent.StringArg1));~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~                    // Resets the state~\\
\cellcolor{green} & 337 & \verb~28~ & & \verb~                    ActiveState.ResetState();~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~                    // GetInstance() of ActiveState which is null, therefore it's initialized~\\
\cellcolor{green} & 337 & \verb~30~ & & \verb~                    SwitchState(StateTransformer.TransformStringToState(gameEvent.StringArg1));~\\
\cellcolor{green} & 337 & \verb~31~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~32~ & & \verb~            }~\\
\cellcolor{green} & 357 & \verb~33~ & & \verb~        }~\\
\cellcolor{green} & 357 & \verb~34~ & & \verb~    }~\\
\cellcolor{green} & 694 & \verb~35~ & & \verb~    private void SwitchState(GameStateType stateType) {~\\
\cellcolor{green} & 694 & \verb~36~ & & \verb~        switch (stateType) {~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~            case GameStateType.GameRunning:~\\
\cellcolor{green} & 82 & \verb~38~ & & \verb~                ActiveState = GameRunning.GetInstance();~\\
\cellcolor{green} & 82 & \verb~39~ & & \verb~                break;~\\
\cellcolor{gray} &  & \verb~40~ & & \verb~            case GameStateType.GamePaused:~\\
\cellcolor{green} & 48 & \verb~41~ & & \verb~                ActiveState = GamePaused.GetInstance();~\\
\cellcolor{green} & 48 & \verb~42~ & & \verb~                break;~\\
\cellcolor{gray} &  & \verb~43~ & & \verb~            case GameStateType.MainMenu:~\\
\cellcolor{green} & 126 & \verb~44~ & & \verb~                ActiveState = MainMenu.GetInstance();~\\
\cellcolor{green} & 126 & \verb~45~ & & \verb~                break;~\\
\cellcolor{gray} &  & \verb~46~ & & \verb~            case GameStateType.GameLost:~\\
\cellcolor{green} & 410 & \verb~47~ & & \verb~                ActiveState = GameLost.GetInstance();~\\
\cellcolor{green} & 410 & \verb~48~ & & \verb~                break;~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~            case GameStateType.GameWon:~\\
\cellcolor{green} & 28 & \verb~50~ & & \verb~                ActiveState = GameWon.GetInstance();~\\
\cellcolor{green} & 28 & \verb~51~ & & \verb~                break;~\\
\cellcolor{gray} &  & \verb~52~ & & \verb~        }~\\
\cellcolor{green} & 694 & \verb~53~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~54~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.States.StateTransformer}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.States.StateTransformer\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/Breakout/States/StateTransformer.cs}\end{minipage} \\
\textbf{Covered lines:} & 9\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 9\\
\textbf{Total lines:} & 27\\
\textbf{Line coverage:} & 100\% (9 of 9)\\
\textbf{Covered branches:} & 10\\
\textbf{Total branches:} & 10\\
\textbf{Branch coverage:} & 100\% (10 of 10)\\
\textbf{Covered methods:} & 1\\
\textbf{Total methods:} & 1\\
\textbf{Method coverage:} & 100\% (1 of 1)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{TransformStringToSta} & 100\% & 10 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/Breakout/States/StateTransformer.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~namespace Breakout.States;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~/// <summary>~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~///  A class used to transform strings into state tyopes.~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~/// </summary>~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~public class StateTransformer {~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    ///  Transforms strings into state types.~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 699 & \verb~10~ & & \verb~    public static GameStateType TransformStringToState(string state) {~\\
\cellcolor{green} & 699 & \verb~11~ & & \verb~        switch (state) {~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~            case "GAME_RUNNING":~\\
\cellcolor{green} & 83 & \verb~13~ & & \verb~                return GameStateType.GameRunning;~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~            case "GAME_PAUSED":~\\
\cellcolor{green} & 49 & \verb~15~ & & \verb~                return GameStateType.GamePaused;~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~            case "MAIN_MENU":~\\
\cellcolor{green} & 127 & \verb~17~ & & \verb~                return GameStateType.MainMenu;~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~            case "GAME_LOST":~\\
\cellcolor{green} & 411 & \verb~19~ & & \verb~                return GameStateType.GameLost;~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~            case "GAME_WON":~\\
\cellcolor{green} & 28 & \verb~21~ & & \verb~                return GameStateType.GameWon;~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~            default:~\\
\cellcolor{green} & 1 & \verb~23~ & & \verb~                throw new ArgumentException("Invalid GameStateType string");~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~        }~\\
\cellcolor{green} & 698 & \verb~25~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~}~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~~\\
\end{longtable}
\newpage
\section{Breakout.Timer}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.Timer\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/Breakout/Timer.cs}\end{minipage} \\
\textbf{Covered lines:} & 36\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 36\\
\textbf{Total lines:} & 63\\
\textbf{Line coverage:} & 100\% (36 of 36)\\
\textbf{Covered branches:} & 6\\
\textbf{Total branches:} & 6\\
\textbf{Branch coverage:} & 100\% (6 of 6)\\
\textbf{Covered methods:} & 6\\
\textbf{Total methods:} & 6\\
\textbf{Method coverage:} & 100\% (6 of 6)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{get\_TimeLeft()} & 100\% & 1 & 100\%\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{SetTime(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{UpdateTime()} & 100\% & 2 & 100\%\\
\hline
\textbf{UpdateText()} & 100\% & 4 & 100\%\\
\hline
\textbf{Render()} & 100\% & 1 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/Breakout/Timer.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Timers;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~namespace Breakout;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~public class Timer {~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~    private int timeLeft;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~    private Text timerText;~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    private int timeElapsed;~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~    private int previousTime;~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    private int n;~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    private Vec2F position;~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~    private Vec3I white;~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~    public int TimeLeft {~\\
\cellcolor{green} & 24 & \verb~14~ & & \verb~        get => timeLeft;~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~    }~\\
\cellcolor{green} & 122 & \verb~16~ & & \verb~    public Timer(Vec2F pos, int init) {~\\
\cellcolor{green} & 61 & \verb~17~ & & \verb~        timeLeft = init;~\\
\cellcolor{green} & 61 & \verb~18~ & & \verb~        position = pos;~\\
\cellcolor{green} & 61 & \verb~19~ & & \verb~        white = new Vec3I(255, 255, 255);~\\
\cellcolor{green} & 61 & \verb~20~ & & \verb~        timerText = new Text($"Time: {timeLeft}s",~\\
\cellcolor{green} & 61 & \verb~21~ & & \verb~        position, new Vec2F(0.25f, 0.35f));~\\
\cellcolor{green} & 61 & \verb~22~ & & \verb~        timerText.SetColor(white);~\\
\cellcolor{green} & 61 & \verb~23~ & & \verb~        timeElapsed = 0;~\\
\cellcolor{green} & 61 & \verb~24~ & & \verb~        n = 0;~\\
\cellcolor{green} & 61 & \verb~25~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~    /// Sets the time left to an input value~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 54 & \verb~29~ & & \verb~    public void SetTime(int s) {~\\
\cellcolor{green} & 54 & \verb~30~ & & \verb~        timeLeft = s;~\\
\cellcolor{green} & 54 & \verb~31~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~32~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~    /// Updates the time and decrements the amount of seconds if a second has passed~\\
\cellcolor{gray} &  & \verb~34~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 2 & \verb~35~ & & \verb~    private void UpdateTime() {~\\
\cellcolor{green} & 2 & \verb~36~ & & \verb~        previousTime = timeLeft;~\\
\cellcolor{green} & 2 & \verb~37~ & & \verb~        timeElapsed = (int) StaticTimer.GetElapsedMilliseconds();~\\
\cellcolor{green} & 4 & \verb~38~ & & \verb~        if (n + 1000 < timeElapsed) {~\\
\cellcolor{green} & 2 & \verb~39~ & & \verb~            timeLeft--;~\\
\cellcolor{green} & 2 & \verb~40~ & & \verb~            n = (int) StaticTimer.GetElapsedMilliseconds();~\\
\cellcolor{green} & 2 & \verb~41~ & & \verb~        }~\\
\cellcolor{green} & 2 & \verb~42~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~43~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~44~ & & \verb~    /// Updates the text for the timer.~\\
\cellcolor{gray} &  & \verb~45~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 3 & \verb~46~ & & \verb~    private void UpdateText() {~\\
\cellcolor{green} & 5 & \verb~47~ & & \verb~        if (timeLeft > 0) {~\\
\cellcolor{green} & 2 & \verb~48~ & & \verb~            UpdateTime();~\\
\cellcolor{green} & 4 & \verb~49~ & & \verb~            if (previousTime != timeLeft) {~\\
\cellcolor{green} & 2 & \verb~50~ & & \verb~                timerText.SetText($"Time: {timeLeft}s");~\\
\cellcolor{green} & 2 & \verb~51~ & & \verb~            }~\\
\cellcolor{green} & 3 & \verb~52~ & & \verb~        } else {~\\
\cellcolor{green} & 1 & \verb~53~ & & \verb~            timerText.SetText("");~\\
\cellcolor{green} & 1 & \verb~54~ & & \verb~        }~\\
\cellcolor{green} & 3 & \verb~55~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~56~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~57~ & & \verb~    /// Renders the timer on the screen.~\\
\cellcolor{gray} &  & \verb~58~ & & \verb~    /// </summary>~\\
\cellcolor{green} & 3 & \verb~59~ & & \verb~    public void Render() {~\\
\cellcolor{green} & 3 & \verb~60~ & & \verb~        UpdateText();~\\
\cellcolor{green} & 3 & \verb~61~ & & \verb~        timerText.RenderText();~\\
\cellcolor{green} & 3 & \verb~62~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~63~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.DIKUGame}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.DIKUGame\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/DIKUGame.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 32\\
\textbf{Coverable lines:} & 32\\
\textbf{Total lines:} & 73\\
\textbf{Line coverage:} & 0\% (0 of 32)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 8\\
\textbf{Branch coverage:} & 0\% (0 of 8)\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 3\\
\textbf{Method coverage:} & 0\% (0 of 3)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{get\_Timestep()} & 100\% & 1 & 0\%\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Run()} & 0\% & 8 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/DIKUGame.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.GUI;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Timers;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~namespace DIKUArcade {~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~    /// Abstract base class for any DIKUArcade game.~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~    public abstract class DIKUGame {~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~        protected Window window;~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~        private GameTimer gameTimer;~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~        /// The exact amount of captured updates in the last second.~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~        /// Can be used for framerate independent calculations.~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~17~ & & \verb~        public static int Timestep { get; private set; }~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~19~ & & \verb~        public DIKUGame(WindowArgs windowArgs) {~\\
\cellcolor{red} & 0 & \verb~20~ & & \verb~            window = new Window(windowArgs);~\\
\cellcolor{red} & 0 & \verb~21~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~        /// Override this method to update game logic.~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~        public abstract void Update();~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~        /// Override this method to render game entities.~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~        public abstract void Render();~\\
\cellcolor{gray} &  & \verb~32~ & & \verb~~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~34~ & & \verb~        /// Enter the game loop and run the game.~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~        /// This method will never return.~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~37~ & & \verb~        public void Run() {~\\
\cellcolor{red} & 0 & \verb~38~ & & \verb~            System.Console.WriteLine("Game.Run()");~\\
\cellcolor{red} & 0 & \verb~39~ & & \verb~            gameTimer = new GameTimer(30, 30);~\\
\cellcolor{gray} &  & \verb~40~ & & \verb~~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~            try~\\
\cellcolor{red} & 0 & \verb~42~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~43~ & & \verb~                while (window.IsRunning()) {~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~                    gameTimer.MeasureTime();~\\
\cellcolor{red} & 0 & \verb~45~ & & \verb~                    window.PollEvents();~\\
\cellcolor{gray} &  & \verb~46~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~47~ & & \verb~                    while (gameTimer.ShouldUpdate()) {~\\
\cellcolor{red} & 0 & \verb~48~ & & \verb~                        Update();~\\
\cellcolor{red} & 0 & \verb~49~ & & \verb~                    }~\\
\cellcolor{gray} &  & \verb~50~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~51~ & & \verb~                    if (gameTimer.ShouldRender()) {~\\
\cellcolor{red} & 0 & \verb~52~ & & \verb~                        window.Clear();~\\
\cellcolor{red} & 0 & \verb~53~ & & \verb~                        Render();~\\
\cellcolor{red} & 0 & \verb~54~ & & \verb~                        window.SwapBuffers();~\\
\cellcolor{red} & 0 & \verb~55~ & & \verb~                    }~\\
\cellcolor{gray} &  & \verb~56~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~57~ & & \verb~                    if (gameTimer.ShouldReset()) {~\\
\cellcolor{red} & 0 & \verb~58~ & & \verb~                        Timestep = gameTimer.CapturedUpdates;~\\
\cellcolor{red} & 0 & \verb~59~ & & \verb~                    }~\\
\cellcolor{red} & 0 & \verb~60~ & & \verb~                }~\\
\cellcolor{gray} &  & \verb~61~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~62~ & & \verb~                window.DestroyWindow();~\\
\cellcolor{red} & 0 & \verb~63~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~64~ & & \verb~            catch(Exception ex) {~\\
\cellcolor{red} & 0 & \verb~65~ & & \verb~                Console.WriteLine("DIKUArcade.DIKUGame caught an exception. See message below:" + Environment.NewLine);~\\
\cellcolor{red} & 0 & \verb~66~ & & \verb~                Console.WriteLine(ex);~\\
\cellcolor{gray} &  & \verb~67~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~68~ & & \verb~                Console.WriteLine(Environment.NewLine + "Terminating program...");~\\
\cellcolor{red} & 0 & \verb~69~ & & \verb~                Environment.Exit(1);~\\
\cellcolor{red} & 0 & \verb~70~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~71~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~72~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~73~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Entities.DynamicShape}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Entities.DynamicShape\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{ome/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Entities/DynamicShape.cs}\end{minipage} \\
\textbf{Covered lines:} & 21\\
\textbf{Uncovered lines:} & 7\\
\textbf{Coverable lines:} & 28\\
\textbf{Total lines:} & 51\\
\textbf{Line coverage:} & 75\% (21 of 28)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 5\\
\textbf{Total methods:} & 7\\
\textbf{Method coverage:} & 71.4\% (5 of 7)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{ChangeDirection(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{Move()} & 100\% & 1 & 100\%\\
\hline
\textbf{op\_Explicit(...)} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{ome/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Entities/DynamicShape.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~namespace DIKUArcade.Entities {~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~    public class DynamicShape : Shape {~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~        /// Only dynamic entities carry a direction vector.~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~        public Vec2F Direction;~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~~\\
\cellcolor{green} & 6 & \verb~10~ & & \verb~        public DynamicShape(float posX, float posY, float width, float height) {~\\
\cellcolor{green} & 3 & \verb~11~ & & \verb~            Position = new Vec2F(posX, posY);~\\
\cellcolor{green} & 3 & \verb~12~ & & \verb~            Direction = new Vec2F();~\\
\cellcolor{green} & 3 & \verb~13~ & & \verb~            Extent = new Vec2F(width, height);~\\
\cellcolor{green} & 3 & \verb~14~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~        public DynamicShape(float posX, float posY, float width, float height,~\\
\cellcolor{red} & 0 & \verb~17~ & & \verb~            float dirX, float dirY) : this(posX, posY, width, height) {~\\
\cellcolor{red} & 0 & \verb~18~ & & \verb~            Direction.X = dirX;~\\
\cellcolor{red} & 0 & \verb~19~ & & \verb~            Direction.Y = dirY;~\\
\cellcolor{red} & 0 & \verb~20~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~~\\
\cellcolor{green} & 168 & \verb~22~ & & \verb~        public DynamicShape(Vec2F pos, Vec2F extent) {~\\
\cellcolor{green} & 84 & \verb~23~ & & \verb~            Position = pos;~\\
\cellcolor{green} & 84 & \verb~24~ & & \verb~            Extent = extent;~\\
\cellcolor{green} & 84 & \verb~25~ & & \verb~            Direction = new Vec2F(0f, 0f); // init 0 to avoid problems~\\
\cellcolor{green} & 84 & \verb~26~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~~\\
\cellcolor{green} & 780 & \verb~28~ & & \verb~        public DynamicShape(Vec2F pos, Vec2F extent, Vec2F dir) {~\\
\cellcolor{green} & 390 & \verb~29~ & & \verb~            Position = pos;~\\
\cellcolor{green} & 390 & \verb~30~ & & \verb~            Extent = extent;~\\
\cellcolor{green} & 390 & \verb~31~ & & \verb~            Direction = dir;~\\
\cellcolor{green} & 390 & \verb~32~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~~\\
\cellcolor{green} & 7 & \verb~34~ & & \verb~        public void ChangeDirection(Vec2F dir) {~\\
\cellcolor{green} & 7 & \verb~35~ & & \verb~            Direction = dir;~\\
\cellcolor{green} & 7 & \verb~36~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~~\\
\cellcolor{gray} &  & \verb~38~ & & \verb~~\\
\cellcolor{gray} &  & \verb~39~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~40~ & & \verb~        /// Overrides the default Shape.Move() method to add~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~        /// this object's direction to its position.~\\
\cellcolor{gray} &  & \verb~42~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 122 & \verb~43~ & & \verb~        public override void Move() {~\\
\cellcolor{green} & 122 & \verb~44~ & & \verb~            Position += Direction;~\\
\cellcolor{green} & 122 & \verb~45~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~46~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~47~ & & \verb~        public static explicit operator StationaryShape(DynamicShape obj) {~\\
\cellcolor{red} & 0 & \verb~48~ & & \verb~            return new StationaryShape(obj.Position, obj.Extent);~\\
\cellcolor{red} & 0 & \verb~49~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~50~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~51~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Entities.Entity}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Entities.Entity\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Entities/Entity.cs}\end{minipage} \\
\textbf{Covered lines:} & 13\\
\textbf{Uncovered lines:} & 6\\
\textbf{Coverable lines:} & 19\\
\textbf{Total lines:} & 40\\
\textbf{Line coverage:} & 68.4\% (13 of 19)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 5\\
\textbf{Total methods:} & 7\\
\textbf{Method coverage:} & 71.4\% (5 of 7)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{get\_Shape()} & 100\% & 1 & 100\%\\
\hline
\textbf{get\_Image()} & 100\% & 1 & 100\%\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{DeleteEntity()} & 100\% & 1 & 100\%\\
\hline
\textbf{IsDeleted()} & 100\% & 1 & 100\%\\
\hline
\textbf{RenderEntity()} & 100\% & 1 & 0\%\\
\hline
\textbf{RenderEntity(...)} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Entities/Entity.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~namespace DIKUArcade.Entities {~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~    public class Entity {~\\
\cellcolor{green} & 6460 & \verb~5~ & & \verb~        public Shape Shape { get; set; }~\\
\cellcolor{green} & 5251 & \verb~6~ & & \verb~        public IBaseImage Image { get; set; }~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~        private bool isDeleted;~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~~\\
\cellcolor{green} & 10502 & \verb~10~ & & \verb~        public Entity(Shape shape, IBaseImage image) {~\\
\cellcolor{green} & 5251 & \verb~11~ & & \verb~            isDeleted = false;~\\
\cellcolor{green} & 5251 & \verb~12~ & & \verb~            Shape = shape;~\\
\cellcolor{green} & 5251 & \verb~13~ & & \verb~            Image = image;~\\
\cellcolor{green} & 5251 & \verb~14~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~        /// Make an Entity as ready for being deleted.~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~        /// This functionality is needed for the EntityContainer class.~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 31 & \verb~20~ & & \verb~        public void DeleteEntity() {~\\
\cellcolor{green} & 31 & \verb~21~ & & \verb~            isDeleted = true;~\\
\cellcolor{green} & 31 & \verb~22~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~        /// Check if this Entity has been marked as ready for being deleted.~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~        /// This functionality is needed for the EntityContainer class.~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 1375 & \verb~28~ & & \verb~        public bool IsDeleted() {~\\
\cellcolor{green} & 1375 & \verb~29~ & & \verb~            return isDeleted;~\\
\cellcolor{green} & 1375 & \verb~30~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~32~ & & \verb~        public void RenderEntity() {~\\
\cellcolor{red} & 0 & \verb~33~ & & \verb~            Image.Render(Shape);~\\
\cellcolor{red} & 0 & \verb~34~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~36~ & & \verb~        public void RenderEntity(Camera camera) {~\\
\cellcolor{red} & 0 & \verb~37~ & & \verb~            Image.Render(Shape, camera);~\\
\cellcolor{red} & 0 & \verb~38~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~39~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~40~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Entities.EntityContainer}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Entities.EntityContainer\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Entities/EntityContainer.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 63\\
\textbf{Coverable lines:} & 63\\
\textbf{Total lines:} & 132\\
\textbf{Line coverage:} & 0\% (0 of 63)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 10\\
\textbf{Branch coverage:} & 0\% (0 of 10)\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 16\\
\textbf{Method coverage:} & 0\% (0 of 16)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{.ctor()} & 100\% & 1 & 0\%\\
\hline
\textbf{AddStationaryEntity(} & 100\% & 1 & 0\%\\
\hline
\textbf{AddDynamicEntity(...} & 100\% & 1 & 0\%\\
\hline
\textbf{Iterate(...)} & 0\% & 6 & 0\%\\
\hline
\textbf{RenderEntities()} & 0\% & 2 & 0\%\\
\hline
\textbf{RenderEntities(...)} & 0\% & 2 & 0\%\\
\hline
\textbf{ClearContainer()} & 100\% & 1 & 0\%\\
\hline
\textbf{CountEntities()} & 100\% & 1 & 0\%\\
\hline
\textbf{System.Collections.I} & 100\% & 1 & 0\%\\
\hline
\textbf{GetEnumerator()} & 100\% & 1 & 0\%\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{MoveNext()} & 100\% & 1 & 0\%\\
\hline
\textbf{Reset()} & 100\% & 1 & 0\%\\
\hline
\textbf{System.Collections.I} & 100\% & 1 & 0\%\\
\hline
\textbf{get\_Current()} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Entities/EntityContainer.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using System.Collections.ObjectModel;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~namespace DIKUArcade.Entities {~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    public class EntityContainer : IEnumerable {~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~        private List<Entity> entities;~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~11~ & & \verb~        public EntityContainer(int size) {~\\
\cellcolor{red} & 0 & \verb~12~ & & \verb~            entities = new List<Entity>(size);~\\
\cellcolor{red} & 0 & \verb~13~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~15~ & & \verb~        public EntityContainer() : this(50) { }~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~17~ & & \verb~        public void AddStationaryEntity(StationaryShape ent, IBaseImage img) {~\\
\cellcolor{red} & 0 & \verb~18~ & & \verb~            entities.Add(new Entity(ent, img));~\\
\cellcolor{red} & 0 & \verb~19~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~21~ & & \verb~        public void AddDynamicEntity(DynamicShape ent, IBaseImage img) {~\\
\cellcolor{red} & 0 & \verb~22~ & & \verb~            entities.Add(new Entity(ent, img));~\\
\cellcolor{red} & 0 & \verb~23~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~        /// Delegate method for iterating through an EntityContainer.~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~        /// This function should return true if the Entity should be~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~        /// removed from the EntityContainer.~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~        /// <param name="entity"></param>~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~        public delegate void IteratorMethod(Entity entity);~\\
\cellcolor{gray} &  & \verb~32~ & & \verb~~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~        /// <summary>Iterate through all Entities in this EntityContainer.</summary>~\\
\cellcolor{gray} &  & \verb~34~ & & \verb~        /// <remarks>This method can modify objects during iteration!~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~        /// If this functionality is undesired, iterate then through this~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~        /// EntityContainer using a 'foreach'-loop (from IEnumerable).</remarks>~\\
\cellcolor{red} & 0 & \verb~37~ & & \verb~        public void Iterate(IteratorMethod iterator) {~\\
\cellcolor{red} & 0 & \verb~38~ & & \verb~            var count = entities.Count;~\\
\cellcolor{red} & 0 & \verb~39~ & & \verb~            var newList = new List<Entity>(count);~\\
\cellcolor{gray} &  & \verb~40~ & & \verb~~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~            // iterate through entities~\\
\cellcolor{red} & 0 & \verb~42~ & & \verb~            for (int i = 0; i < count; i++) {~\\
\cellcolor{red} & 0 & \verb~43~ & & \verb~                iterator(entities[i]);~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~45~ & & \verb~~\\
\cellcolor{gray} &  & \verb~46~ & & \verb~            // keep Entities that have not been marked for deletion during iteration~\\
\cellcolor{red} & 0 & \verb~47~ & & \verb~            foreach (var entity in entities) {~\\
\cellcolor{red} & 0 & \verb~48~ & & \verb~                if (!entity.IsDeleted()) {~\\
\cellcolor{red} & 0 & \verb~49~ & & \verb~                    newList.Add(entity);~\\
\cellcolor{red} & 0 & \verb~50~ & & \verb~                }~\\
\cellcolor{red} & 0 & \verb~51~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~52~ & & \verb~            entities = newList;~\\
\cellcolor{red} & 0 & \verb~53~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~54~ & & \verb~~\\
\cellcolor{gray} &  & \verb~55~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~56~ & & \verb~        /// Render all entities in this EntityContainer~\\
\cellcolor{gray} &  & \verb~57~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~58~ & & \verb~        public void RenderEntities() {~\\
\cellcolor{red} & 0 & \verb~59~ & & \verb~            foreach (Entity entity in entities) {~\\
\cellcolor{red} & 0 & \verb~60~ & & \verb~                entity.Image.Render(entity.Shape);~\\
\cellcolor{red} & 0 & \verb~61~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~62~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~63~ & & \verb~~\\
\cellcolor{gray} &  & \verb~64~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~65~ & & \verb~        /// Render all entities in this EntityContainer~\\
\cellcolor{gray} &  & \verb~66~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~67~ & & \verb~        public void RenderEntities(Camera camera) {~\\
\cellcolor{red} & 0 & \verb~68~ & & \verb~            foreach (Entity entity in entities) {~\\
\cellcolor{red} & 0 & \verb~69~ & & \verb~                entity.Image.Render(entity.Shape, camera);~\\
\cellcolor{red} & 0 & \verb~70~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~71~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~72~ & & \verb~~\\
\cellcolor{gray} &  & \verb~73~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~74~ & & \verb~        /// Remove all entities from this container~\\
\cellcolor{gray} &  & \verb~75~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~76~ & & \verb~        public void ClearContainer() {~\\
\cellcolor{red} & 0 & \verb~77~ & & \verb~            entities.Clear();~\\
\cellcolor{red} & 0 & \verb~78~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~79~ & & \verb~~\\
\cellcolor{gray} &  & \verb~80~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~81~ & & \verb~        /// Count the number of entities in the EntityContainer~\\
\cellcolor{gray} &  & \verb~82~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~83~ & & \verb~        public int CountEntities() {~\\
\cellcolor{red} & 0 & \verb~84~ & & \verb~            return entities.Count;~\\
\cellcolor{red} & 0 & \verb~85~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~86~ & & \verb~~\\
\cellcolor{gray} &  & \verb~87~ & & \verb~        // IEnumerable interface:~\\
\cellcolor{gray} &  & \verb~88~ & & \verb~        #region IEnumerable~\\
\cellcolor{gray} &  & \verb~89~ & & \verb~~\\
\cellcolor{gray} &  & \verb~90~ & & \verb~        IEnumerator IEnumerable.GetEnumerator()~\\
\cellcolor{red} & 0 & \verb~91~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~92~ & & \verb~            return GetEnumerator();~\\
\cellcolor{red} & 0 & \verb~93~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~94~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~95~ & & \verb~        public IEnumerator GetEnumerator() {~\\
\cellcolor{red} & 0 & \verb~96~ & & \verb~            return new EntityContainerEnum(entities);~\\
\cellcolor{red} & 0 & \verb~97~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~98~ & & \verb~~\\
\cellcolor{gray} &  & \verb~99~ & & \verb~        private class EntityContainerEnum : IEnumerator {~\\
\cellcolor{gray} &  & \verb~100~ & & \verb~            private ReadOnlyCollection<Entity> entities;~\\
\cellcolor{red} & 0 & \verb~101~ & & \verb~            private int position = -1;~\\
\cellcolor{gray} &  & \verb~102~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~103~ & & \verb~            public EntityContainerEnum(List<Entity> entities) {~\\
\cellcolor{red} & 0 & \verb~104~ & & \verb~                this.entities = entities.AsReadOnly();~\\
\cellcolor{red} & 0 & \verb~105~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~106~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~107~ & & \verb~            public bool MoveNext() {~\\
\cellcolor{red} & 0 & \verb~108~ & & \verb~                position++;~\\
\cellcolor{red} & 0 & \verb~109~ & & \verb~                return position < entities.Count;~\\
\cellcolor{red} & 0 & \verb~110~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~111~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~112~ & & \verb~            public void Reset() {~\\
\cellcolor{red} & 0 & \verb~113~ & & \verb~                position = -1;~\\
\cellcolor{red} & 0 & \verb~114~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~115~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~116~ & & \verb~            object IEnumerator.Current => Current;~\\
\cellcolor{gray} &  & \verb~117~ & & \verb~~\\
\cellcolor{gray} &  & \verb~118~ & & \verb~            public Entity Current {~\\
\cellcolor{red} & 0 & \verb~119~ & & \verb~                get {~\\
\cellcolor{red} & 0 & \verb~120~ & & \verb~                    try {~\\
\cellcolor{red} & 0 & \verb~121~ & & \verb~                        return entities[position];~\\
\cellcolor{red} & 0 & \verb~122~ & & \verb~                    } catch (IndexOutOfRangeException) {~\\
\cellcolor{red} & 0 & \verb~123~ & & \verb~                        throw new InvalidOperationException();~\\
\cellcolor{gray} &  & \verb~124~ & & \verb~                    }~\\
\cellcolor{red} & 0 & \verb~125~ & & \verb~                }~\\
\cellcolor{gray} &  & \verb~126~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~127~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~128~ & & \verb~~\\
\cellcolor{gray} &  & \verb~129~ & & \verb~        #endregion~\\
\cellcolor{gray} &  & \verb~130~ & & \verb~~\\
\cellcolor{gray} &  & \verb~131~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~132~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Entities.EntityContainer$<$T$>$}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Entities.EntityContainer$<$T$>$\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Entities/EntityContainerT.cs}\end{minipage} \\
\textbf{Covered lines:} & 39\\
\textbf{Uncovered lines:} & 12\\
\textbf{Coverable lines:} & 51\\
\textbf{Total lines:} & 113\\
\textbf{Line coverage:} & 76.4\% (39 of 51)\\
\textbf{Covered branches:} & 6\\
\textbf{Total branches:} & 8\\
\textbf{Branch coverage:} & 75\% (6 of 8)\\
\textbf{Covered methods:} & 11\\
\textbf{Total methods:} & 15\\
\textbf{Method coverage:} & 73.3\% (11 of 15)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{.ctor()} & 100\% & 1 & 0\%\\
\hline
\textbf{AddEntity(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{Iterate(...)} & 100\% & 6 & 100\%\\
\hline
\textbf{RenderEntities()} & 0\% & 2 & 0\%\\
\hline
\textbf{ClearContainer()} & 100\% & 1 & 100\%\\
\hline
\textbf{CountEntities()} & 100\% & 1 & 100\%\\
\hline
\textbf{System.Collections.I} & 100\% & 1 & 0\%\\
\hline
\textbf{GetEnumerator()} & 100\% & 1 & 100\%\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{MoveNext()} & 100\% & 1 & 100\%\\
\hline
\textbf{Reset()} & 100\% & 1 & 0\%\\
\hline
\textbf{System.IDisposable.D} & 100\% & 1 & 100\%\\
\hline
\textbf{System.Collections.I} & 100\% & 1 & 100\%\\
\hline
\textbf{get\_Current()} & 100\% & 1 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Entities/EntityContainerT.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using System.Collections.ObjectModel;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~namespace DIKUArcade.Entities {~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    public sealed class EntityContainer<T> : IEnumerable where T: Entity {~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~        private List<T> entities;~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~~\\
\cellcolor{green} & 644 & \verb~11~ & & \verb~        public EntityContainer(int size) {~\\
\cellcolor{green} & 322 & \verb~12~ & & \verb~            entities = new List<T>(size);~\\
\cellcolor{green} & 322 & \verb~13~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~15~ & & \verb~        public EntityContainer() : this(50) { }~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~~\\
\cellcolor{green} & 4739 & \verb~17~ & & \verb~        public void AddEntity(T obj) {~\\
\cellcolor{green} & 4739 & \verb~18~ & & \verb~            entities.Add(obj);~\\
\cellcolor{green} & 4739 & \verb~19~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~        /// Delegate method for iterating through an EntityContainer.~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~        /// This function should return true if the object should be~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~        /// removed from the EntityContainer.~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~        /// <param name="obj">Generic object of type T</param>~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~        public delegate void IteratorMethod(T obj);~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~        /// <summary>Iterate through all objects in this EntityContainer.</summary>~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~        /// <remarks>This method can modify objects during iteration!~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~        /// If this functionality is undesired, iterate then through this~\\
\cellcolor{gray} &  & \verb~32~ & & \verb~        /// EntityContainer using a 'foreach'-loop (from IEnumerable).</remarks>~\\
\cellcolor{green} & 193 & \verb~33~ & & \verb~        public void Iterate(IteratorMethod iterator) {~\\
\cellcolor{green} & 193 & \verb~34~ & & \verb~            var count = entities.Count;~\\
\cellcolor{green} & 193 & \verb~35~ & & \verb~            var newList = new List<T>(count);~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~            // iterate through entities~\\
\cellcolor{green} & 3929 & \verb~38~ & & \verb~            for (int i = 0; i < count; i++) {~\\
\cellcolor{green} & 1181 & \verb~39~ & & \verb~                iterator(entities[i]);~\\
\cellcolor{green} & 1181 & \verb~40~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~~\\
\cellcolor{gray} &  & \verb~42~ & & \verb~            // keep Entities that have not been marked for deletion during iteration~\\
\cellcolor{green} & 4644 & \verb~43~ & & \verb~            foreach (var obj in entities) {~\\
\cellcolor{green} & 2690 & \verb~44~ & & \verb~                if (!obj.IsDeleted()) {~\\
\cellcolor{green} & 1335 & \verb~45~ & & \verb~                    newList.Add(obj);~\\
\cellcolor{green} & 1335 & \verb~46~ & & \verb~                }~\\
\cellcolor{green} & 1355 & \verb~47~ & & \verb~            }~\\
\cellcolor{green} & 193 & \verb~48~ & & \verb~            entities = newList;~\\
\cellcolor{green} & 193 & \verb~49~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~50~ & & \verb~~\\
\cellcolor{gray} &  & \verb~51~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~52~ & & \verb~        /// Render all entities in this EntityContainer~\\
\cellcolor{gray} &  & \verb~53~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~54~ & & \verb~        public void RenderEntities() {~\\
\cellcolor{red} & 0 & \verb~55~ & & \verb~            foreach (var obj in entities) {~\\
\cellcolor{red} & 0 & \verb~56~ & & \verb~                obj.Image.Render(obj.Shape);~\\
\cellcolor{red} & 0 & \verb~57~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~58~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~59~ & & \verb~~\\
\cellcolor{gray} &  & \verb~60~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~61~ & & \verb~        /// Remove all entities from this container~\\
\cellcolor{gray} &  & \verb~62~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 207 & \verb~63~ & & \verb~        public void ClearContainer() {~\\
\cellcolor{green} & 207 & \verb~64~ & & \verb~            entities.Clear();~\\
\cellcolor{green} & 207 & \verb~65~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~66~ & & \verb~~\\
\cellcolor{gray} &  & \verb~67~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~68~ & & \verb~        /// Count the number of entities in the EntityContainer~\\
\cellcolor{gray} &  & \verb~69~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 201 & \verb~70~ & & \verb~        public int CountEntities() {~\\
\cellcolor{green} & 201 & \verb~71~ & & \verb~            return entities.Count;~\\
\cellcolor{green} & 201 & \verb~72~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~73~ & & \verb~~\\
\cellcolor{gray} &  & \verb~74~ & & \verb~        // IEnumerable interface:~\\
\cellcolor{gray} &  & \verb~75~ & & \verb~        #region IEnumerable~\\
\cellcolor{gray} &  & \verb~76~ & & \verb~~\\
\cellcolor{gray} &  & \verb~77~ & & \verb~        IEnumerator IEnumerable.GetEnumerator()~\\
\cellcolor{red} & 0 & \verb~78~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~79~ & & \verb~            return GetEnumerator();~\\
\cellcolor{red} & 0 & \verb~80~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~81~ & & \verb~~\\
\cellcolor{green} & 42 & \verb~82~ & & \verb~        public IEnumerator GetEnumerator() {~\\
\cellcolor{green} & 42 & \verb~83~ & & \verb~            return new EntityContainerEnum(entities);~\\
\cellcolor{green} & 42 & \verb~84~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~85~ & & \verb~~\\
\cellcolor{gray} &  & \verb~86~ & & \verb~        private class EntityContainerEnum : IEnumerator<T> {~\\
\cellcolor{gray} &  & \verb~87~ & & \verb~            private ReadOnlyCollection<T> entities;~\\
\cellcolor{green} & 42 & \verb~88~ & & \verb~            private int position = -1;~\\
\cellcolor{gray} &  & \verb~89~ & & \verb~~\\
\cellcolor{green} & 84 & \verb~90~ & & \verb~            public EntityContainerEnum(List<T> entities) {~\\
\cellcolor{green} & 42 & \verb~91~ & & \verb~                this.entities = entities.AsReadOnly();~\\
\cellcolor{green} & 42 & \verb~92~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~93~ & & \verb~~\\
\cellcolor{green} & 54 & \verb~94~ & & \verb~            public bool MoveNext() {~\\
\cellcolor{green} & 54 & \verb~95~ & & \verb~                position++;~\\
\cellcolor{green} & 54 & \verb~96~ & & \verb~                return position < entities.Count;~\\
\cellcolor{green} & 54 & \verb~97~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~98~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~99~ & & \verb~            public void Reset() {~\\
\cellcolor{red} & 0 & \verb~100~ & & \verb~                position = -1;~\\
\cellcolor{red} & 0 & \verb~101~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~102~ & & \verb~~\\
\cellcolor{green} & 84 & \verb~103~ & & \verb~            void IDisposable.Dispose() { }~\\
\cellcolor{gray} &  & \verb~104~ & & \verb~~\\
\cellcolor{green} & 16 & \verb~105~ & & \verb~            object IEnumerator.Current => Current;~\\
\cellcolor{gray} &  & \verb~106~ & & \verb~~\\
\cellcolor{green} & 16 & \verb~107~ & & \verb~            public T Current => entities[position];~\\
\cellcolor{gray} &  & \verb~108~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~109~ & & \verb~~\\
\cellcolor{gray} &  & \verb~110~ & & \verb~        #endregion~\\
\cellcolor{gray} &  & \verb~111~ & & \verb~~\\
\cellcolor{gray} &  & \verb~112~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~113~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Entities.Shape}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Entities.Shape\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Entities/Shape.cs}\end{minipage} \\
\textbf{Covered lines:} & 6\\
\textbf{Uncovered lines:} & 55\\
\textbf{Coverable lines:} & 61\\
\textbf{Total lines:} & 114\\
\textbf{Line coverage:} & 9.8\% (6 of 61)\\
\textbf{Covered branches:} & 1\\
\textbf{Total branches:} & 4\\
\textbf{Branch coverage:} & 25\% (1 of 4)\\
\textbf{Covered methods:} & 3\\
\textbf{Total methods:} & 20\\
\textbf{Method coverage:} & 15\% (3 of 20)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{get\_Rotation()} & 100\% & 1 & 100\%\\
\hline
\textbf{get\_Extent()} & 100\% & 1 & 100\%\\
\hline
\textbf{AsDynamicShape()} & 50.0\% & 2 & 100\%\\
\hline
\textbf{AsStationaryShape()} & 0\% & 2 & 0\%\\
\hline
\textbf{Scale(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Scale(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{ScaleX(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{ScaleY(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{ScaleXFromCenter(...} & 100\% & 1 & 0\%\\
\hline
\textbf{ScaleYFromCenter(...} & 100\% & 1 & 0\%\\
\hline
\textbf{ScaleFromCenter(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{ScaleFromCenter(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Move()} & 100\% & 1 & 0\%\\
\hline
\textbf{Move(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{MoveX(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{MoveY(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Move(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Rotate(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{SetRotation(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{SetPosition(...)} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Entities/Shape.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~namespace DIKUArcade.Entities {~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~    public class Shape {~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~        /// Shape's rotational angle measured in radians.~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 3 & \verb~8~ & & \verb~        public float Rotation { get; set; }~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~        /// Basic Shape properties~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~        public Vec2F Position;~\\
\cellcolor{green} & 21585 & \verb~14~ & & \verb~        public Vec2F Extent { get; set; }~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~        /// Performs a downcast on this Shape instance to a~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~        /// DynamicShape. If the downcast fails, a new~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~        /// DynamicShape is returned instead with this Shape's~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~        /// Position and Extent properties, and a default (0,0)~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~        /// Direction vector.~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~        /// <returns></returns>~\\
\cellcolor{green} & 84 & \verb~24~ & & \verb~        public DynamicShape AsDynamicShape() {~\\
\cellcolor{green} & 84 & \verb~25~ & & \verb~            var shape = this as DynamicShape;~\\
\cellcolor{orange} & 84 & \verb~26~ & & \verb~            return shape ?? new DynamicShape(Position, Extent);~\\
\cellcolor{green} & 84 & \verb~27~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~        /// Performs a downcast on this Shape instance to a~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~        /// StationaryShape. If the downcast fails, a new~\\
\cellcolor{gray} &  & \verb~32~ & & \verb~        /// StationaryShape is returned instead with this Shape's~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~        /// Position and Extent properties.~\\
\cellcolor{gray} &  & \verb~34~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~        /// <returns></returns>~\\
\cellcolor{red} & 0 & \verb~36~ & & \verb~        public StationaryShape AsStationaryShape() {~\\
\cellcolor{red} & 0 & \verb~37~ & & \verb~            var sta = this as StationaryShape;~\\
\cellcolor{red} & 0 & \verb~38~ & & \verb~            return sta ?? new StationaryShape(Position, Extent);~\\
\cellcolor{red} & 0 & \verb~39~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~40~ & & \verb~~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~        // Do not reference other shapes if you intend to scale.~\\
\cellcolor{gray} &  & \verb~42~ & & \verb~        // Use .Copy() or you might scale everything.~\\
\cellcolor{red} & 0 & \verb~43~ & & \verb~        public void Scale(float scale) {~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~            Extent *= scale;~\\
\cellcolor{red} & 0 & \verb~45~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~46~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~47~ & & \verb~        public void Scale(Vec2F scalar) {~\\
\cellcolor{gray} &  & \verb~48~ & & \verb~            // This is doing pairwise vector multiplication!~\\
\cellcolor{red} & 0 & \verb~49~ & & \verb~            Extent *= scalar;~\\
\cellcolor{red} & 0 & \verb~50~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~51~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~52~ & & \verb~        public void ScaleX(float scale) {~\\
\cellcolor{red} & 0 & \verb~53~ & & \verb~            Extent.X *= scale;~\\
\cellcolor{red} & 0 & \verb~54~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~55~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~56~ & & \verb~        public void ScaleY(float scale) {~\\
\cellcolor{red} & 0 & \verb~57~ & & \verb~            Extent.Y *= scale;~\\
\cellcolor{red} & 0 & \verb~58~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~59~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~60~ & & \verb~        public void ScaleXFromCenter(float scale) {~\\
\cellcolor{red} & 0 & \verb~61~ & & \verb~            Position.X = (Position.X + Extent.X / 2.0f) - ((Extent.X / 2.0f) * scale);~\\
\cellcolor{red} & 0 & \verb~62~ & & \verb~            Extent.X *= scale;~\\
\cellcolor{red} & 0 & \verb~63~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~64~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~65~ & & \verb~        public void ScaleYFromCenter(float scale) {~\\
\cellcolor{red} & 0 & \verb~66~ & & \verb~            Position.Y = (Position.Y + Extent.Y / 2.0f) - (Extent.Y / 2.0f * scale);~\\
\cellcolor{red} & 0 & \verb~67~ & & \verb~            Extent.Y *= scale;~\\
\cellcolor{red} & 0 & \verb~68~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~69~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~70~ & & \verb~        public void ScaleFromCenter(float scale) {~\\
\cellcolor{red} & 0 & \verb~71~ & & \verb~            ScaleXFromCenter(scale);~\\
\cellcolor{red} & 0 & \verb~72~ & & \verb~            ScaleYFromCenter(scale);~\\
\cellcolor{red} & 0 & \verb~73~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~74~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~75~ & & \verb~        public void ScaleFromCenter(Vec2F scalar) {~\\
\cellcolor{red} & 0 & \verb~76~ & & \verb~            ScaleXFromCenter(scalar.X);~\\
\cellcolor{red} & 0 & \verb~77~ & & \verb~            ScaleYFromCenter(scalar.Y);~\\
\cellcolor{red} & 0 & \verb~78~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~79~ & & \verb~~\\
\cellcolor{gray} &  & \verb~80~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~81~ & & \verb~        /// Default Move method which does nothing.~\\
\cellcolor{gray} &  & \verb~82~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~83~ & & \verb~        public virtual void Move() {}~\\
\cellcolor{gray} &  & \verb~84~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~85~ & & \verb~        public void Move(Vec2F mover) {~\\
\cellcolor{red} & 0 & \verb~86~ & & \verb~            Position += mover;~\\
\cellcolor{red} & 0 & \verb~87~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~88~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~89~ & & \verb~        public void MoveX(float move) {~\\
\cellcolor{red} & 0 & \verb~90~ & & \verb~            Position.X += move;~\\
\cellcolor{red} & 0 & \verb~91~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~92~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~93~ & & \verb~        public void MoveY(float move) {~\\
\cellcolor{red} & 0 & \verb~94~ & & \verb~            Position.Y += move;~\\
\cellcolor{red} & 0 & \verb~95~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~96~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~97~ & & \verb~        public void Move(float x, float y) {~\\
\cellcolor{red} & 0 & \verb~98~ & & \verb~            MoveX(x);~\\
\cellcolor{red} & 0 & \verb~99~ & & \verb~            MoveY(y);~\\
\cellcolor{red} & 0 & \verb~100~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~101~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~102~ & & \verb~        public void Rotate(float angleRadians) {~\\
\cellcolor{red} & 0 & \verb~103~ & & \verb~            Rotation += angleRadians;~\\
\cellcolor{red} & 0 & \verb~104~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~105~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~106~ & & \verb~        public void SetRotation(float angleRadians) {~\\
\cellcolor{red} & 0 & \verb~107~ & & \verb~            Rotation = angleRadians;~\\
\cellcolor{red} & 0 & \verb~108~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~109~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~110~ & & \verb~        public void SetPosition(Vec2F newPosition) {~\\
\cellcolor{red} & 0 & \verb~111~ & & \verb~            Position = newPosition;~\\
\cellcolor{red} & 0 & \verb~112~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~113~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~114~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Entities.StationaryShape}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Entities.StationaryShape\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Entities/StationaryShape.cs}\end{minipage} \\
\textbf{Covered lines:} & 4\\
\textbf{Uncovered lines:} & 7\\
\textbf{Coverable lines:} & 11\\
\textbf{Total lines:} & 23\\
\textbf{Line coverage:} & 36.3\% (4 of 11)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 1\\
\textbf{Total methods:} & 3\\
\textbf{Method coverage:} & 33.3\% (1 of 3)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{op\_Explicit(...)} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Entities/StationaryShape.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~namespace DIKUArcade.Entities {~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~    /// Similar to DynamicShape, but does not contain direction information,~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~    /// since a static object os not meant to be affected by game physics.~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    public class StationaryShape : Shape {~\\
\cellcolor{red} & 0 & \verb~9~ & & \verb~        public StationaryShape(float posX, float posY, float width, float height) {~\\
\cellcolor{red} & 0 & \verb~10~ & & \verb~            Position = new Vec2F(posX, posY);~\\
\cellcolor{red} & 0 & \verb~11~ & & \verb~            Extent = new Vec2F(width, height);~\\
\cellcolor{red} & 0 & \verb~12~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~~\\
\cellcolor{green} & 34296 & \verb~14~ & & \verb~        public StationaryShape(Vec2F pos, Vec2F extent) {~\\
\cellcolor{green} & 17148 & \verb~15~ & & \verb~            Position = pos;~\\
\cellcolor{green} & 17148 & \verb~16~ & & \verb~            Extent = extent;~\\
\cellcolor{green} & 17148 & \verb~17~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~19~ & & \verb~        public static explicit operator DynamicShape(StationaryShape sta) {~\\
\cellcolor{red} & 0 & \verb~20~ & & \verb~            return new DynamicShape(sta.Position, sta.Extent);~\\
\cellcolor{red} & 0 & \verb~21~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Events.GameEventBus}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Events.GameEventBus\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Events/GameEventBus.cs}\end{minipage} \\
\textbf{Covered lines:} & 86\\
\textbf{Uncovered lines:} & 88\\
\textbf{Coverable lines:} & 174\\
\textbf{Total lines:} & 285\\
\textbf{Line coverage:} & 49.4\% (86 of 174)\\
\textbf{Covered branches:} & 19\\
\textbf{Total branches:} & 60\\
\textbf{Branch coverage:} & 31.6\% (19 of 60)\\
\textbf{Covered methods:} & 11\\
\textbf{Total methods:} & 19\\
\textbf{Method coverage:} & 57.8\% (11 of 19)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor()} & 100\% & 1 & 100\%\\
\hline
\textbf{SwapTimedEventLists(} & 100\% & 1 & 100\%\\
\hline
\textbf{InitializeEventBus(.} & 83.33\% & 6 & 94.44\%\\
\hline
\textbf{Subscribe(...)} & 50.0\% & 4 & 60.0\%\\
\hline
\textbf{Unsubscribe(...)} & 0\% & 4 & 0\%\\
\hline
\textbf{RegisterTimedEvent(.} & 25.00\% & 4 & 57.14\%\\
\hline
\textbf{AddOrResetTimedEvent} & 0\% & 4 & 0\%\\
\hline
\textbf{CancelTimedEvent(...} & 0\% & 4 & 0\%\\
\hline
\textbf{ResetTimedEvent(...)} & 0\% & 2 & 0\%\\
\hline
\textbf{HasTimedEvent(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{RegisterEvent(...)} & 50.0\% & 2 & 62.50\%\\
\hline
\textbf{ProcessTimedEvents()} & 75.00\% & 4 & 91.66\%\\
\hline
\textbf{ProcessEvents(...)} & 50.0\% & 2 & 84.00\%\\
\hline
\textbf{ProcessEventsSequent} & 0\% & 16 & 0\%\\
\hline
\textbf{ProcessEvents()} & 100\% & 2 & 100\%\\
\hline
\textbf{ProcessEventsSequent} & 0\% & 2 & 0\%\\
\hline
\textbf{BreakProcessing()} & 100\% & 1 & 100\%\\
\hline
\textbf{ResetBreakProcessing} & 100\% & 1 & 0\%\\
\hline
\textbf{Flush()} & 100\% & 4 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Events/GameEventBus.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using System.Threading.Tasks;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using DIKUArcade.Timers;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~namespace DIKUArcade.Events~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~{~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~    /// Default implementation of GameEventBus (see below) which uses GameEventType~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    /// instead of a generic enum event type.~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    /// GameEventBus is the core module for processing events in the DIKUArcade game engine. Modules can register events~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~    /// add them to the queues. Events are distinguished by event types to improve processing performance. Event process~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~    /// can register/subscribe themself to receive events of a certain event type. For a single event, all processors ar~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~    /// called with this event (broadcast semantic).~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~    public class GameEventBus : IGameEventBus, ITimedGameEventBus, IGameEventBusController~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~    {~\\
\cellcolor{green} & 1 & \verb~18~ & & \verb~        private bool _initialized = false;~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~        /// Dictionary of registered event processors for a given game event type.~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~        private Dictionary<GameEventType, ICollection<IGameEventProcessor>> _eventProcessors;~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~        /// Dictionary of game event queues for different game event types.~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~        private Dictionary<GameEventType, GameEventQueue<GameEvent>> _eventQueues;~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~        /// Stops processing the pipeline, e.g. needed due real-time constraints.~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 1 & \verb~31~ & & \verb~        private bool _breakExecution = false;~\\
\cellcolor{gray} &  & \verb~32~ & & \verb~~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~34~ & & \verb~        /// List of events which must be processed after a specified time interval has passed.~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~        /// We use a double-buffered system.~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 1 & \verb~37~ & & \verb~        private int _activeTimedEventList = 0;~\\
\cellcolor{green} & 1 & \verb~38~ & & \verb~        private int _inactiveTimedEventList = 1;~\\
\cellcolor{gray} &  & \verb~39~ & & \verb~        private List<TimedGameEvent>[] _timedEventLists;~\\
\cellcolor{gray} &  & \verb~40~ & & \verb~~\\
\cellcolor{green} & 41 & \verb~41~ & & \verb~        private void SwapTimedEventLists() {~\\
\cellcolor{green} & 41 & \verb~42~ & & \verb~            _activeTimedEventList = (_activeTimedEventList + 1) % 2;~\\
\cellcolor{green} & 41 & \verb~43~ & & \verb~            _inactiveTimedEventList = (_inactiveTimedEventList + 1) % 2;~\\
\cellcolor{green} & 41 & \verb~44~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~45~ & & \verb~~\\
\cellcolor{gray} &  & \verb~46~ & & \verb~~\\
\cellcolor{gray} &  & \verb~47~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~48~ & & \verb~        /// Initialized the event bus to handle the specified event types.~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~        /// An exception is thrown if called on an already initialized GameEventBus.~\\
\cellcolor{gray} &  & \verb~50~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~51~ & & \verb~        /// <exception cref="InvalidOperationException"></exception>~\\
\cellcolor{gray} &  & \verb~52~ & & \verb~        public void InitializeEventBus(ICollection<GameEventType> eventTypeList)~\\
\cellcolor{green} & 1 & \verb~53~ & & \verb~        {~\\
\cellcolor{orange} & 1 & \verb~54~ & & \verb~            if (_initialized) {~\\
\cellcolor{red} & 0 & \verb~55~ & & \verb~                throw new InvalidOperationException("GameEventBus is already initialized!");~\\
\cellcolor{gray} &  & \verb~56~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~57~ & & \verb~~\\
\cellcolor{green} & 1 & \verb~58~ & & \verb~            _eventProcessors= new Dictionary<GameEventType, ICollection<IGameEventProcessor>>();~\\
\cellcolor{green} & 1 & \verb~59~ & & \verb~            _eventQueues= new Dictionary<GameEventType, GameEventQueue<GameEvent>>();~\\
\cellcolor{gray} &  & \verb~60~ & & \verb~~\\
\cellcolor{green} & 2 & \verb~61~ & & \verb~            if (eventTypeList != null) {~\\
\cellcolor{green} & 13 & \verb~62~ & & \verb~                foreach (var eventType in eventTypeList)~\\
\cellcolor{green} & 5 & \verb~63~ & & \verb~                {~\\
\cellcolor{green} & 5 & \verb~64~ & & \verb~                    _eventProcessors.Add(eventType, new List<IGameEventProcessor>());~\\
\cellcolor{green} & 5 & \verb~65~ & & \verb~                    _eventQueues.Add(eventType, new GameEventQueue<GameEvent>());~\\
\cellcolor{green} & 5 & \verb~66~ & & \verb~                }~\\
\cellcolor{green} & 1 & \verb~67~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~68~ & & \verb~~\\
\cellcolor{green} & 1 & \verb~69~ & & \verb~            _timedEventLists = new List<TimedGameEvent>[2] {~\\
\cellcolor{green} & 1 & \verb~70~ & & \verb~                new List<TimedGameEvent>(),~\\
\cellcolor{green} & 1 & \verb~71~ & & \verb~                new List<TimedGameEvent>()~\\
\cellcolor{green} & 1 & \verb~72~ & & \verb~            };~\\
\cellcolor{gray} &  & \verb~73~ & & \verb~~\\
\cellcolor{green} & 1 & \verb~74~ & & \verb~            _initialized = true;~\\
\cellcolor{green} & 1 & \verb~75~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~76~ & & \verb~~\\
\cellcolor{gray} &  & \verb~77~ & & \verb~        public void Subscribe(GameEventType eventType, IGameEventProcessor gameEventProcessor)~\\
\cellcolor{green} & 337 & \verb~78~ & & \verb~        {~\\
\cellcolor{orange} & 337 & \verb~79~ & & \verb~            if (gameEventProcessor == default(IGameEventProcessor))~\\
\cellcolor{red} & 0 & \verb~80~ & & \verb~                throw new ArgumentNullException("Parameter gameEventProcessor must not be null.");~\\
\cellcolor{gray} &  & \verb~81~ & & \verb~~\\
\cellcolor{gray} &  & \verb~82~ & & \verb~            try~\\
\cellcolor{green} & 337 & \verb~83~ & & \verb~            {~\\
\cellcolor{orange} & 337 & \verb~84~ & & \verb~                _eventProcessors?[eventType].Add(gameEventProcessor);~\\
\cellcolor{green} & 337 & \verb~85~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~86~ & & \verb~            catch (Exception e)~\\
\cellcolor{red} & 0 & \verb~87~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~88~ & & \verb~                throw new Exception($"Could not subscribe event processor. Check eventType! {e}");~\\
\cellcolor{gray} &  & \verb~89~ & & \verb~            }~\\
\cellcolor{green} & 337 & \verb~90~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~91~ & & \verb~~\\
\cellcolor{gray} &  & \verb~92~ & & \verb~        public void Unsubscribe(GameEventType eventType, IGameEventProcessor gameEventProcessor)~\\
\cellcolor{red} & 0 & \verb~93~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~94~ & & \verb~            if (gameEventProcessor == default(IGameEventProcessor))~\\
\cellcolor{red} & 0 & \verb~95~ & & \verb~                throw new ArgumentNullException("Parameter gameEventProcessor must not be null.");~\\
\cellcolor{gray} &  & \verb~96~ & & \verb~~\\
\cellcolor{gray} &  & \verb~97~ & & \verb~            try~\\
\cellcolor{red} & 0 & \verb~98~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~99~ & & \verb~                _eventProcessors?[eventType].Remove(gameEventProcessor);~\\
\cellcolor{red} & 0 & \verb~100~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~101~ & & \verb~            catch (Exception e)~\\
\cellcolor{red} & 0 & \verb~102~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~103~ & & \verb~                throw new Exception($"Could not unsubsribe event processor. Check eventType or processor is unregistered~\\
\cellcolor{gray} &  & \verb~104~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~105~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~106~ & & \verb~~\\
\cellcolor{gray} &  & \verb~107~ & & \verb~~\\
\cellcolor{gray} &  & \verb~108~ & & \verb~        #region TIMED_EVENTS~\\
\cellcolor{gray} &  & \verb~109~ & & \verb~~\\
\cellcolor{gray} &  & \verb~110~ & & \verb~        public void RegisterTimedEvent(GameEvent gameEvent, TimePeriod timePeriod)~\\
\cellcolor{green} & 6 & \verb~111~ & & \verb~        {~\\
\cellcolor{gray} &  & \verb~112~ & & \verb~            // do not insert already registered events:~\\
\cellcolor{orange} & 6 & \verb~113~ & & \verb~            if (gameEvent.Id != default(uint)) {~\\
\cellcolor{red} & 0 & \verb~114~ & & \verb~                if (_timedEventLists[_activeTimedEventList].Exists(e => e.GameEvent.Id == gameEvent.Id)) {~\\
\cellcolor{red} & 0 & \verb~115~ & & \verb~                    return;~\\
\cellcolor{gray} &  & \verb~116~ & & \verb~                }~\\
\cellcolor{red} & 0 & \verb~117~ & & \verb~            }~\\
\cellcolor{green} & 6 & \verb~118~ & & \verb~            _timedEventLists[_activeTimedEventList].Add(new TimedGameEvent(timePeriod, gameEvent));~\\
\cellcolor{green} & 6 & \verb~119~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~120~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~121~ & & \verb~        public void AddOrResetTimedEvent(GameEvent gameEvent, TimePeriod timePeriod) {~\\
\cellcolor{red} & 0 & \verb~122~ & & \verb~            if (gameEvent.Id != default(uint)) {~\\
\cellcolor{gray} &  & \verb~123~ & & \verb~                // search for an item which matches the Id of the specified event~\\
\cellcolor{red} & 0 & \verb~124~ & & \verb~                var search = _timedEventLists[_activeTimedEventList].FindIndex(e => e.GameEvent.Id == gameEvent.Id);~\\
\cellcolor{gray} &  & \verb~125~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~126~ & & \verb~                if (search >= 0) {~\\
\cellcolor{gray} &  & \verb~127~ & & \verb~                    // event with Id already exists, so we reset its time period~\\
\cellcolor{red} & 0 & \verb~128~ & & \verb~                    _timedEventLists[_activeTimedEventList][search] =~\\
\cellcolor{red} & 0 & \verb~129~ & & \verb~                        new TimedGameEvent(timePeriod, _timedEventLists[_activeTimedEventList][search].GameEvent);~\\
\cellcolor{red} & 0 & \verb~130~ & & \verb~                    return;~\\
\cellcolor{gray} &  & \verb~131~ & & \verb~                }~\\
\cellcolor{red} & 0 & \verb~132~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~133~ & & \verb~            // input event does not have an Id, or it has an Id but does not exist in list.~\\
\cellcolor{gray} &  & \verb~134~ & & \verb~            // In either case, we add it.~\\
\cellcolor{red} & 0 & \verb~135~ & & \verb~            _timedEventLists[_activeTimedEventList].Add(new TimedGameEvent(timePeriod, gameEvent));~\\
\cellcolor{red} & 0 & \verb~136~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~137~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~138~ & & \verb~        public bool CancelTimedEvent(uint eventId) {~\\
\cellcolor{red} & 0 & \verb~139~ & & \verb~            bool cancelled = false;~\\
\cellcolor{red} & 0 & \verb~140~ & & \verb~            _timedEventLists[_inactiveTimedEventList].Clear();~\\
\cellcolor{red} & 0 & \verb~141~ & & \verb~            foreach (var e in _timedEventLists[_activeTimedEventList]) {~\\
\cellcolor{red} & 0 & \verb~142~ & & \verb~                if (e.GameEvent.Id != eventId) {~\\
\cellcolor{red} & 0 & \verb~143~ & & \verb~                    _timedEventLists[_inactiveTimedEventList].Add(e);~\\
\cellcolor{red} & 0 & \verb~144~ & & \verb~                } else {~\\
\cellcolor{red} & 0 & \verb~145~ & & \verb~                    cancelled = true;~\\
\cellcolor{red} & 0 & \verb~146~ & & \verb~                }~\\
\cellcolor{red} & 0 & \verb~147~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~148~ & & \verb~~\\
\cellcolor{gray} &  & \verb~149~ & & \verb~            // swap the timed-event lists~\\
\cellcolor{red} & 0 & \verb~150~ & & \verb~            SwapTimedEventLists();~\\
\cellcolor{red} & 0 & \verb~151~ & & \verb~            return cancelled;~\\
\cellcolor{red} & 0 & \verb~152~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~153~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~154~ & & \verb~        public bool ResetTimedEvent(uint eventId, TimePeriod timePeriod) {~\\
\cellcolor{red} & 0 & \verb~155~ & & \verb~            var search = _timedEventLists[_activeTimedEventList].FindIndex(e => e.GameEvent.Id == eventId);~\\
\cellcolor{red} & 0 & \verb~156~ & & \verb~            if (search >= 0) {~\\
\cellcolor{red} & 0 & \verb~157~ & & \verb~                _timedEventLists[_activeTimedEventList][search] =~\\
\cellcolor{red} & 0 & \verb~158~ & & \verb~                    new TimedGameEvent(timePeriod, _timedEventLists[_activeTimedEventList][search].GameEvent);~\\
\cellcolor{red} & 0 & \verb~159~ & & \verb~                return true;~\\
\cellcolor{gray} &  & \verb~160~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~161~ & & \verb~            return false;~\\
\cellcolor{red} & 0 & \verb~162~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~163~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~164~ & & \verb~        public bool HasTimedEvent(uint eventId) {~\\
\cellcolor{red} & 0 & \verb~165~ & & \verb~            return _timedEventLists[_activeTimedEventList].FindIndex(e => e.GameEvent.Id == eventId) >= 0;~\\
\cellcolor{red} & 0 & \verb~166~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~167~ & & \verb~~\\
\cellcolor{gray} &  & \verb~168~ & & \verb~        #endregion // TIMED_EVENTS~\\
\cellcolor{gray} &  & \verb~169~ & & \verb~~\\
\cellcolor{gray} &  & \verb~170~ & & \verb~~\\
\cellcolor{gray} &  & \verb~171~ & & \verb~        public void RegisterEvent(GameEvent gameEvent)~\\
\cellcolor{green} & 90 & \verb~172~ & & \verb~        {~\\
\cellcolor{gray} &  & \verb~173~ & & \verb~            try~\\
\cellcolor{green} & 90 & \verb~174~ & & \verb~            {~\\
\cellcolor{orange} & 90 & \verb~175~ & & \verb~                _eventQueues?[gameEvent.EventType].Enqueue(gameEvent);~\\
\cellcolor{green} & 90 & \verb~176~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~177~ & & \verb~            catch (Exception e)~\\
\cellcolor{red} & 0 & \verb~178~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~179~ & & \verb~                throw new Exception($"Could not register event. Did you Initialize the EventBus with {e.Message}");~\\
\cellcolor{gray} &  & \verb~180~ & & \verb~            }~\\
\cellcolor{green} & 90 & \verb~181~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~182~ & & \verb~~\\
\cellcolor{green} & 41 & \verb~183~ & & \verb~        private void ProcessTimedEvents() {~\\
\cellcolor{green} & 41 & \verb~184~ & & \verb~            _timedEventLists[_inactiveTimedEventList].Clear();~\\
\cellcolor{gray} &  & \verb~185~ & & \verb~~\\
\cellcolor{green} & 41 & \verb~186~ & & \verb~            var currentTime = Timers.StaticTimer.GetElapsedMilliseconds();~\\
\cellcolor{green} & 723 & \verb~187~ & & \verb~            foreach (var e in _timedEventLists[_activeTimedEventList]) {~\\
\cellcolor{orange} & 200 & \verb~188~ & & \verb~                if (e.HasExpired(currentTime)) {~\\
\cellcolor{red} & 0 & \verb~189~ & & \verb~                    RegisterEvent(e.GameEvent);~\\
\cellcolor{green} & 200 & \verb~190~ & & \verb~                } else {~\\
\cellcolor{green} & 200 & \verb~191~ & & \verb~                    _timedEventLists[_inactiveTimedEventList].Add(e);~\\
\cellcolor{green} & 200 & \verb~192~ & & \verb~                }~\\
\cellcolor{green} & 200 & \verb~193~ & & \verb~            }~\\
\cellcolor{green} & 41 & \verb~194~ & & \verb~            SwapTimedEventLists();~\\
\cellcolor{green} & 41 & \verb~195~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~196~ & & \verb~~\\
\cellcolor{green} & 41 & \verb~197~ & & \verb~        public void ProcessEvents(IEnumerable<GameEventType> processOrder) {~\\
\cellcolor{orange} & 41 & \verb~198~ & & \verb~            if(processOrder==default(IEnumerable<GameEventType>)) {~\\
\cellcolor{red} & 0 & \verb~199~ & & \verb~                throw new ArgumentNullException();~\\
\cellcolor{gray} &  & \verb~200~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~201~ & & \verb~~\\
\cellcolor{green} & 41 & \verb~202~ & & \verb~            ProcessTimedEvents();~\\
\cellcolor{gray} &  & \verb~203~ & & \verb~~\\
\cellcolor{green} & 41 & \verb~204~ & & \verb~            Parallel.ForEach<GameEventType>(processOrder, new Action<GameEventType, ParallelLoopState>(~\\
\cellcolor{green} & 194 & \verb~205~ & & \verb~                (eventType, loopState) => {~\\
\cellcolor{green} & 388 & \verb~206~ & & \verb~                    if (_eventQueues != null) {~\\
\cellcolor{green} & 366 & \verb~207~ & & \verb~                        while (!_eventQueues[eventType].IsEmpty()) {~\\
\cellcolor{green} & 86 & \verb~208~ & & \verb~                            var currentEvent = _eventQueues[eventType].Dequeue();~\\
\cellcolor{green} & 86 & \verb~209~ & & \verb~                            if (currentEvent.To != default(IGameEventProcessor))~\\
\cellcolor{red} & 0 & \verb~210~ & & \verb~                            {~\\
\cellcolor{red} & 0 & \verb~211~ & & \verb~                                currentEvent.To.ProcessEvent(currentEvent);~\\
\cellcolor{red} & 0 & \verb~212~ & & \verb~                            }~\\
\cellcolor{green} & 86 & \verb~213~ & & \verb~                            else if (_eventProcessors != null)~\\
\cellcolor{green} & 86 & \verb~214~ & & \verb~                            {~\\
\cellcolor{green} & 6930 & \verb~215~ & & \verb~                                foreach (var eventProcessor in _eventProcessors[eventType]) {~\\
\cellcolor{green} & 2224 & \verb~216~ & & \verb~                                    eventProcessor.ProcessEvent(currentEvent);~\\
\cellcolor{green} & 41 & \verb~217~ & & \verb~~\\
\cellcolor{green} & 4448 & \verb~218~ & & \verb~                                    if (_breakExecution) loopState.Break();~\\
\cellcolor{green} & 2224 & \verb~219~ & & \verb~                                }~\\
\cellcolor{green} & 86 & \verb~220~ & & \verb~                            }~\\
\cellcolor{green} & 86 & \verb~221~ & & \verb~                        }~\\
\cellcolor{green} & 194 & \verb~222~ & & \verb~                    }~\\
\cellcolor{green} & 235 & \verb~223~ & & \verb~            }));~\\
\cellcolor{gray} &  & \verb~224~ & & \verb~~\\
\cellcolor{gray} &  & \verb~225~ & & \verb~            // semantic of Parallel.ForEach is it blocks until all parallel threads are finished~\\
\cellcolor{green} & 41 & \verb~226~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~227~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~228~ & & \verb~        public void ProcessEventsSequentially(IEnumerable<GameEventType> processOrder) {~\\
\cellcolor{red} & 0 & \verb~229~ & & \verb~            if(processOrder==default(IEnumerable<GameEventType>)) {~\\
\cellcolor{red} & 0 & \verb~230~ & & \verb~                throw new ArgumentNullException();~\\
\cellcolor{gray} &  & \verb~231~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~232~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~233~ & & \verb~            ProcessTimedEvents();~\\
\cellcolor{gray} &  & \verb~234~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~235~ & & \verb~            foreach(GameEventType eventType in processOrder) {~\\
\cellcolor{red} & 0 & \verb~236~ & & \verb~                if (_eventQueues != null) {~\\
\cellcolor{red} & 0 & \verb~237~ & & \verb~                    while (!_eventQueues[eventType].IsEmpty()) {~\\
\cellcolor{red} & 0 & \verb~238~ & & \verb~                        var currentEvent = _eventQueues[eventType].Dequeue();~\\
\cellcolor{red} & 0 & \verb~239~ & & \verb~                        if (currentEvent.To != default(IGameEventProcessor))~\\
\cellcolor{red} & 0 & \verb~240~ & & \verb~                        {~\\
\cellcolor{red} & 0 & \verb~241~ & & \verb~                            currentEvent.To.ProcessEvent(currentEvent);~\\
\cellcolor{red} & 0 & \verb~242~ & & \verb~                        }~\\
\cellcolor{red} & 0 & \verb~243~ & & \verb~                        else if (_eventProcessors != null) {~\\
\cellcolor{red} & 0 & \verb~244~ & & \verb~                            foreach (var eventProcessor in _eventProcessors[eventType]) {~\\
\cellcolor{red} & 0 & \verb~245~ & & \verb~                                eventProcessor.ProcessEvent(currentEvent);~\\
\cellcolor{red} & 0 & \verb~246~ & & \verb~                                if (_breakExecution) return;~\\
\cellcolor{red} & 0 & \verb~247~ & & \verb~                            }~\\
\cellcolor{red} & 0 & \verb~248~ & & \verb~                        }~\\
\cellcolor{red} & 0 & \verb~249~ & & \verb~                    }~\\
\cellcolor{red} & 0 & \verb~250~ & & \verb~                }~\\
\cellcolor{red} & 0 & \verb~251~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~252~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~253~ & & \verb~~\\
\cellcolor{gray} &  & \verb~254~ & & \verb~        public void ProcessEvents()~\\
\cellcolor{green} & 41 & \verb~255~ & & \verb~        {~\\
\cellcolor{green} & 82 & \verb~256~ & & \verb~            if (_eventQueues != null) ProcessEvents(_eventQueues.Keys);~\\
\cellcolor{green} & 41 & \verb~257~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~258~ & & \verb~~\\
\cellcolor{gray} &  & \verb~259~ & & \verb~        public void ProcessEventsSequentially()~\\
\cellcolor{red} & 0 & \verb~260~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~261~ & & \verb~            if (_eventQueues != null) ProcessEventsSequentially(_eventQueues.Keys);~\\
\cellcolor{red} & 0 & \verb~262~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~263~ & & \verb~~\\
\cellcolor{gray} &  & \verb~264~ & & \verb~        public void BreakProcessing()~\\
\cellcolor{green} & 1 & \verb~265~ & & \verb~        {~\\
\cellcolor{green} & 1 & \verb~266~ & & \verb~            _breakExecution = true;~\\
\cellcolor{green} & 1 & \verb~267~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~268~ & & \verb~~\\
\cellcolor{gray} &  & \verb~269~ & & \verb~        public void ResetBreakProcessing()~\\
\cellcolor{red} & 0 & \verb~270~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~271~ & & \verb~            _breakExecution = false;~\\
\cellcolor{red} & 0 & \verb~272~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~273~ & & \verb~~\\
\cellcolor{gray} &  & \verb~274~ & & \verb~        public void Flush()~\\
\cellcolor{green} & 1 & \verb~275~ & & \verb~        {~\\
\cellcolor{green} & 1 & \verb~276~ & & \verb~            BreakProcessing();~\\
\cellcolor{gray} &  & \verb~277~ & & \verb~~\\
\cellcolor{green} & 1 & \verb~278~ & & \verb~            if (_eventQueues == null) return;~\\
\cellcolor{green} & 13 & \verb~279~ & & \verb~            foreach (var eventType in _eventQueues.Keys)~\\
\cellcolor{green} & 5 & \verb~280~ & & \verb~            {~\\
\cellcolor{green} & 5 & \verb~281~ & & \verb~                _eventQueues[eventType].Flush();~\\
\cellcolor{green} & 5 & \verb~282~ & & \verb~            }~\\
\cellcolor{green} & 1 & \verb~283~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~284~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~285~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Events.GameEventQueue$<$T$>$}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Events.GameEventQueue$<$T$>$\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{ome/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Events/GameEventQueue.cs}\end{minipage} \\
\textbf{Covered lines:} & 17\\
\textbf{Uncovered lines:} & 13\\
\textbf{Coverable lines:} & 30\\
\textbf{Total lines:} & 97\\
\textbf{Line coverage:} & 56.6\% (17 of 30)\\
\textbf{Covered branches:} & 2\\
\textbf{Total branches:} & 2\\
\textbf{Branch coverage:} & 100\% (2 of 2)\\
\textbf{Covered methods:} & 5\\
\textbf{Total methods:} & 12\\
\textbf{Method coverage:} & 41.6\% (5 of 12)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor()} & 100\% & 1 & 100\%\\
\hline
\textbf{GetEnumerator()} & 100\% & 1 & 0\%\\
\hline
\textbf{System.Collections.I} & 100\% & 1 & 0\%\\
\hline
\textbf{CopyTo(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{System.Collections.I} & 100\% & 1 & 0\%\\
\hline
\textbf{get\_IsSynchronized()} & 100\% & 1 & 0\%\\
\hline
\textbf{get\_SyncRoot()} & 100\% & 1 & 0\%\\
\hline
\textbf{System.Collections.G} & 100\% & 1 & 0\%\\
\hline
\textbf{Enqueue(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{Dequeue()} & 100\% & 1 & 100\%\\
\hline
\textbf{IsEmpty()} & 100\% & 1 & 100\%\\
\hline
\textbf{Flush()} & 100\% & 2 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{ome/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Events/GameEventQueue.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using System.Collections.Concurrent;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~namespace DIKUArcade.Events~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~{~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~    /// Game event queue based on the concurrent queue implementation of the .NET framework~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    /// offering a simplified facade for the game event bus system.~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~    /// <typeparam name="TP">EventType data type.</typeparam>~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~    public class GameEventQueue<TP> : ICollection, IReadOnlyCollection<TP>~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~    {~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~        /// Core component of the event queue.~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 5 & \verb~18~ & & \verb~        private readonly ConcurrentQueue<TP> _queue= new ConcurrentQueue<TP>();~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~        /// Enumerator access for event queue.~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~        /// <returns>IEnumerator of concurrent queue.</returns>~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~        public IEnumerator<TP> GetEnumerator()~\\
\cellcolor{red} & 0 & \verb~25~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~26~ & & \verb~            return ((IEnumerable<TP>)_queue).GetEnumerator();~\\
\cellcolor{red} & 0 & \verb~27~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~        /// Generic enumerator access for event queue.~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~32~ & & \verb~        /// <returns>Generic IEnumerator of concurrent queue.</returns>~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~        IEnumerator IEnumerable.GetEnumerator()~\\
\cellcolor{red} & 0 & \verb~34~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~35~ & & \verb~            return GetEnumerator();~\\
\cellcolor{red} & 0 & \verb~36~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~~\\
\cellcolor{gray} &  & \verb~38~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~39~ & & \verb~        /// Copy semantics for fast array initialization and processing.~\\
\cellcolor{gray} &  & \verb~40~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~        /// <param name="array">Copy queue elements to array.</param>~\\
\cellcolor{gray} &  & \verb~42~ & & \verb~        /// <param name="index">Copy queue elements to which index position.</param>~\\
\cellcolor{gray} &  & \verb~43~ & & \verb~        public void CopyTo(Array array, int index)~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~45~ & & \verb~            _queue.CopyTo((TP[])array, index);~\\
\cellcolor{red} & 0 & \verb~46~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~47~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~48~ & & \verb~        int ICollection.Count => _queue.Count;~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~50~ & & \verb~        public bool IsSynchronized { get; }~\\
\cellcolor{red} & 0 & \verb~51~ & & \verb~        public object SyncRoot { get; }~\\
\cellcolor{gray} &  & \verb~52~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~53~ & & \verb~        int IReadOnlyCollection<TP>.Count => _queue.Count;~\\
\cellcolor{gray} &  & \verb~54~ & & \verb~~\\
\cellcolor{gray} &  & \verb~55~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~56~ & & \verb~        /// Enqueue a game event in the event queue.~\\
\cellcolor{gray} &  & \verb~57~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~58~ & & \verb~        /// <param name="gameEvent">Event which is enqueued.</param>~\\
\cellcolor{gray} &  & \verb~59~ & & \verb~        public void Enqueue(TP gameEvent)~\\
\cellcolor{green} & 90 & \verb~60~ & & \verb~        {~\\
\cellcolor{green} & 90 & \verb~61~ & & \verb~            _queue.Enqueue(gameEvent);~\\
\cellcolor{green} & 90 & \verb~62~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~63~ & & \verb~~\\
\cellcolor{gray} &  & \verb~64~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~65~ & & \verb~        /// Dequeues a game event from the event queue.~\\
\cellcolor{gray} &  & \verb~66~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~67~ & & \verb~        /// <returns>A game event from event queue.</returns>~\\
\cellcolor{gray} &  & \verb~68~ & & \verb~        public TP Dequeue()~\\
\cellcolor{green} & 86 & \verb~69~ & & \verb~        {~\\
\cellcolor{gray} &  & \verb~70~ & & \verb~            TP gameEvent;~\\
\cellcolor{green} & 86 & \verb~71~ & & \verb~            _queue.TryDequeue(out gameEvent);~\\
\cellcolor{green} & 86 & \verb~72~ & & \verb~            return gameEvent;~\\
\cellcolor{green} & 86 & \verb~73~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~74~ & & \verb~~\\
\cellcolor{gray} &  & \verb~75~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~76~ & & \verb~        /// Checks if the element queue is empty.~\\
\cellcolor{gray} &  & \verb~77~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~78~ & & \verb~        /// <returns>true if game event queue is empty, otherwise false.</returns>~\\
\cellcolor{gray} &  & \verb~79~ & & \verb~        public bool IsEmpty()~\\
\cellcolor{green} & 280 & \verb~80~ & & \verb~        {~\\
\cellcolor{green} & 280 & \verb~81~ & & \verb~            return _queue.IsEmpty;~\\
\cellcolor{green} & 280 & \verb~82~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~83~ & & \verb~~\\
\cellcolor{gray} &  & \verb~84~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~85~ & & \verb~        /// Flushes all elements stored in the event queue.~\\
\cellcolor{gray} &  & \verb~86~ & & \verb~        /// TODO: Method is slow and needs a rewrite.~\\
\cellcolor{gray} &  & \verb~87~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~88~ & & \verb~        public void Flush()~\\
\cellcolor{green} & 5 & \verb~89~ & & \verb~        {~\\
\cellcolor{gray} &  & \verb~90~ & & \verb~            TP gameEventDummy;~\\
\cellcolor{green} & 9 & \verb~91~ & & \verb~            while(!_queue.IsEmpty)~\\
\cellcolor{green} & 4 & \verb~92~ & & \verb~            {~\\
\cellcolor{green} & 4 & \verb~93~ & & \verb~                _queue.TryDequeue(out gameEventDummy);~\\
\cellcolor{green} & 4 & \verb~94~ & & \verb~            }~\\
\cellcolor{green} & 5 & \verb~95~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~96~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~97~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Events.Generic.GameEventBus$<$T$>$}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Events.Generic.GameEventBus$<$T$>$\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{dent/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Events/Generic/GameEventBusT.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 174\\
\textbf{Coverable lines:} & 174\\
\textbf{Total lines:} & 287\\
\textbf{Line coverage:} & 0\% (0 of 174)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 60\\
\textbf{Branch coverage:} & 0\% (0 of 60)\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 19\\
\textbf{Method coverage:} & 0\% (0 of 19)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor()} & 100\% & 1 & 0\%\\
\hline
\textbf{SwapTimedEventLists(} & 100\% & 1 & 0\%\\
\hline
\textbf{InitializeEventBus(.} & 0\% & 6 & 0\%\\
\hline
\textbf{Subscribe(...)} & 0\% & 4 & 0\%\\
\hline
\textbf{Unsubscribe(...)} & 0\% & 4 & 0\%\\
\hline
\textbf{RegisterTimedEvent(.} & 0\% & 4 & 0\%\\
\hline
\textbf{AddOrResetTimedEvent} & 0\% & 4 & 0\%\\
\hline
\textbf{CancelTimedEvent(...} & 0\% & 4 & 0\%\\
\hline
\textbf{ResetTimedEvent(...)} & 0\% & 2 & 0\%\\
\hline
\textbf{HasTimedEvent(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{RegisterEvent(...)} & 0\% & 2 & 0\%\\
\hline
\textbf{ProcessTimedEvents()} & 0\% & 4 & 0\%\\
\hline
\textbf{ProcessEvents(...)} & 0\% & 2 & 0\%\\
\hline
\textbf{ProcessEventsSequent} & 0\% & 16 & 0\%\\
\hline
\textbf{ProcessEvents()} & 0\% & 2 & 0\%\\
\hline
\textbf{ProcessEventsSequent} & 0\% & 2 & 0\%\\
\hline
\textbf{BreakProcessing()} & 100\% & 1 & 0\%\\
\hline
\textbf{ResetBreakProcessing} & 100\% & 1 & 0\%\\
\hline
\textbf{Flush()} & 0\% & 4 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{dent/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Events/Generic/GameEventBusT.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using System.Threading.Tasks;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using DIKUArcade.Timers;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~namespace DIKUArcade.Events.Generic~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~{~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~    /// Generic version of the DIKUArcade.Events.GameEventBus class, which uses the generic type EventT~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    /// as the underlying event type enum.~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    /// GameEventBus is the core module for processing events in the DIKUArcade game engine. Modules can register events~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~    /// add them to the queues. Events are distinguished by event types to improve processing performance. Event process~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~    /// can register/subscribe themself to receive events of a certain event type. For a single event, all processors ar~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~    /// called with this event (broadcast semantic).~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~    /// <typeparam name="EventT">Enumeration type representing type of game events.</typeparam>~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~    public class GameEventBus<EventT> : IGameEventBus<EventT>, ITimedGameEventBus<EventT>,~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~        IGameEventBusController<EventT> where EventT : System.Enum~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~    {~\\
\cellcolor{red} & 0 & \verb~20~ & & \verb~        private bool _initialized = false;~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~        /// Dictionary of registered event processors for a given game event type.~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~        private Dictionary<EventT, ICollection<IGameEventProcessor<EventT>>> _eventProcessors;~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~        /// Dictionary of game event queues for different game event types.~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~        private Dictionary<EventT, GameEventQueue<GameEvent<EventT>>> _eventQueues;~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~        /// Stops processing the pipeline, e.g. needed due real-time constraints.~\\
\cellcolor{gray} &  & \verb~32~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~33~ & & \verb~        private bool _breakExecution = false;~\\
\cellcolor{gray} &  & \verb~34~ & & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~        /// List of events which must be processed after a specified time interval has passed.~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~        /// We use a double-buffered system.~\\
\cellcolor{gray} &  & \verb~38~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~39~ & & \verb~        private List<TimedGameEvent<EventT>>[] _timedEventLists;~\\
\cellcolor{red} & 0 & \verb~40~ & & \verb~        private int _activeTimedEventList = 0;~\\
\cellcolor{red} & 0 & \verb~41~ & & \verb~        private int _inactiveTimedEventList = 1;~\\
\cellcolor{gray} &  & \verb~42~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~43~ & & \verb~        private void SwapTimedEventLists() {~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~            _activeTimedEventList = (_activeTimedEventList + 1) % 2;~\\
\cellcolor{red} & 0 & \verb~45~ & & \verb~            _inactiveTimedEventList = (_inactiveTimedEventList + 1) % 2;~\\
\cellcolor{red} & 0 & \verb~46~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~47~ & & \verb~~\\
\cellcolor{gray} &  & \verb~48~ & & \verb~~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~50~ & & \verb~        /// Initialized the event bus to handle the specified event types.~\\
\cellcolor{gray} &  & \verb~51~ & & \verb~        /// An exception is thrown if called on an already initialized GameEventBus.~\\
\cellcolor{gray} &  & \verb~52~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~53~ & & \verb~        /// <exception cref="InvalidOperationException"></exception>~\\
\cellcolor{gray} &  & \verb~54~ & & \verb~        public void InitializeEventBus(ICollection<EventT> eventTypeList)~\\
\cellcolor{red} & 0 & \verb~55~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~56~ & & \verb~            if (_initialized) {~\\
\cellcolor{red} & 0 & \verb~57~ & & \verb~                throw new InvalidOperationException("GameEventBus is already initialized!");~\\
\cellcolor{gray} &  & \verb~58~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~59~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~60~ & & \verb~            _eventProcessors= new Dictionary<EventT, ICollection<IGameEventProcessor<EventT>>>();~\\
\cellcolor{red} & 0 & \verb~61~ & & \verb~            _eventQueues= new Dictionary<EventT, GameEventQueue<GameEvent<EventT>>>();~\\
\cellcolor{gray} &  & \verb~62~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~63~ & & \verb~            if (eventTypeList != null) {~\\
\cellcolor{red} & 0 & \verb~64~ & & \verb~                foreach (var eventType in eventTypeList)~\\
\cellcolor{red} & 0 & \verb~65~ & & \verb~                {~\\
\cellcolor{red} & 0 & \verb~66~ & & \verb~                    _eventProcessors.Add(eventType, new List<IGameEventProcessor<EventT>>());~\\
\cellcolor{red} & 0 & \verb~67~ & & \verb~                    _eventQueues.Add(eventType, new GameEventQueue<GameEvent<EventT>>());~\\
\cellcolor{red} & 0 & \verb~68~ & & \verb~                }~\\
\cellcolor{red} & 0 & \verb~69~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~70~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~71~ & & \verb~            _timedEventLists = new List<TimedGameEvent<EventT>>[2] {~\\
\cellcolor{red} & 0 & \verb~72~ & & \verb~                new List<TimedGameEvent<EventT>>(),~\\
\cellcolor{red} & 0 & \verb~73~ & & \verb~                new List<TimedGameEvent<EventT>>()~\\
\cellcolor{red} & 0 & \verb~74~ & & \verb~            };~\\
\cellcolor{gray} &  & \verb~75~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~76~ & & \verb~            _initialized = true;~\\
\cellcolor{red} & 0 & \verb~77~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~78~ & & \verb~~\\
\cellcolor{gray} &  & \verb~79~ & & \verb~        public void Subscribe(EventT eventType, IGameEventProcessor<EventT> gameEventProcessor)~\\
\cellcolor{red} & 0 & \verb~80~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~81~ & & \verb~            if (gameEventProcessor == default(IGameEventProcessor<EventT>))~\\
\cellcolor{red} & 0 & \verb~82~ & & \verb~                throw new ArgumentNullException("Parameter gameEventProcessor must not be null.");~\\
\cellcolor{gray} &  & \verb~83~ & & \verb~~\\
\cellcolor{gray} &  & \verb~84~ & & \verb~            try~\\
\cellcolor{red} & 0 & \verb~85~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~86~ & & \verb~                _eventProcessors?[eventType].Add(gameEventProcessor);~\\
\cellcolor{red} & 0 & \verb~87~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~88~ & & \verb~            catch (Exception e)~\\
\cellcolor{red} & 0 & \verb~89~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~90~ & & \verb~                throw new Exception($"Could not subscribe event processor. Check eventType! {e}");~\\
\cellcolor{gray} &  & \verb~91~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~92~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~93~ & & \verb~~\\
\cellcolor{gray} &  & \verb~94~ & & \verb~        public void Unsubscribe(EventT eventType, IGameEventProcessor<EventT> gameEventProcessor)~\\
\cellcolor{red} & 0 & \verb~95~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~96~ & & \verb~            if (gameEventProcessor == default(IGameEventProcessor<EventT>))~\\
\cellcolor{red} & 0 & \verb~97~ & & \verb~                throw new ArgumentNullException("Parameter gameEventProcessor must not be null.");~\\
\cellcolor{gray} &  & \verb~98~ & & \verb~~\\
\cellcolor{gray} &  & \verb~99~ & & \verb~            try~\\
\cellcolor{red} & 0 & \verb~100~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~101~ & & \verb~                _eventProcessors?[eventType].Remove(gameEventProcessor);~\\
\cellcolor{red} & 0 & \verb~102~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~103~ & & \verb~            catch (Exception e)~\\
\cellcolor{red} & 0 & \verb~104~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~105~ & & \verb~                throw new Exception($"Could not unsubsribe event processor. Check eventType or processor is unregistered~\\
\cellcolor{gray} &  & \verb~106~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~107~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~108~ & & \verb~~\\
\cellcolor{gray} &  & \verb~109~ & & \verb~~\\
\cellcolor{gray} &  & \verb~110~ & & \verb~        #region TIMED_EVENTS~\\
\cellcolor{gray} &  & \verb~111~ & & \verb~~\\
\cellcolor{gray} &  & \verb~112~ & & \verb~        public void RegisterTimedEvent(GameEvent<EventT> gameEvent, TimePeriod timePeriod)~\\
\cellcolor{red} & 0 & \verb~113~ & & \verb~        {~\\
\cellcolor{gray} &  & \verb~114~ & & \verb~            // do not insert already registered events:~\\
\cellcolor{red} & 0 & \verb~115~ & & \verb~            if (gameEvent.Id != default(uint)) {~\\
\cellcolor{red} & 0 & \verb~116~ & & \verb~                if (_timedEventLists[_activeTimedEventList].Exists(e => e.GameEvent.Id == gameEvent.Id)) {~\\
\cellcolor{red} & 0 & \verb~117~ & & \verb~                    return;~\\
\cellcolor{gray} &  & \verb~118~ & & \verb~                }~\\
\cellcolor{red} & 0 & \verb~119~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~120~ & & \verb~            _timedEventLists[_activeTimedEventList].Add(new TimedGameEvent<EventT>(timePeriod, gameEvent));~\\
\cellcolor{red} & 0 & \verb~121~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~122~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~123~ & & \verb~        public void AddOrResetTimedEvent(GameEvent<EventT> gameEvent, TimePeriod timePeriod) {~\\
\cellcolor{red} & 0 & \verb~124~ & & \verb~            if (gameEvent.Id != default(uint)) {~\\
\cellcolor{gray} &  & \verb~125~ & & \verb~                // search for an item which matches the Id of the specified event~\\
\cellcolor{red} & 0 & \verb~126~ & & \verb~                var search = _timedEventLists[_activeTimedEventList].FindIndex(e => e.GameEvent.Id == gameEvent.Id);~\\
\cellcolor{gray} &  & \verb~127~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~128~ & & \verb~                if (search >= 0) {~\\
\cellcolor{gray} &  & \verb~129~ & & \verb~                    // event with Id already exists, so we reset its time period~\\
\cellcolor{red} & 0 & \verb~130~ & & \verb~                    _timedEventLists[_activeTimedEventList][search] =~\\
\cellcolor{red} & 0 & \verb~131~ & & \verb~                        new TimedGameEvent<EventT>(timePeriod, _timedEventLists[_activeTimedEventList][search].GameEvent~\\
\cellcolor{red} & 0 & \verb~132~ & & \verb~                    return;~\\
\cellcolor{gray} &  & \verb~133~ & & \verb~                }~\\
\cellcolor{red} & 0 & \verb~134~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~135~ & & \verb~            // input event does not have an Id, or it has an Id but does not exist in list.~\\
\cellcolor{gray} &  & \verb~136~ & & \verb~            // In either case, we add it.~\\
\cellcolor{red} & 0 & \verb~137~ & & \verb~            _timedEventLists[_activeTimedEventList].Add(new TimedGameEvent<EventT>(timePeriod, gameEvent));~\\
\cellcolor{red} & 0 & \verb~138~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~139~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~140~ & & \verb~        public bool CancelTimedEvent(uint eventId) {~\\
\cellcolor{red} & 0 & \verb~141~ & & \verb~            bool cancelled = false;~\\
\cellcolor{red} & 0 & \verb~142~ & & \verb~            _timedEventLists[_inactiveTimedEventList].Clear();~\\
\cellcolor{red} & 0 & \verb~143~ & & \verb~            foreach (var e in _timedEventLists[_activeTimedEventList]) {~\\
\cellcolor{red} & 0 & \verb~144~ & & \verb~                if (e.GameEvent.Id != eventId) {~\\
\cellcolor{red} & 0 & \verb~145~ & & \verb~                    _timedEventLists[_inactiveTimedEventList].Add(e);~\\
\cellcolor{red} & 0 & \verb~146~ & & \verb~                } else {~\\
\cellcolor{red} & 0 & \verb~147~ & & \verb~                    cancelled = true;~\\
\cellcolor{red} & 0 & \verb~148~ & & \verb~                }~\\
\cellcolor{red} & 0 & \verb~149~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~150~ & & \verb~~\\
\cellcolor{gray} &  & \verb~151~ & & \verb~            // swap the timed-event lists~\\
\cellcolor{red} & 0 & \verb~152~ & & \verb~            SwapTimedEventLists();~\\
\cellcolor{red} & 0 & \verb~153~ & & \verb~            return cancelled;~\\
\cellcolor{red} & 0 & \verb~154~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~155~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~156~ & & \verb~        public bool ResetTimedEvent(uint eventId, TimePeriod timePeriod) {~\\
\cellcolor{red} & 0 & \verb~157~ & & \verb~            var search = _timedEventLists[_activeTimedEventList].FindIndex(e => e.GameEvent.Id == eventId);~\\
\cellcolor{red} & 0 & \verb~158~ & & \verb~            if (search >= 0) {~\\
\cellcolor{red} & 0 & \verb~159~ & & \verb~                _timedEventLists[_activeTimedEventList][search] =~\\
\cellcolor{red} & 0 & \verb~160~ & & \verb~                    new TimedGameEvent<EventT>(timePeriod, _timedEventLists[_activeTimedEventList][search].GameEvent);~\\
\cellcolor{red} & 0 & \verb~161~ & & \verb~                return true;~\\
\cellcolor{gray} &  & \verb~162~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~163~ & & \verb~            return false;~\\
\cellcolor{red} & 0 & \verb~164~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~165~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~166~ & & \verb~        public bool HasTimedEvent(uint eventId) {~\\
\cellcolor{red} & 0 & \verb~167~ & & \verb~            return _timedEventLists[_activeTimedEventList].FindIndex(e => e.GameEvent.Id == eventId) >= 0;~\\
\cellcolor{red} & 0 & \verb~168~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~169~ & & \verb~~\\
\cellcolor{gray} &  & \verb~170~ & & \verb~        #endregion // TIMED_EVENTS~\\
\cellcolor{gray} &  & \verb~171~ & & \verb~~\\
\cellcolor{gray} &  & \verb~172~ & & \verb~~\\
\cellcolor{gray} &  & \verb~173~ & & \verb~        public void RegisterEvent(GameEvent<EventT> gameEvent)~\\
\cellcolor{red} & 0 & \verb~174~ & & \verb~        {~\\
\cellcolor{gray} &  & \verb~175~ & & \verb~            try~\\
\cellcolor{red} & 0 & \verb~176~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~177~ & & \verb~                _eventQueues?[gameEvent.EventType].Enqueue(gameEvent);~\\
\cellcolor{red} & 0 & \verb~178~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~179~ & & \verb~            catch (Exception e)~\\
\cellcolor{red} & 0 & \verb~180~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~181~ & & \verb~                throw new Exception($"Could not register event. Did you Initialize the EventBus with {e.Message}");~\\
\cellcolor{gray} &  & \verb~182~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~183~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~184~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~185~ & & \verb~        private void ProcessTimedEvents() {~\\
\cellcolor{red} & 0 & \verb~186~ & & \verb~            _timedEventLists[_inactiveTimedEventList].Clear();~\\
\cellcolor{gray} &  & \verb~187~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~188~ & & \verb~            var currentTime = Timers.StaticTimer.GetElapsedMilliseconds();~\\
\cellcolor{red} & 0 & \verb~189~ & & \verb~            foreach (var e in _timedEventLists[_activeTimedEventList]) {~\\
\cellcolor{red} & 0 & \verb~190~ & & \verb~                if (e.HasExpired(currentTime)) {~\\
\cellcolor{red} & 0 & \verb~191~ & & \verb~                    RegisterEvent(e.GameEvent);~\\
\cellcolor{red} & 0 & \verb~192~ & & \verb~                } else {~\\
\cellcolor{red} & 0 & \verb~193~ & & \verb~                    _timedEventLists[_inactiveTimedEventList].Add(e);~\\
\cellcolor{red} & 0 & \verb~194~ & & \verb~                }~\\
\cellcolor{red} & 0 & \verb~195~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~196~ & & \verb~            SwapTimedEventLists();~\\
\cellcolor{red} & 0 & \verb~197~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~198~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~199~ & & \verb~        public void ProcessEvents(IEnumerable<EventT> processOrder) {~\\
\cellcolor{red} & 0 & \verb~200~ & & \verb~            if(processOrder==default(IEnumerable<EventT>)) {~\\
\cellcolor{red} & 0 & \verb~201~ & & \verb~                throw new ArgumentNullException();~\\
\cellcolor{gray} &  & \verb~202~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~203~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~204~ & & \verb~            ProcessTimedEvents();~\\
\cellcolor{gray} &  & \verb~205~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~206~ & & \verb~            Parallel.ForEach<EventT>(processOrder, new Action<EventT, ParallelLoopState>(~\\
\cellcolor{red} & 0 & \verb~207~ & & \verb~                (eventType, loopState) => {~\\
\cellcolor{red} & 0 & \verb~208~ & & \verb~                    if (_eventQueues != null) {~\\
\cellcolor{red} & 0 & \verb~209~ & & \verb~                        while (!_eventQueues[eventType].IsEmpty()) {~\\
\cellcolor{red} & 0 & \verb~210~ & & \verb~                            var currentEvent = _eventQueues[eventType].Dequeue();~\\
\cellcolor{red} & 0 & \verb~211~ & & \verb~                            if (currentEvent.To != default(IGameEventProcessor<EventT>))~\\
\cellcolor{red} & 0 & \verb~212~ & & \verb~                            {~\\
\cellcolor{red} & 0 & \verb~213~ & & \verb~                                currentEvent.To.ProcessEvent(currentEvent);~\\
\cellcolor{red} & 0 & \verb~214~ & & \verb~                            }~\\
\cellcolor{red} & 0 & \verb~215~ & & \verb~                            else if (_eventProcessors != null)~\\
\cellcolor{red} & 0 & \verb~216~ & & \verb~                            {~\\
\cellcolor{red} & 0 & \verb~217~ & & \verb~                                foreach (var eventProcessor in _eventProcessors[eventType]) {~\\
\cellcolor{red} & 0 & \verb~218~ & & \verb~                                    eventProcessor.ProcessEvent(currentEvent);~\\
\cellcolor{red} & 0 & \verb~219~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~220~ & & \verb~                                    if (_breakExecution) loopState.Break();~\\
\cellcolor{red} & 0 & \verb~221~ & & \verb~                                }~\\
\cellcolor{red} & 0 & \verb~222~ & & \verb~                            }~\\
\cellcolor{red} & 0 & \verb~223~ & & \verb~                        }~\\
\cellcolor{red} & 0 & \verb~224~ & & \verb~                    }~\\
\cellcolor{red} & 0 & \verb~225~ & & \verb~            }));~\\
\cellcolor{gray} &  & \verb~226~ & & \verb~~\\
\cellcolor{gray} &  & \verb~227~ & & \verb~            // semantic of Parallel.ForEach is it blocks until all parallel threads are finished~\\
\cellcolor{red} & 0 & \verb~228~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~229~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~230~ & & \verb~        public void ProcessEventsSequentially(IEnumerable<EventT> processOrder) {~\\
\cellcolor{red} & 0 & \verb~231~ & & \verb~            if(processOrder==default(IEnumerable<EventT>)) {~\\
\cellcolor{red} & 0 & \verb~232~ & & \verb~                throw new ArgumentNullException();~\\
\cellcolor{gray} &  & \verb~233~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~234~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~235~ & & \verb~            ProcessTimedEvents();~\\
\cellcolor{gray} &  & \verb~236~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~237~ & & \verb~            foreach(EventT eventType in processOrder) {~\\
\cellcolor{red} & 0 & \verb~238~ & & \verb~                if (_eventQueues != null) {~\\
\cellcolor{red} & 0 & \verb~239~ & & \verb~                    while (!_eventQueues[eventType].IsEmpty()) {~\\
\cellcolor{red} & 0 & \verb~240~ & & \verb~                        var currentEvent = _eventQueues[eventType].Dequeue();~\\
\cellcolor{red} & 0 & \verb~241~ & & \verb~                        if (currentEvent.To != default(IGameEventProcessor<EventT>))~\\
\cellcolor{red} & 0 & \verb~242~ & & \verb~                        {~\\
\cellcolor{red} & 0 & \verb~243~ & & \verb~                            currentEvent.To.ProcessEvent(currentEvent);~\\
\cellcolor{red} & 0 & \verb~244~ & & \verb~                        }~\\
\cellcolor{red} & 0 & \verb~245~ & & \verb~                        else if (_eventProcessors != null) {~\\
\cellcolor{red} & 0 & \verb~246~ & & \verb~                            foreach (var eventProcessor in _eventProcessors[eventType]) {~\\
\cellcolor{red} & 0 & \verb~247~ & & \verb~                                eventProcessor.ProcessEvent(currentEvent);~\\
\cellcolor{red} & 0 & \verb~248~ & & \verb~                                if (_breakExecution) return;~\\
\cellcolor{red} & 0 & \verb~249~ & & \verb~                            }~\\
\cellcolor{red} & 0 & \verb~250~ & & \verb~                        }~\\
\cellcolor{red} & 0 & \verb~251~ & & \verb~                    }~\\
\cellcolor{red} & 0 & \verb~252~ & & \verb~                }~\\
\cellcolor{red} & 0 & \verb~253~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~254~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~255~ & & \verb~~\\
\cellcolor{gray} &  & \verb~256~ & & \verb~        public void ProcessEvents()~\\
\cellcolor{red} & 0 & \verb~257~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~258~ & & \verb~            if (_eventQueues != null) ProcessEvents(_eventQueues.Keys);~\\
\cellcolor{red} & 0 & \verb~259~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~260~ & & \verb~~\\
\cellcolor{gray} &  & \verb~261~ & & \verb~        public void ProcessEventsSequentially()~\\
\cellcolor{red} & 0 & \verb~262~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~263~ & & \verb~            if (_eventQueues != null) ProcessEventsSequentially(_eventQueues.Keys);~\\
\cellcolor{red} & 0 & \verb~264~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~265~ & & \verb~~\\
\cellcolor{gray} &  & \verb~266~ & & \verb~        public void BreakProcessing()~\\
\cellcolor{red} & 0 & \verb~267~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~268~ & & \verb~            _breakExecution = true;~\\
\cellcolor{red} & 0 & \verb~269~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~270~ & & \verb~~\\
\cellcolor{gray} &  & \verb~271~ & & \verb~        public void ResetBreakProcessing()~\\
\cellcolor{red} & 0 & \verb~272~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~273~ & & \verb~            _breakExecution = false;~\\
\cellcolor{red} & 0 & \verb~274~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~275~ & & \verb~~\\
\cellcolor{gray} &  & \verb~276~ & & \verb~        public void Flush()~\\
\cellcolor{red} & 0 & \verb~277~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~278~ & & \verb~            BreakProcessing();~\\
\cellcolor{gray} &  & \verb~279~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~280~ & & \verb~            if (_eventQueues == null) return;~\\
\cellcolor{red} & 0 & \verb~281~ & & \verb~            foreach (var eventType in _eventQueues.Keys)~\\
\cellcolor{red} & 0 & \verb~282~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~283~ & & \verb~                _eventQueues[eventType].Flush();~\\
\cellcolor{red} & 0 & \verb~284~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~285~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~286~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~287~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Events.Generic.TimedGameEvent$<$T$>$}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Events.Generic.TimedGameEvent$<$T$>$\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{nt/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Events/Generic/TimedGameEventT.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 13\\
\textbf{Coverable lines:} & 13\\
\textbf{Total lines:} & 46\\
\textbf{Line coverage:} & 0\% (0 of 13)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 4\\
\textbf{Method coverage:} & 0\% (0 of 4)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{get\_GameEvent()} & 100\% & 1 & 0\%\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{HasExpired()} & 100\% & 1 & 0\%\\
\hline
\textbf{HasExpired(...)} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{nt/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Events/Generic/TimedGameEventT.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Timers;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~namespace DIKUArcade.Events.Generic~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~{~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~    /// Generic version of the DIKUArcade.Events.TimedGameEvent struct.~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~    /// Represents a GameEvent together with an expiration time.~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    /// When a TimedGameEvent has expired it is ready for processing by a GameEventBus.~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    /// <typeparam name="EventT">Enumeration type representing type of game events.</typeparam>~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    public struct TimedGameEvent<EventT> where EventT : System.Enum~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~    {~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~        /// The GameEvent<EventT> which this object wraps around.~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~16~ & & \verb~        public GameEvent<EventT> GameEvent { get; private set; }~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~        private readonly TimePeriod timeSpan;~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~        private readonly long timeOfCreation;~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~21~ & & \verb~        public TimedGameEvent(TimePeriod timeSpan, GameEvent<EventT> gameEvent) {~\\
\cellcolor{red} & 0 & \verb~22~ & & \verb~            this.timeSpan = timeSpan;~\\
\cellcolor{red} & 0 & \verb~23~ & & \verb~            GameEvent = gameEvent;~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~25~ & & \verb~            timeOfCreation = StaticTimer.GetElapsedMilliseconds();~\\
\cellcolor{red} & 0 & \verb~26~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~        /// Measure time and check if the event is ready for processing.~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~31~ & & \verb~        public bool HasExpired() {~\\
\cellcolor{red} & 0 & \verb~32~ & & \verb~            var now = StaticTimer.GetElapsedMilliseconds();~\\
\cellcolor{red} & 0 & \verb~33~ & & \verb~            return (now - timeOfCreation) > timeSpan.ToMilliseconds();~\\
\cellcolor{red} & 0 & \verb~34~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~        /// Measure time and check if the event is ready for processing,~\\
\cellcolor{gray} &  & \verb~38~ & & \verb~        /// but where current timestamp is provided in milliseconds.~\\
\cellcolor{gray} &  & \verb~39~ & & \verb~        /// This is useful if checking multiple TimedEvents in sequence without~\\
\cellcolor{gray} &  & \verb~40~ & & \verb~        /// having to get current timestamp for each one.~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~42~ & & \verb~        public bool HasExpired(long currentTime) {~\\
\cellcolor{red} & 0 & \verb~43~ & & \verb~            return (currentTime - timeOfCreation) > timeSpan.ToMilliseconds();~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~45~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~46~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Events.TimedGameEvent}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Events.TimedGameEvent\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{ome/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Events/TimedGameEvent.cs}\end{minipage} \\
\textbf{Covered lines:} & 9\\
\textbf{Uncovered lines:} & 4\\
\textbf{Coverable lines:} & 13\\
\textbf{Total lines:} & 43\\
\textbf{Line coverage:} & 69.2\% (9 of 13)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 3\\
\textbf{Total methods:} & 4\\
\textbf{Method coverage:} & 75\% (3 of 4)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{get\_GameEvent()} & 100\% & 1 & 100\%\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{HasExpired()} & 100\% & 1 & 0\%\\
\hline
\textbf{HasExpired(...)} & 100\% & 1 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{ome/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Events/TimedGameEvent.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Timers;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~namespace DIKUArcade.Events {~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~    /// Represents a GameEvent together with an expiration time.~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~    /// When a TimedGameEvent has expired it is ready for processing by a GameEventBus.~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    public struct TimedGameEvent~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~    {~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~        /// The GameEvent which this object wraps around.~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 6 & \verb~13~ & & \verb~        public GameEvent GameEvent { get; private set; }~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~        private readonly TimePeriod timeSpan;~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~        private readonly long timeOfCreation;~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~~\\
\cellcolor{green} & 6 & \verb~18~ & & \verb~        public TimedGameEvent(TimePeriod timeSpan, GameEvent gameEvent) {~\\
\cellcolor{green} & 6 & \verb~19~ & & \verb~            this.timeSpan = timeSpan;~\\
\cellcolor{green} & 6 & \verb~20~ & & \verb~            GameEvent = gameEvent;~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~~\\
\cellcolor{green} & 6 & \verb~22~ & & \verb~            timeOfCreation = StaticTimer.GetElapsedMilliseconds();~\\
\cellcolor{green} & 6 & \verb~23~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~        /// Measure time and check if the event is ready for processing.~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~28~ & & \verb~        public bool HasExpired() {~\\
\cellcolor{red} & 0 & \verb~29~ & & \verb~            var now = StaticTimer.GetElapsedMilliseconds();~\\
\cellcolor{red} & 0 & \verb~30~ & & \verb~            return (now - timeOfCreation) > timeSpan.ToMilliseconds();~\\
\cellcolor{red} & 0 & \verb~31~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~32~ & & \verb~~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~34~ & & \verb~        /// Measure time and check if the event is ready for processing,~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~        /// but where current timestamp is provided in milliseconds.~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~        /// This is useful if checking multiple TimedEvents in sequence without~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~        /// having to get current timestamp for each one.~\\
\cellcolor{gray} &  & \verb~38~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 200 & \verb~39~ & & \verb~        public bool HasExpired(long currentTimeMs) {~\\
\cellcolor{green} & 200 & \verb~40~ & & \verb~            return (currentTimeMs - timeOfCreation) > timeSpan.ToMilliseconds();~\\
\cellcolor{green} & 200 & \verb~41~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~42~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~43~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Graphics.Animation}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Graphics.Animation\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Graphics/Animation.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 15\\
\textbf{Coverable lines:} & 15\\
\textbf{Total lines:} & 44\\
\textbf{Line coverage:} & 0\% (0 of 15)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 7\\
\textbf{Method coverage:} & 0\% (0 of 7)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{get\_Duration()} & 100\% & 1 & 0\%\\
\hline
\textbf{get\_Shape()} & 100\% & 1 & 0\%\\
\hline
\textbf{get\_Stride()} & 100\% & 1 & 0\%\\
\hline
\textbf{.ctor()} & 100\% & 1 & 0\%\\
\hline
\textbf{IsActive()} & 100\% & 1 & 0\%\\
\hline
\textbf{RenderAnimation()} & 100\% & 1 & 0\%\\
\hline
\textbf{ResetAnimation()} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Graphics/Animation.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Timers;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~namespace DIKUArcade.Graphics {~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~    public class Animation {~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~        /// Duration of this animation, in milliseconds~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~10~ & & \verb~        public int Duration { get; set; }~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~        /// Position and Extent of this animation~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~15~ & & \verb~        public StationaryShape Shape { get; set; }~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~        /// ImageStride used for animation~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~20~ & & \verb~        public ImageStride Stride { get; set; }~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~        private double timeOfCreation;~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~24~ & & \verb~        public Animation() {~\\
\cellcolor{red} & 0 & \verb~25~ & & \verb~            timeOfCreation = StaticTimer.GetElapsedMilliseconds();~\\
\cellcolor{red} & 0 & \verb~26~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~        /// The animation is still considered active if the specified duration~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~        /// in milliseconds has not yet passed.~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~32~ & & \verb~        public bool IsActive() {~\\
\cellcolor{red} & 0 & \verb~33~ & & \verb~            return timeOfCreation + Duration > StaticTimer.GetElapsedMilliseconds();~\\
\cellcolor{red} & 0 & \verb~34~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~36~ & & \verb~        public void RenderAnimation() {~\\
\cellcolor{red} & 0 & \verb~37~ & & \verb~            Stride.Render(Shape);~\\
\cellcolor{red} & 0 & \verb~38~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~39~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~40~ & & \verb~        public void ResetAnimation() {~\\
\cellcolor{red} & 0 & \verb~41~ & & \verb~            timeOfCreation = StaticTimer.GetElapsedMilliseconds();~\\
\cellcolor{red} & 0 & \verb~42~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~43~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~44~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Graphics.AnimationContainer}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Graphics.AnimationContainer\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{udent/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Graphics/AnimationContainer.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 40\\
\textbf{Coverable lines:} & 40\\
\textbf{Total lines:} & 72\\
\textbf{Line coverage:} & 0\% (0 of 40)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 14\\
\textbf{Branch coverage:} & 0\% (0 of 14)\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 5\\
\textbf{Method coverage:} & 0\% (0 of 5)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{get\_Occupied()} & 100\% & 1 & 0\%\\
\hline
\textbf{.ctor(...)} & 0\% & 2 & 0\%\\
\hline
\textbf{ResetContainer()} & 0\% & 2 & 0\%\\
\hline
\textbf{AddAnimation(...)} & 0\% & 4 & 0\%\\
\hline
\textbf{RenderAnimations()} & 0\% & 6 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{udent/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Graphics/AnimationContainer.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~namespace DIKUArcade.Graphics {~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~    public class AnimationContainer {~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~        internal class OccupyValue<T> {~\\
\cellcolor{red} & 0 & \verb~7~ & & \verb~            public bool Occupied { get; set; }~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~            public T Value;~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~        private OccupyValue<Animation>[] container;~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~        private int size;~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~14~ & & \verb~        public AnimationContainer(int size) {~\\
\cellcolor{red} & 0 & \verb~15~ & & \verb~            if (size < 0) {~\\
\cellcolor{red} & 0 & \verb~16~ & & \verb~                throw new ArgumentOutOfRangeException(~\\
\cellcolor{red} & 0 & \verb~17~ & & \verb~                    $"Cannot instantiate Animation container with negative size: {size}");~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~20~ & & \verb~            container = new OccupyValue<Animation>[size];~\\
\cellcolor{red} & 0 & \verb~21~ & & \verb~            this.size = size;~\\
\cellcolor{red} & 0 & \verb~22~ & & \verb~            ResetContainer();~\\
\cellcolor{red} & 0 & \verb~23~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~        /// Clear this container of all bound animation objects~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~28~ & & \verb~        public void ResetContainer() {~\\
\cellcolor{red} & 0 & \verb~29~ & & \verb~            for (int i = 0; i < size; i++) {~\\
\cellcolor{red} & 0 & \verb~30~ & & \verb~                container[i] = new OccupyValue<Animation>()~\\
\cellcolor{red} & 0 & \verb~31~ & & \verb~                    {Occupied = false, Value = new Animation() {~\\
\cellcolor{red} & 0 & \verb~32~ & & \verb~                        Duration = 0, Shape = new StationaryShape(0.0f, 0.0f, 0.0f, 0.0f)~\\
\cellcolor{red} & 0 & \verb~33~ & & \verb~                    }};~\\
\cellcolor{red} & 0 & \verb~34~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~35~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~38~ & & \verb~        /// Add an animation to this container. Return true if successful, otherwise false.~\\
\cellcolor{gray} &  & \verb~39~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~40~ & & \verb~        /// <param name="shape"></param>~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~        /// <param name="duration"></param>~\\
\cellcolor{gray} &  & \verb~42~ & & \verb~        /// <param name="stride"></param>~\\
\cellcolor{red} & 0 & \verb~43~ & & \verb~        public bool AddAnimation(Shape shape, int duration, ImageStride stride) {~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~            for (int i = 0; i < size; i++) {~\\
\cellcolor{red} & 0 & \verb~45~ & & \verb~                var anim = container[i];~\\
\cellcolor{red} & 0 & \verb~46~ & & \verb~                if (!anim.Occupied) {~\\
\cellcolor{red} & 0 & \verb~47~ & & \verb~                    anim.Occupied = true;~\\
\cellcolor{red} & 0 & \verb~48~ & & \verb~                    anim.Value.Shape.Position = shape.Position;~\\
\cellcolor{red} & 0 & \verb~49~ & & \verb~                    anim.Value.Shape.Extent = shape.Extent;~\\
\cellcolor{red} & 0 & \verb~50~ & & \verb~                    anim.Value.Duration = duration;~\\
\cellcolor{red} & 0 & \verb~51~ & & \verb~                    anim.Value.Stride = stride;~\\
\cellcolor{red} & 0 & \verb~52~ & & \verb~                    anim.Value.ResetAnimation();~\\
\cellcolor{red} & 0 & \verb~53~ & & \verb~                    return true;~\\
\cellcolor{gray} &  & \verb~54~ & & \verb~                }~\\
\cellcolor{red} & 0 & \verb~55~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~56~ & & \verb~            return false;~\\
\cellcolor{red} & 0 & \verb~57~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~58~ & & \verb~~\\
\cellcolor{gray} &  & \verb~59~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~60~ & & \verb~        /// Render all animation objects currently bound to this container~\\
\cellcolor{gray} &  & \verb~61~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~62~ & & \verb~        public void RenderAnimations() {~\\
\cellcolor{red} & 0 & \verb~63~ & & \verb~            foreach (var animation in container) {~\\
\cellcolor{red} & 0 & \verb~64~ & & \verb~                if (animation.Occupied && animation.Value.IsActive()) {~\\
\cellcolor{red} & 0 & \verb~65~ & & \verb~                    animation.Value.RenderAnimation();~\\
\cellcolor{red} & 0 & \verb~66~ & & \verb~                } else {~\\
\cellcolor{red} & 0 & \verb~67~ & & \verb~                    animation.Occupied = false;~\\
\cellcolor{red} & 0 & \verb~68~ & & \verb~                }~\\
\cellcolor{red} & 0 & \verb~69~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~70~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~71~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~72~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Graphics.Camera}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Graphics.Camera\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Graphics/Camera.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 12\\
\textbf{Coverable lines:} & 12\\
\textbf{Total lines:} & 26\\
\textbf{Line coverage:} & 0\% (0 of 12)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 3\\
\textbf{Method coverage:} & 0\% (0 of 3)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{ScaleBy(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{OffsetBy(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{setZoom()} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Graphics/Camera.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using OpenTK.Graphics.OpenGL;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~namespace DIKUArcade.Graphics {~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~    public abstract class Camera {~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~        public Vec2F Offset;~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~        public float Scale;~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~10~ & & \verb~        public void ScaleBy(float scalar) {~\\
\cellcolor{red} & 0 & \verb~11~ & & \verb~            Scale *= scalar;~\\
\cellcolor{red} & 0 & \verb~12~ & & \verb~            setZoom();~\\
\cellcolor{red} & 0 & \verb~13~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~15~ & & \verb~        public void OffsetBy(Vec2F offsetBy) {~\\
\cellcolor{red} & 0 & \verb~16~ & & \verb~            Offset += offsetBy;~\\
\cellcolor{red} & 0 & \verb~17~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~19~ & & \verb~        private void setZoom() {~\\
\cellcolor{red} & 0 & \verb~20~ & & \verb~            GL.MatrixMode(MatrixMode.Projection);~\\
\cellcolor{red} & 0 & \verb~21~ & & \verb~            GL.LoadIdentity();~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~            //GL.Ortho(-1.0, 1.0, -1.0, 1.0, 0.0, 4.0);~\\
\cellcolor{red} & 0 & \verb~23~ & & \verb~            GL.Ortho(0.0, 1.0 * Scale,0.0,1.0 * Scale, 0.0, 4.0);~\\
\cellcolor{red} & 0 & \verb~24~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Graphics.ChaseCamera}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Graphics.ChaseCamera\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Graphics/ChaseCamera.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 19\\
\textbf{Coverable lines:} & 19\\
\textbf{Total lines:} & 50\\
\textbf{Line coverage:} & 0\% (0 of 19)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 10\\
\textbf{Branch coverage:} & 0\% (0 of 10)\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 2\\
\textbf{Method coverage:} & 0\% (0 of 2)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 0\% & 2 & 0\%\\
\hline
\textbf{EnqueueDirection(...} & 0\% & 8 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Graphics/ChaseCamera.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~namespace DIKUArcade.Graphics {~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~/// <summary>A camera that takes a direction </summary>~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    public class ChaseCamera : Camera {~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~        public Shape WorldShape;~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~        public DynamicShape cameraShape;~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~        // We want to expose the camera position, as it is quite nice to know what we are looking at.~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~        //public Vec2F CameraPos() { return cameraShape.Position; }~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~15~ & & \verb~        private Vec2F baseOffset = new Vec2F(0.5f, 0.5f);~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~        private Queue<Vec2F> directionQueue;~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~        // Set the frame delay of the camera~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~        private const int CAMERA_DELAY = 20;~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~23~ & & \verb~        public ChaseCamera(StationaryShape worldShape) {~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~25~ & & \verb~            cameraShape = new DynamicShape(0.5f, 0.5f, 0.0f, 0.0f);~\\
\cellcolor{red} & 0 & \verb~26~ & & \verb~            Offset = baseOffset - cameraShape.Position;//new Vec2F(0f, 0f);~\\
\cellcolor{red} & 0 & \verb~27~ & & \verb~            Scale = 1f;~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~29~ & & \verb~            WorldShape = worldShape;~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~             // Initialize the queue and fill it with 0-vectors to make the camera lag behind by CAMERA_DELAY seconds~\\
\cellcolor{red} & 0 & \verb~31~ & & \verb~            directionQueue = new Queue<Vec2F>(CAMERA_DELAY);~\\
\cellcolor{red} & 0 & \verb~32~ & & \verb~            for (int i = 0; i < CAMERA_DELAY; i++) { directionQueue.Enqueue(new Vec2F(0f,0f)); }~\\
\cellcolor{red} & 0 & \verb~33~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~34~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~35~ & & \verb~        public void EnqueueDirection(Vec2F direction) {~\\
\cellcolor{red} & 0 & \verb~36~ & & \verb~            cameraShape.Direction = directionQueue.Dequeue();~\\
\cellcolor{red} & 0 & \verb~37~ & & \verb~            directionQueue.Enqueue(direction);~\\
\cellcolor{gray} &  & \verb~38~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~39~ & & \verb~            cameraShape.Move();~\\
\cellcolor{gray} &  & \verb~40~ & & \verb~~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~            // Update camera offset and clamp it to the worldshape~\\
\cellcolor{red} & 0 & \verb~42~ & & \verb~            Offset = baseOffset - cameraShape.Position;~\\
\cellcolor{red} & 0 & \verb~43~ & & \verb~            if (-Offset.X      < WorldShape.Position.X)                       { Offset.X = -WorldShape.Position.X; }~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~            if (-Offset.X + 1f > WorldShape.Position.X + WorldShape.Extent.X) { Offset.X = -(WorldShape.Position.X + Wor~\\
\cellcolor{red} & 0 & \verb~45~ & & \verb~            if (-Offset.Y      < WorldShape.Position.Y)                       { Offset.Y = -WorldShape.Position.Y; }~\\
\cellcolor{red} & 0 & \verb~46~ & & \verb~            if (-Offset.Y + 1f > WorldShape.Position.Y + WorldShape.Extent.Y) { Offset.Y = -(WorldShape.Position.Y + Wor~\\
\cellcolor{gray} &  & \verb~47~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~48~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~50~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Graphics.DynamicCamera}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Graphics.DynamicCamera\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{me/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Graphics/DynamicCamera.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 46\\
\textbf{Coverable lines:} & 46\\
\textbf{Total lines:} & 79\\
\textbf{Line coverage:} & 0\% (0 of 46)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 20\\
\textbf{Branch coverage:} & 0\% (0 of 20)\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 3\\
\textbf{Method coverage:} & 0\% (0 of 3)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{OffsetRelativeTo(...} & 0\% & 20 & 0\%\\
\hline
\textbf{Render()} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{me/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Graphics/DynamicCamera.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~namespace DIKUArcade.Graphics {~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~    public class DynamicCamera : Camera {~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~        public Shape WorldShape;~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~        private DynamicShape innerBounds;~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~        private Entity overlay;~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~        private Vec2F displacement;~\\
\cellcolor{red} & 0 & \verb~13~ & & \verb~        public DynamicCamera(StationaryShape worldShape) {~\\
\cellcolor{red} & 0 & \verb~14~ & & \verb~            Offset = new Vec2F(0.0f, 0.0f);~\\
\cellcolor{red} & 0 & \verb~15~ & & \verb~            Scale = 1f;~\\
\cellcolor{red} & 0 & \verb~16~ & & \verb~            WorldShape = worldShape;~\\
\cellcolor{red} & 0 & \verb~17~ & & \verb~            innerBounds = new DynamicShape(0.25f, 0.25f, 0.5f, 0.5f);~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~            //innerBounds.ScaleFromCenter(0.5f);~\\
\cellcolor{red} & 0 & \verb~19~ & & \verb~            displacement = innerBounds.Position;~\\
\cellcolor{red} & 0 & \verb~20~ & & \verb~            overlay = new Entity(innerBounds, new Image(Path.Combine("Assets", "Images", "Overlay.png")));~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~22~ & & \verb~            System.Console.WriteLine("Offset is: {0}", Offset);~\\
\cellcolor{red} & 0 & \verb~23~ & & \verb~            System.Console.WriteLine("inner is: {0}", innerBounds.Position);~\\
\cellcolor{red} & 0 & \verb~24~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~26~ & & \verb~        public void OffsetRelativeTo(Vec2F offsetRelativeTo) {~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~            // Check if "safe" inside the inner bounds and exit early~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~            // The magic constant 0.03f is the players width and height~\\
\cellcolor{red} & 0 & \verb~29~ & & \verb~            if (innerBounds.Position.X <= offsetRelativeTo.X~\\
\cellcolor{red} & 0 & \verb~30~ & & \verb~                && offsetRelativeTo.X <= innerBounds.Position.X + innerBounds.Extent.X - 0.03f~\\
\cellcolor{red} & 0 & \verb~31~ & & \verb~                && innerBounds.Position.Y <= offsetRelativeTo.Y~\\
\cellcolor{red} & 0 & \verb~32~ & & \verb~                && offsetRelativeTo.Y <= innerBounds.Position.Y + innerBounds.Extent.Y - 0.03f) {~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~                    //innerBounds.Direction = new Vec2F(0.0f, 0.0f);~\\
\cellcolor{red} & 0 & \verb~34~ & & \verb~                    return;~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~                }~\\
\cellcolor{red} & 0 & \verb~36~ & & \verb~            else {~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~                // Calculate new offset~\\
\cellcolor{gray} &  & \verb~38~ & & \verb~                // If the player has driven out the left side of the box~\\
\cellcolor{red} & 0 & \verb~39~ & & \verb~                if (offsetRelativeTo.X < innerBounds.Position.X)~\\
\cellcolor{red} & 0 & \verb~40~ & & \verb~                {~\\
\cellcolor{red} & 0 & \verb~41~ & & \verb~                    innerBounds.Position.X = offsetRelativeTo.X;~\\
\cellcolor{gray} &  & \verb~42~ & & \verb~                    //innerBounds.Direction.X = offsetRelativeTo.X - innerBounds.Position.X;~\\
\cellcolor{red} & 0 & \verb~43~ & & \verb~                }~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~                else if (offsetRelativeTo.X > innerBounds.Position.X + innerBounds.Extent.X - 0.03f) {~\\
\cellcolor{red} & 0 & \verb~45~ & & \verb~                    innerBounds.Position.X = (offsetRelativeTo.X - innerBounds.Extent.X - 0.03f);~\\
\cellcolor{gray} &  & \verb~46~ & & \verb~                    //innerBounds.Direction.X = (offsetRelativeTo.X - (innerBounds.Position.X + innerBounds.Extent.X -0.~\\
\cellcolor{red} & 0 & \verb~47~ & & \verb~                }~\\
\cellcolor{gray} &  & \verb~48~ & & \verb~                //innerBounds.Direction *= 3.0f;~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~                //innerBounds.Move();~\\
\cellcolor{gray} &  & \verb~50~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~51~ & & \verb~                Offset = displacement - innerBounds.Position;~\\
\cellcolor{gray} &  & \verb~52~ & & \verb~                // Then check if outside the world and move stuff back~\\
\cellcolor{gray} &  & \verb~53~ & & \verb~                // Stop at the edge of the world~\\
\cellcolor{red} & 0 & \verb~54~ & & \verb~                if (-Offset.X < WorldShape.Position.X) { // Left side~\\
\cellcolor{red} & 0 & \verb~55~ & & \verb~                        Offset.X = -WorldShape.Position.X;~\\
\cellcolor{red} & 0 & \verb~56~ & & \verb~                        innerBounds.Position.X = offsetRelativeTo.X;//WorldShape.Position.X + innerBounds.Extent.X / 2.0~\\
\cellcolor{red} & 0 & \verb~57~ & & \verb~                    }~\\
\cellcolor{red} & 0 & \verb~58~ & & \verb~                if (-Offset.X + 1f > WorldShape.Position.X + WorldShape.Extent.X) { // Right side~\\
\cellcolor{red} & 0 & \verb~59~ & & \verb~                     Offset.X = -(WorldShape.Position.X + WorldShape.Extent.X - 1f);~\\
\cellcolor{red} & 0 & \verb~60~ & & \verb~                     innerBounds.Position.X = offsetRelativeTo.X - 0.03f;//WorldShape.Extent.X - innerBounds.Extent.X;~\\
\cellcolor{red} & 0 & \verb~61~ & & \verb~                    }~\\
\cellcolor{red} & 0 & \verb~62~ & & \verb~                if (-Offset.Y      < WorldShape.Position.Y) // Top~\\
\cellcolor{red} & 0 & \verb~63~ & & \verb~                    { Offset.Y = -WorldShape.Position.Y;~\\
\cellcolor{red} & 0 & \verb~64~ & & \verb~                    innerBounds.Position.Y = offsetRelativeTo.Y; }~\\
\cellcolor{red} & 0 & \verb~65~ & & \verb~                if (-Offset.Y + 1f > WorldShape.Position.Y + WorldShape.Extent.Y) // Bottom~\\
\cellcolor{red} & 0 & \verb~66~ & & \verb~                    {~\\
\cellcolor{red} & 0 & \verb~67~ & & \verb~                        Offset.Y = -(WorldShape.Position.Y + WorldShape.Extent.Y - 1.0f);~\\
\cellcolor{red} & 0 & \verb~68~ & & \verb~                        innerBounds.Position.Y = offsetRelativeTo.Y - 0.03f;~\\
\cellcolor{red} & 0 & \verb~69~ & & \verb~                    }~\\
\cellcolor{gray} &  & \verb~70~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~71~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~72~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~73~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~74~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~75~ & & \verb~        public void Render() {~\\
\cellcolor{red} & 0 & \verb~76~ & & \verb~            overlay.Image.Render(overlay.Shape, this);~\\
\cellcolor{red} & 0 & \verb~77~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~78~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~79~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Graphics.FollowCamera}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Graphics.FollowCamera\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{ome/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Graphics/FollowCamera.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 13\\
\textbf{Coverable lines:} & 13\\
\textbf{Total lines:} & 23\\
\textbf{Line coverage:} & 0\% (0 of 13)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 8\\
\textbf{Branch coverage:} & 0\% (0 of 8)\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 2\\
\textbf{Method coverage:} & 0\% (0 of 2)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{OffsetRelativeTo(...} & 0\% & 8 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{ome/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Graphics/FollowCamera.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~namespace DIKUArcade.Graphics {~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~    public class FollowCamera : Camera {~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~        public Shape WorldShape;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~8~ & & \verb~        private Vec2F baseOffset = new Vec2F(0.5f, 0.5f);~\\
\cellcolor{red} & 0 & \verb~9~ & & \verb~        public FollowCamera(StationaryShape worldShape) {~\\
\cellcolor{red} & 0 & \verb~10~ & & \verb~            Offset = new Vec2F(0f, 0f);~\\
\cellcolor{red} & 0 & \verb~11~ & & \verb~            Scale = 1f;~\\
\cellcolor{red} & 0 & \verb~12~ & & \verb~            WorldShape = worldShape;~\\
\cellcolor{red} & 0 & \verb~13~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~15~ & & \verb~        public void OffsetRelativeTo(Vec2F offsetRelativeTo) {~\\
\cellcolor{red} & 0 & \verb~16~ & & \verb~            Offset = baseOffset - offsetRelativeTo;~\\
\cellcolor{red} & 0 & \verb~17~ & & \verb~            if (-Offset.X      < WorldShape.Position.X)                            { Offset.X = -WorldShape.Position.X; ~\\
\cellcolor{red} & 0 & \verb~18~ & & \verb~            if (-Offset.X + 1f > WorldShape.Position.X + WorldShape.Extent.X) { Offset.X = -(WorldShape.Position.X + Wor~\\
\cellcolor{red} & 0 & \verb~19~ & & \verb~            if (-Offset.Y      < WorldShape.Position.Y)                            { Offset.Y = -WorldShape.Position.Y; ~\\
\cellcolor{red} & 0 & \verb~20~ & & \verb~            if (-Offset.Y + 1f > WorldShape.Position.Y + WorldShape.Extent.Y) { Offset.Y = -(WorldShape.Position.Y + Wor~\\
\cellcolor{red} & 0 & \verb~21~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Graphics.Image}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Graphics.Image\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Graphics/Image.cs}\end{minipage} \\
\textbf{Covered lines:} & 3\\
\textbf{Uncovered lines:} & 12\\
\textbf{Coverable lines:} & 15\\
\textbf{Total lines:} & 28\\
\textbf{Line coverage:} & 20\% (3 of 15)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 1\\
\textbf{Total methods:} & 5\\
\textbf{Method coverage:} & 20\% (1 of 5)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Render(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Render(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{GetTexture()} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Graphics/Image.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~namespace DIKUArcade.Graphics {~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~    public class Image : IBaseImage {~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~        private Texture texture;~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~~\\
\cellcolor{green} & 10502 & \verb~9~ & & \verb~        public Image(string imageFile) {~\\
\cellcolor{green} & 5251 & \verb~10~ & & \verb~            texture = new Texture(imageFile);~\\
\cellcolor{green} & 5251 & \verb~11~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~13~ & & \verb~        public Image(Texture texture) {~\\
\cellcolor{red} & 0 & \verb~14~ & & \verb~            this.texture = texture;~\\
\cellcolor{red} & 0 & \verb~15~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~17~ & & \verb~        public void Render(Shape shape) {~\\
\cellcolor{red} & 0 & \verb~18~ & & \verb~            texture.Render(shape);~\\
\cellcolor{red} & 0 & \verb~19~ & & \verb~        }~\\
\cellcolor{red} & 0 & \verb~20~ & & \verb~        public void Render(Shape shape, Camera camera) {~\\
\cellcolor{red} & 0 & \verb~21~ & & \verb~            texture.Render(shape, camera);~\\
\cellcolor{red} & 0 & \verb~22~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~24~ & & \verb~        public Texture GetTexture() {~\\
\cellcolor{red} & 0 & \verb~25~ & & \verb~            return texture;~\\
\cellcolor{red} & 0 & \verb~26~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Graphics.ImageStride}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Graphics.ImageStride\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Graphics/ImageStride.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 87\\
\textbf{Coverable lines:} & 87\\
\textbf{Total lines:} & 191\\
\textbf{Line coverage:} & 0\% (0 of 87)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 32\\
\textbf{Branch coverage:} & 0\% (0 of 32)\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 10\\
\textbf{Method coverage:} & 0\% (0 of 10)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 0\% & 6 & 0\%\\
\hline
\textbf{.ctor(...)} & 0\% & 6 & 0\%\\
\hline
\textbf{.ctor(...)} & 0\% & 6 & 0\%\\
\hline
\textbf{CreateStrides(...)} & 0\% & 2 & 0\%\\
\hline
\textbf{StartAnimation()} & 100\% & 1 & 0\%\\
\hline
\textbf{StopAnimation()} & 100\% & 1 & 0\%\\
\hline
\textbf{SetAnimationFrequenc} & 0\% & 2 & 0\%\\
\hline
\textbf{ChangeAnimationFrequ} & 0\% & 2 & 0\%\\
\hline
\textbf{Render(...)} & 0\% & 8 & 0\%\\
\hline
\textbf{Render(...)} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Graphics/ImageStride.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using DIKUArcade.Timers;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~using DIKUArcade.Utilities;~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~namespace DIKUArcade.Graphics {~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    /// Image stride to show animations based on a list of textures~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~    /// and an animation frequency.~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~    public class ImageStride : IBaseImage {~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~        private int animFrequency;~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~        private double lastTime;~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~        private bool animate;~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~        private List<Texture> textures;~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~        private readonly int maxImageCount;~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~        private int currentImageCount;~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~        /// This value is only added for random animation offset,~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~        /// e.g. 100 objects created at the same time with the same~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~        /// animation frequency will not change texture at the exact~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~        /// same time.~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~        private double timerOffset;~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~~\\
\cellcolor{gray} &  & \verb~32~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~        ///~\\
\cellcolor{gray} &  & \verb~34~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~        /// <param name="milliseconds">Time between consecutive frames</param>~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~        /// <param name="imageFiles">List of image files to include in strides</param>~\\
\cellcolor{red} & 0 & \verb~37~ & & \verb~        public ImageStride(int milliseconds, params string[] imageFiles) {~\\
\cellcolor{red} & 0 & \verb~38~ & & \verb~            if (milliseconds < 0) {~\\
\cellcolor{red} & 0 & \verb~39~ & & \verb~                throw new ArgumentException("milliseconds must be a positive integer");~\\
\cellcolor{gray} &  & \verb~40~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~41~ & & \verb~            animFrequency = milliseconds;~\\
\cellcolor{red} & 0 & \verb~42~ & & \verb~            animate = true;~\\
\cellcolor{gray} &  & \verb~43~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~            int imgs = imageFiles.Length;~\\
\cellcolor{red} & 0 & \verb~45~ & & \verb~            if (imgs == 0) {~\\
\cellcolor{gray} &  & \verb~46~ & & \verb~                // ReSharper disable once NotResolvedInText~\\
\cellcolor{red} & 0 & \verb~47~ & & \verb~                throw new ArgumentNullException("At least one image file must be specified");~\\
\cellcolor{gray} &  & \verb~48~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~49~ & & \verb~            maxImageCount = imgs - 1;~\\
\cellcolor{red} & 0 & \verb~50~ & & \verb~            currentImageCount = RandomGenerator.Generator.Next(imgs);~\\
\cellcolor{red} & 0 & \verb~51~ & & \verb~            timerOffset = RandomGenerator.Generator.Next(100);~\\
\cellcolor{gray} &  & \verb~52~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~53~ & & \verb~            textures = new List<Texture>(imgs);~\\
\cellcolor{red} & 0 & \verb~54~ & & \verb~            foreach (string imgFile in imageFiles)~\\
\cellcolor{red} & 0 & \verb~55~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~56~ & & \verb~                textures.Add(new Texture(imgFile));~\\
\cellcolor{red} & 0 & \verb~57~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~58~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~59~ & & \verb~~\\
\cellcolor{gray} &  & \verb~60~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~61~ & & \verb~        ///~\\
\cellcolor{gray} &  & \verb~62~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~63~ & & \verb~        /// <param name="milliseconds">Time between consecutive frames</param>~\\
\cellcolor{gray} &  & \verb~64~ & & \verb~        /// <param name="images">List of images to include in strides</param>~\\
\cellcolor{red} & 0 & \verb~65~ & & \verb~        public ImageStride(int milliseconds, params Image[] images) {~\\
\cellcolor{red} & 0 & \verb~66~ & & \verb~            if (milliseconds < 0) {~\\
\cellcolor{red} & 0 & \verb~67~ & & \verb~                throw new ArgumentException("milliseconds must be a positive integer");~\\
\cellcolor{gray} &  & \verb~68~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~69~ & & \verb~            animFrequency = milliseconds;~\\
\cellcolor{red} & 0 & \verb~70~ & & \verb~            animate = true;~\\
\cellcolor{gray} &  & \verb~71~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~72~ & & \verb~            int imgs = images.Length;~\\
\cellcolor{red} & 0 & \verb~73~ & & \verb~            if (imgs == 0) {~\\
\cellcolor{gray} &  & \verb~74~ & & \verb~                // ReSharper disable once NotResolvedInText~\\
\cellcolor{red} & 0 & \verb~75~ & & \verb~                throw new ArgumentNullException("at least one image file must be specified");~\\
\cellcolor{gray} &  & \verb~76~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~77~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~78~ & & \verb~            maxImageCount = imgs - 1;~\\
\cellcolor{red} & 0 & \verb~79~ & & \verb~            currentImageCount = RandomGenerator.Generator.Next(imgs);~\\
\cellcolor{red} & 0 & \verb~80~ & & \verb~            timerOffset = RandomGenerator.Generator.Next(100);~\\
\cellcolor{gray} &  & \verb~81~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~82~ & & \verb~            textures = new List<Texture>(imgs);~\\
\cellcolor{red} & 0 & \verb~83~ & & \verb~            foreach (Image img in images)~\\
\cellcolor{red} & 0 & \verb~84~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~85~ & & \verb~                textures.Add(img.GetTexture());~\\
\cellcolor{red} & 0 & \verb~86~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~87~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~88~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~89~ & & \verb~        public ImageStride(int milliseconds, List<Image> images) {~\\
\cellcolor{red} & 0 & \verb~90~ & & \verb~            if (milliseconds < 0) {~\\
\cellcolor{red} & 0 & \verb~91~ & & \verb~                throw new ArgumentException("milliseconds must be a positive integer");~\\
\cellcolor{gray} &  & \verb~92~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~93~ & & \verb~            animFrequency = milliseconds;~\\
\cellcolor{red} & 0 & \verb~94~ & & \verb~            animate = true;~\\
\cellcolor{gray} &  & \verb~95~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~96~ & & \verb~            int imgs = images.Count;~\\
\cellcolor{red} & 0 & \verb~97~ & & \verb~            if (imgs == 0) {~\\
\cellcolor{gray} &  & \verb~98~ & & \verb~                // ReSharper disable once NotResolvedInText~\\
\cellcolor{red} & 0 & \verb~99~ & & \verb~                throw new ArgumentNullException("at least one image file must be specified");~\\
\cellcolor{gray} &  & \verb~100~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~101~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~102~ & & \verb~            maxImageCount = imgs - 1;~\\
\cellcolor{red} & 0 & \verb~103~ & & \verb~            currentImageCount = RandomGenerator.Generator.Next(imgs);~\\
\cellcolor{red} & 0 & \verb~104~ & & \verb~            timerOffset = RandomGenerator.Generator.Next(100);~\\
\cellcolor{gray} &  & \verb~105~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~106~ & & \verb~            textures = new List<Texture>(imgs);~\\
\cellcolor{red} & 0 & \verb~107~ & & \verb~            foreach (Image img in images)~\\
\cellcolor{red} & 0 & \verb~108~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~109~ & & \verb~                textures.Add(img.GetTexture());~\\
\cellcolor{red} & 0 & \verb~110~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~111~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~112~ & & \verb~~\\
\cellcolor{gray} &  & \verb~113~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~114~ & & \verb~        /// Create a List of images from an image stride file.~\\
\cellcolor{gray} &  & \verb~115~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~116~ & & \verb~        /// <param name="numStrides">Total number of strides in the image</param>~\\
\cellcolor{gray} &  & \verb~117~ & & \verb~        /// <param name="imagePath">The relative path to the image</param>~\\
\cellcolor{gray} &  & \verb~118~ & & \verb~        /// <returns>A list of Image objects, each corresponding to a stride of the image.</returns>~\\
\cellcolor{red} & 0 & \verb~119~ & & \verb~        public static List<Image> CreateStrides(int numStrides, string imagePath) {~\\
\cellcolor{red} & 0 & \verb~120~ & & \verb~            var res = new List<Image>();~\\
\cellcolor{gray} &  & \verb~121~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~122~ & & \verb~            for (int i = 0; i < numStrides; i++) {~\\
\cellcolor{red} & 0 & \verb~123~ & & \verb~                res.Add(new Image(new Texture(imagePath, i, numStrides)));~\\
\cellcolor{red} & 0 & \verb~124~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~125~ & & \verb~            return res;~\\
\cellcolor{red} & 0 & \verb~126~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~127~ & & \verb~~\\
\cellcolor{gray} &  & \verb~128~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~129~ & & \verb~        /// Restart animation for this ImageStride object~\\
\cellcolor{gray} &  & \verb~130~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~131~ & & \verb~        public void StartAnimation() {~\\
\cellcolor{red} & 0 & \verb~132~ & & \verb~            animate = true;~\\
\cellcolor{red} & 0 & \verb~133~ & & \verb~            lastTime = StaticTimer.GetElapsedMilliseconds();~\\
\cellcolor{red} & 0 & \verb~134~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~135~ & & \verb~~\\
\cellcolor{gray} &  & \verb~136~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~137~ & & \verb~        /// Halt animation for this ImageStride object~\\
\cellcolor{gray} &  & \verb~138~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~139~ & & \verb~        public void StopAnimation() {~\\
\cellcolor{red} & 0 & \verb~140~ & & \verb~            animate = false;~\\
\cellcolor{red} & 0 & \verb~141~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~142~ & & \verb~~\\
\cellcolor{gray} &  & \verb~143~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~144~ & & \verb~        /// Change the animation frequency for this ImageStride object~\\
\cellcolor{gray} &  & \verb~145~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~146~ & & \verb~        /// <param name="milliseconds"></param>~\\
\cellcolor{gray} &  & \verb~147~ & & \verb~        /// <exception cref="ArgumentException">milliseconds must be a positive integer</exception>~\\
\cellcolor{red} & 0 & \verb~148~ & & \verb~        public void SetAnimationFrequency(int milliseconds) {~\\
\cellcolor{red} & 0 & \verb~149~ & & \verb~            if (milliseconds < 0) {~\\
\cellcolor{red} & 0 & \verb~150~ & & \verb~                throw new ArgumentException("milliseconds must be a positive integer");~\\
\cellcolor{gray} &  & \verb~151~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~152~ & & \verb~            animFrequency = milliseconds;~\\
\cellcolor{red} & 0 & \verb~153~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~154~ & & \verb~~\\
\cellcolor{gray} &  & \verb~155~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~156~ & & \verb~        /// Relatively change the animation frequency for this ImageStride object~\\
\cellcolor{gray} &  & \verb~157~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~158~ & & \verb~        /// <param name="millisecondsChange"></param>~\\
\cellcolor{gray} &  & \verb~159~ & & \verb~        /// <exception cref="ArgumentException">milliseconds must be a positive integer</exception>~\\
\cellcolor{red} & 0 & \verb~160~ & & \verb~        public void ChangeAnimationFrequency(int millisecondsChange) {~\\
\cellcolor{red} & 0 & \verb~161~ & & \verb~            animFrequency += millisecondsChange;~\\
\cellcolor{red} & 0 & \verb~162~ & & \verb~            if (animFrequency < 0) {~\\
\cellcolor{red} & 0 & \verb~163~ & & \verb~                animFrequency = 0;~\\
\cellcolor{red} & 0 & \verb~164~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~165~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~166~ & & \verb~~\\
\cellcolor{gray} &  & \verb~167~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~168~ & & \verb~        /// Render this ImageStride object onto the currently active drawing window~\\
\cellcolor{gray} &  & \verb~169~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~170~ & & \verb~        /// <param name="shape">The Shape object for the rendered image</param>~\\
\cellcolor{red} & 0 & \verb~171~ & & \verb~        public void Render(Shape shape) {~\\
\cellcolor{gray} &  & \verb~172~ & & \verb~            // measure elapsed time~\\
\cellcolor{red} & 0 & \verb~173~ & & \verb~            double elapsed = StaticTimer.GetElapsedMilliseconds() + timerOffset;~\\
\cellcolor{gray} &  & \verb~174~ & & \verb~~\\
\cellcolor{gray} &  & \verb~175~ & & \verb~            // the desired number of milliseconds has passed, change texture stride~\\
\cellcolor{red} & 0 & \verb~176~ & & \verb~            if (animFrequency > 0 && animate && elapsed - lastTime > animFrequency) {~\\
\cellcolor{red} & 0 & \verb~177~ & & \verb~                lastTime = elapsed;~\\
\cellcolor{gray} &  & \verb~178~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~179~ & & \verb~                currentImageCount =~\\
\cellcolor{red} & 0 & \verb~180~ & & \verb~                    (currentImageCount >= maxImageCount) ? 0 : currentImageCount + 1;~\\
\cellcolor{red} & 0 & \verb~181~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~182~ & & \verb~~\\
\cellcolor{gray} &  & \verb~183~ & & \verb~            // render the current texture object~\\
\cellcolor{red} & 0 & \verb~184~ & & \verb~            textures[currentImageCount].Render(shape);~\\
\cellcolor{red} & 0 & \verb~185~ & & \verb~        }~\\
\cellcolor{red} & 0 & \verb~186~ & & \verb~        public void Render(Shape shape, Camera camera) {~\\
\cellcolor{red} & 0 & \verb~187~ & & \verb~            throw new NotImplementedException();~\\
\cellcolor{gray} &  & \verb~188~ & & \verb~~\\
\cellcolor{gray} &  & \verb~189~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~190~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~191~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Graphics.NoImage}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Graphics.NoImage\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Graphics/NoImage.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 3\\
\textbf{Coverable lines:} & 3\\
\textbf{Total lines:} & 11\\
\textbf{Line coverage:} & 0\% (0 of 3)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 3\\
\textbf{Method coverage:} & 0\% (0 of 3)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor()} & 100\% & 1 & 0\%\\
\hline
\textbf{Render(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Render(...)} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Graphics/NoImage.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~namespace DIKUArcade.Graphics {~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~    /// A stub for an image, to use with entities that are non-drawable~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~    public class NoImage : IBaseImage {~\\
\cellcolor{red} & 0 & \verb~7~ & & \verb~        public NoImage() {}~\\
\cellcolor{red} & 0 & \verb~8~ & & \verb~        public void Render(Shape shape) {}~\\
\cellcolor{red} & 0 & \verb~9~ & & \verb~        public void Render(Shape shape, Camera camera) {}~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Graphics.StaticCamera}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Graphics.StaticCamera\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{ome/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Graphics/StaticCamera.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 4\\
\textbf{Coverable lines:} & 4\\
\textbf{Total lines:} & 14\\
\textbf{Line coverage:} & 0\% (0 of 4)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 1\\
\textbf{Method coverage:} & 0\% (0 of 1)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor()} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{ome/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Graphics/StaticCamera.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~namespace DIKUArcade.Graphics {~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~    public class StaticCamera : Camera {~\\
\cellcolor{red} & 0 & \verb~5~ & & \verb~        public StaticCamera() {~\\
\cellcolor{red} & 0 & \verb~6~ & & \verb~            Offset = new Vec2F(0f, 0f);~\\
\cellcolor{red} & 0 & \verb~7~ & & \verb~            Scale = 1f;~\\
\cellcolor{red} & 0 & \verb~8~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Graphics.Text}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Graphics.Text\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Graphics/Text.cs}\end{minipage} \\
\textbf{Covered lines:} & 79\\
\textbf{Uncovered lines:} & 62\\
\textbf{Coverable lines:} & 141\\
\textbf{Total lines:} & 300\\
\textbf{Line coverage:} & 56\% (79 of 141)\\
\textbf{Covered branches:} & 6\\
\textbf{Total branches:} & 78\\
\textbf{Branch coverage:} & 7.6\% (6 of 78)\\
\textbf{Covered methods:} & 8\\
\textbf{Total methods:} & 17\\
\textbf{Method coverage:} & 47\% (8 of 17)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{CreateBitmapTexture(} & 100\% & 1 & 100\%\\
\hline
\textbf{BindTexture()} & 100\% & 1 & 100\%\\
\hline
\textbf{UnbindTexture()} & 100\% & 1 & 100\%\\
\hline
\textbf{GetShape()} & 100\% & 1 & 0\%\\
\hline
\textbf{SetText(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{SetFontSize(...)} & 0\% & 2 & 0\%\\
\hline
\textbf{SetFont(...)} & 0\% & 4 & 0\%\\
\hline
\textbf{SetColor(...)} & 0\% & 12 & 0\%\\
\hline
\textbf{SetColor(...)} & 50.0\% & 12 & 87.50\%\\
\hline
\textbf{SetColor(...)} & 0\% & 16 & 0\%\\
\hline
\textbf{SetColor(...)} & 0\% & 16 & 0\%\\
\hline
\textbf{SetColor(...)} & 0\% & 16 & 0\%\\
\hline
\textbf{SetColor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{CreateMatrix()} & 100\% & 1 & 100\%\\
\hline
\textbf{ScaleText(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{RenderText()} & 100\% & 1 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Graphics/Text.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using System.Drawing;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using System.Drawing.Imaging;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using System.Drawing.Text;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~using OpenTK.Graphics.OpenGL;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~using OpenTK.Mathematics;~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~namespace DIKUArcade.Graphics {~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    public class Text {~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~        // TODO: Add method for centering text (vertically, horizontally) within its shape!~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~        /// OpenGL texture handle~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~        private int textureId;~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~        /// The string value for the text~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~        private string text;~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~        /// The font size for the text string~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~        private int fontSize;~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~        /// The position and size of the text~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~        private StationaryShape shape;~\\
\cellcolor{gray} &  & \verb~32~ & & \verb~~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~34~ & & \verb~        /// The color for the text~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~        private System.Drawing.Color color;~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~~\\
\cellcolor{gray} &  & \verb~38~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~39~ & & \verb~        /// The font family of the text.~\\
\cellcolor{gray} &  & \verb~40~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~        private System.Drawing.Font font;~\\
\cellcolor{gray} &  & \verb~42~ & & \verb~~\\
\cellcolor{green} & 2650 & \verb~43~ & & \verb~        public Text(string text, Vec2F pos, Vec2F extent) {~\\
\cellcolor{green} & 1325 & \verb~44~ & & \verb~            this.text = text;~\\
\cellcolor{green} & 1325 & \verb~45~ & & \verb~            shape = new StationaryShape(pos, extent);~\\
\cellcolor{green} & 1325 & \verb~46~ & & \verb~            color = System.Drawing.Color.Black;~\\
\cellcolor{green} & 1325 & \verb~47~ & & \verb~            fontSize = 50;~\\
\cellcolor{green} & 1325 & \verb~48~ & & \verb~            font = new Font("Arial", fontSize);~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~~\\
\cellcolor{gray} &  & \verb~50~ & & \verb~            // create a texture id~\\
\cellcolor{green} & 1325 & \verb~51~ & & \verb~            textureId = GL.GenTexture();~\\
\cellcolor{gray} &  & \verb~52~ & & \verb~~\\
\cellcolor{gray} &  & \verb~53~ & & \verb~            // bind this new texture id~\\
\cellcolor{green} & 1325 & \verb~54~ & & \verb~            BindTexture();~\\
\cellcolor{gray} &  & \verb~55~ & & \verb~~\\
\cellcolor{gray} &  & \verb~56~ & & \verb~            // set texture properties, filters, blending functions, etc.~\\
\cellcolor{green} & 1325 & \verb~57~ & & \verb~            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)All.Linear);~\\
\cellcolor{green} & 1325 & \verb~58~ & & \verb~            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)All.Linear);~\\
\cellcolor{gray} &  & \verb~59~ & & \verb~~\\
\cellcolor{green} & 1325 & \verb~60~ & & \verb~            GL.Enable(EnableCap.Blend);~\\
\cellcolor{green} & 1325 & \verb~61~ & & \verb~            GL.BlendFunc(BlendingFactor.SrcAlpha, BlendingFactor.OneMinusSrcAlpha);~\\
\cellcolor{gray} &  & \verb~62~ & & \verb~~\\
\cellcolor{green} & 1325 & \verb~63~ & & \verb~            GL.Enable(EnableCap.DepthTest);~\\
\cellcolor{green} & 1325 & \verb~64~ & & \verb~            GL.DepthFunc(DepthFunction.Lequal);~\\
\cellcolor{gray} &  & \verb~65~ & & \verb~~\\
\cellcolor{green} & 1325 & \verb~66~ & & \verb~            GL.Enable(EnableCap.Texture2D);~\\
\cellcolor{green} & 1325 & \verb~67~ & & \verb~            GL.Enable(EnableCap.AlphaTest);~\\
\cellcolor{gray} &  & \verb~68~ & & \verb~~\\
\cellcolor{green} & 1325 & \verb~69~ & & \verb~            GL.AlphaFunc(AlphaFunction.Gequal, 0.5f);~\\
\cellcolor{gray} &  & \verb~70~ & & \verb~~\\
\cellcolor{gray} &  & \verb~71~ & & \verb~            // unbind this new texture~\\
\cellcolor{green} & 1325 & \verb~72~ & & \verb~            UnbindTexture();~\\
\cellcolor{gray} &  & \verb~73~ & & \verb~~\\
\cellcolor{gray} &  & \verb~74~ & & \verb~            // create a texture~\\
\cellcolor{green} & 1325 & \verb~75~ & & \verb~            CreateBitmapTexture();~\\
\cellcolor{green} & 1325 & \verb~76~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~77~ & & \verb~~\\
\cellcolor{gray} &  & \verb~78~ & & \verb~        // This method assumes that~\\
\cellcolor{green} & 2800 & \verb~79~ & & \verb~        private void CreateBitmapTexture() {~\\
\cellcolor{green} & 2800 & \verb~80~ & & \verb~            BindTexture();~\\
\cellcolor{gray} &  & \verb~81~ & & \verb~~\\
\cellcolor{green} & 2800 & \verb~82~ & & \verb~            System.Drawing.Bitmap textBmp = new System.Drawing.Bitmap(500, 500); // match window size~\\
\cellcolor{gray} &  & \verb~83~ & & \verb~~\\
\cellcolor{gray} &  & \verb~84~ & & \verb~            // just allocate memory, so we can update efficiently using TexSubImage2D~\\
\cellcolor{green} & 2800 & \verb~85~ & & \verb~            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, textBmp.Width, textBmp.Height, 0,~\\
\cellcolor{green} & 2800 & \verb~86~ & & \verb~                OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, IntPtr.Zero);~\\
\cellcolor{gray} &  & \verb~87~ & & \verb~~\\
\cellcolor{green} & 2800 & \verb~88~ & & \verb~            using (System.Drawing.Graphics gfx = System.Drawing.Graphics.FromImage(textBmp))~\\
\cellcolor{green} & 2800 & \verb~89~ & & \verb~            {~\\
\cellcolor{green} & 2800 & \verb~90~ & & \verb~                gfx.Clear(System.Drawing.Color.Transparent);~\\
\cellcolor{gray} &  & \verb~91~ & & \verb~                // TODO: Could create an enumeration for choosing btw different font families!~\\
\cellcolor{green} & 2800 & \verb~92~ & & \verb~                Font drawFont = font;~\\
\cellcolor{green} & 2800 & \verb~93~ & & \verb~                SolidBrush drawBrush = new SolidBrush(color);~\\
\cellcolor{gray} &  & \verb~94~ & & \verb~~\\
\cellcolor{gray} &  & \verb~95~ & & \verb~                // TODO: Maybe we should not use shape.Position here, because different coordinate system !!?~\\
\cellcolor{green} & 2800 & \verb~96~ & & \verb~                System.Drawing.PointF drawPoint = new System.Drawing.PointF(shape.Position.X, shape.Position.Y);~\\
\cellcolor{gray} &  & \verb~97~ & & \verb~~\\
\cellcolor{green} & 2800 & \verb~98~ & & \verb~                gfx.DrawString(text, drawFont, drawBrush, drawPoint); // Draw as many strings as you need~\\
\cellcolor{green} & 2800 & \verb~99~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~100~ & & \verb~~\\
\cellcolor{green} & 2800 & \verb~101~ & & \verb~            BitmapData data = textBmp.LockBits(new System.Drawing.Rectangle(0, 0, textBmp.Width, textBmp.Height),~\\
\cellcolor{green} & 2800 & \verb~102~ & & \verb~                ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);~\\
\cellcolor{green} & 2800 & \verb~103~ & & \verb~            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, textBmp.Width, textBmp.Height, 0,~\\
\cellcolor{green} & 2800 & \verb~104~ & & \verb~                OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, data.Scan0);~\\
\cellcolor{green} & 2800 & \verb~105~ & & \verb~            textBmp.UnlockBits(data);~\\
\cellcolor{gray} &  & \verb~106~ & & \verb~~\\
\cellcolor{green} & 2800 & \verb~107~ & & \verb~            UnbindTexture();~\\
\cellcolor{green} & 2800 & \verb~108~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~109~ & & \verb~~\\
\cellcolor{green} & 4128 & \verb~110~ & & \verb~        private void BindTexture() {~\\
\cellcolor{green} & 4128 & \verb~111~ & & \verb~            GL.BindTexture(TextureTarget.Texture2D, textureId);~\\
\cellcolor{green} & 4128 & \verb~112~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~113~ & & \verb~~\\
\cellcolor{green} & 4128 & \verb~114~ & & \verb~        private void UnbindTexture() {~\\
\cellcolor{green} & 4128 & \verb~115~ & & \verb~            GL.BindTexture(TextureTarget.Texture2D, 0); // 0 is invalid texture id~\\
\cellcolor{green} & 4128 & \verb~116~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~117~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~118~ & & \verb~        public StationaryShape GetShape() {~\\
\cellcolor{red} & 0 & \verb~119~ & & \verb~            return shape;~\\
\cellcolor{red} & 0 & \verb~120~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~121~ & & \verb~~\\
\cellcolor{gray} &  & \verb~122~ & & \verb~        #region ChangeTextProperties~\\
\cellcolor{gray} &  & \verb~123~ & & \verb~~\\
\cellcolor{gray} &  & \verb~124~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~125~ & & \verb~        /// Set the text string for this Text object.~\\
\cellcolor{gray} &  & \verb~126~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~127~ & & \verb~        /// <param name="newText">The new text string</param>~\\
\cellcolor{green} & 120 & \verb~128~ & & \verb~        public void SetText(string newText) {~\\
\cellcolor{green} & 120 & \verb~129~ & & \verb~            text = newText;~\\
\cellcolor{green} & 120 & \verb~130~ & & \verb~            CreateBitmapTexture();~\\
\cellcolor{green} & 120 & \verb~131~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~132~ & & \verb~~\\
\cellcolor{gray} &  & \verb~133~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~134~ & & \verb~        /// Set the font size for this Text object.~\\
\cellcolor{gray} &  & \verb~135~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~136~ & & \verb~        /// <param name="newSize">The new font size</param>~\\
\cellcolor{gray} &  & \verb~137~ & & \verb~        /// <exception cref="ArgumentOutOfRangeException">Font size must be a~\\
\cellcolor{gray} &  & \verb~138~ & & \verb~        /// positive integer.</exception>~\\
\cellcolor{red} & 0 & \verb~139~ & & \verb~        public void SetFontSize(int newSize) {~\\
\cellcolor{red} & 0 & \verb~140~ & & \verb~            if (newSize < 0) {~\\
\cellcolor{gray} &  & \verb~141~ & & \verb~                // ReSharper disable once NotResolvedInText~\\
\cellcolor{red} & 0 & \verb~142~ & & \verb~                throw  new ArgumentOutOfRangeException("Font size must be a positive integer");~\\
\cellcolor{gray} &  & \verb~143~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~144~ & & \verb~            fontSize = newSize;~\\
\cellcolor{red} & 0 & \verb~145~ & & \verb~            CreateBitmapTexture();~\\
\cellcolor{red} & 0 & \verb~146~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~147~ & & \verb~~\\
\cellcolor{gray} &  & \verb~148~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~149~ & & \verb~        /// Set the font for this Text object, if the font is installed.~\\
\cellcolor{gray} &  & \verb~150~ & & \verb~        /// If the font is not installed defaults to Arial.~\\
\cellcolor{gray} &  & \verb~151~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~152~ & & \verb~        /// <param name="fontfamily">The name of the font family</param>~\\
\cellcolor{red} & 0 & \verb~153~ & & \verb~        public void SetFont(string fontfamily) {~\\
\cellcolor{gray} &  & \verb~154~ & & \verb~            // The loop below checks if said font is installed, if not defaults to Arial.~\\
\cellcolor{red} & 0 & \verb~155~ & & \verb~            var fontsCollection = new InstalledFontCollection();~\\
\cellcolor{red} & 0 & \verb~156~ & & \verb~            foreach (var fontFamily in fontsCollection.Families) {~\\
\cellcolor{red} & 0 & \verb~157~ & & \verb~                if (fontFamily.Name == fontfamily) {~\\
\cellcolor{red} & 0 & \verb~158~ & & \verb~                    font = new Font(fontfamily, fontSize);~\\
\cellcolor{red} & 0 & \verb~159~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~160~ & & \verb~                }~\\
\cellcolor{red} & 0 & \verb~161~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~162~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~163~ & & \verb~            CreateBitmapTexture();~\\
\cellcolor{red} & 0 & \verb~164~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~165~ & & \verb~~\\
\cellcolor{gray} &  & \verb~166~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~167~ & & \verb~        /// Change text color~\\
\cellcolor{gray} &  & \verb~168~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~169~ & & \verb~        /// <param name="vec">Vec3F containing the RGB color values.</param>~\\
\cellcolor{gray} &  & \verb~170~ & & \verb~        /// <exception cref="ArgumentOutOfRangeException">Normalized color values must be~\\
\cellcolor{gray} &  & \verb~171~ & & \verb~        /// between 0 and 1.</exception>~\\
\cellcolor{red} & 0 & \verb~172~ & & \verb~        public void SetColor(Vec3F vec) {~\\
\cellcolor{red} & 0 & \verb~173~ & & \verb~            if (vec.X < 0.0f || vec.X > 1.0f ||~\\
\cellcolor{red} & 0 & \verb~174~ & & \verb~                vec.Y < 0.0f || vec.Y > 1.0f ||~\\
\cellcolor{red} & 0 & \verb~175~ & & \verb~                vec.Z < 0.0f || vec.Z > 1.0f) {~\\
\cellcolor{red} & 0 & \verb~176~ & & \verb~                throw new ArgumentOutOfRangeException($"RGB Color values must be between 0 and 1: {vec}");~\\
\cellcolor{gray} &  & \verb~177~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~178~ & & \verb~            color = System.Drawing.Color.FromArgb((int)(vec.X * 255.0f), (int)(vec.Y * 255.0f), (int)(vec.Z * 255.0f));~\\
\cellcolor{red} & 0 & \verb~179~ & & \verb~            CreateBitmapTexture();~\\
\cellcolor{red} & 0 & \verb~180~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~181~ & & \verb~~\\
\cellcolor{gray} &  & \verb~182~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~183~ & & \verb~        /// Change text color~\\
\cellcolor{gray} &  & \verb~184~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~185~ & & \verb~        /// <param name="vec">Vec3I containing the RGB color values.</param>~\\
\cellcolor{gray} &  & \verb~186~ & & \verb~        /// <exception cref="ArgumentOutOfRangeException">Color values must be~\\
\cellcolor{gray} &  & \verb~187~ & & \verb~        /// between 0 and 255.</exception>~\\
\cellcolor{green} & 1355 & \verb~188~ & & \verb~        public void SetColor(Vec3I vec) {~\\
\cellcolor{orange} & 1355 & \verb~189~ & & \verb~            if (vec.X < 0 || vec.X > 255 ||~\\
\cellcolor{green} & 1355 & \verb~190~ & & \verb~                vec.Y < 0 || vec.Y > 255 ||~\\
\cellcolor{green} & 1355 & \verb~191~ & & \verb~                vec.Z < 0 || vec.Z > 255) {~\\
\cellcolor{red} & 0 & \verb~192~ & & \verb~                throw new ArgumentOutOfRangeException($"RGB Color values must be between 0 and 255: {vec}");~\\
\cellcolor{gray} &  & \verb~193~ & & \verb~            }~\\
\cellcolor{green} & 1355 & \verb~194~ & & \verb~            color = System.Drawing.Color.FromArgb(vec.X, vec.Y, vec.Z);~\\
\cellcolor{green} & 1355 & \verb~195~ & & \verb~            CreateBitmapTexture();~\\
\cellcolor{green} & 1355 & \verb~196~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~197~ & & \verb~~\\
\cellcolor{gray} &  & \verb~198~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~199~ & & \verb~        /// Change text color~\\
\cellcolor{gray} &  & \verb~200~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~201~ & & \verb~        /// <param name="vec">Vec4I containing the ARGB color values.</param>~\\
\cellcolor{gray} &  & \verb~202~ & & \verb~        /// <exception cref="ArgumentOutOfRangeException">Color values must be~\\
\cellcolor{gray} &  & \verb~203~ & & \verb~        /// between 0 and 255.</exception>~\\
\cellcolor{red} & 0 & \verb~204~ & & \verb~        public void SetColor(int a, int r, int g, int b) {~\\
\cellcolor{red} & 0 & \verb~205~ & & \verb~            if (a < 0 || a > 255 ||~\\
\cellcolor{red} & 0 & \verb~206~ & & \verb~                r < 0 || r > 255 ||~\\
\cellcolor{red} & 0 & \verb~207~ & & \verb~                g < 0 || g > 255 ||~\\
\cellcolor{red} & 0 & \verb~208~ & & \verb~                b < 0 || b > 255) {~\\
\cellcolor{red} & 0 & \verb~209~ & & \verb~                throw new ArgumentOutOfRangeException($"ARGB Color values must be between 0 and 255: {a} {r} {g} {b}");~\\
\cellcolor{gray} &  & \verb~210~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~211~ & & \verb~            color = System.Drawing.Color.FromArgb(a, r, g, b);~\\
\cellcolor{red} & 0 & \verb~212~ & & \verb~            CreateBitmapTexture();~\\
\cellcolor{red} & 0 & \verb~213~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~214~ & & \verb~~\\
\cellcolor{gray} &  & \verb~215~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~216~ & & \verb~        /// Change text color~\\
\cellcolor{gray} &  & \verb~217~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~218~ & & \verb~        /// <param name="vec">Vec4I containing the ARGB color values.</param>~\\
\cellcolor{gray} &  & \verb~219~ & & \verb~        /// <exception cref="ArgumentOutOfRangeException">Color values must be~\\
\cellcolor{gray} &  & \verb~220~ & & \verb~        /// between 0 and 255.</exception>~\\
\cellcolor{red} & 0 & \verb~221~ & & \verb~        public void SetColor(Vec4I vec) {~\\
\cellcolor{red} & 0 & \verb~222~ & & \verb~            if (vec.X < 0 || vec.X > 255 ||~\\
\cellcolor{red} & 0 & \verb~223~ & & \verb~                vec.Y < 0 || vec.Y > 255 ||~\\
\cellcolor{red} & 0 & \verb~224~ & & \verb~                vec.Z < 0 || vec.Z > 255 ||~\\
\cellcolor{red} & 0 & \verb~225~ & & \verb~                vec.W < 0 || vec.W > 255) {~\\
\cellcolor{red} & 0 & \verb~226~ & & \verb~                throw new ArgumentOutOfRangeException($"ARGB Color values must be between 0 and 255: {vec}");~\\
\cellcolor{gray} &  & \verb~227~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~228~ & & \verb~            color = System.Drawing.Color.FromArgb(vec.X, vec.Y, vec.Z, vec.W);~\\
\cellcolor{red} & 0 & \verb~229~ & & \verb~            CreateBitmapTexture();~\\
\cellcolor{red} & 0 & \verb~230~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~231~ & & \verb~~\\
\cellcolor{gray} &  & \verb~232~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~233~ & & \verb~        /// Change text color~\\
\cellcolor{gray} &  & \verb~234~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~235~ & & \verb~        /// <param name="vec">Vec3F containing the RGB color values.</param>~\\
\cellcolor{gray} &  & \verb~236~ & & \verb~        /// <exception cref="ArgumentOutOfRangeException">Normalized color values must be~\\
\cellcolor{gray} &  & \verb~237~ & & \verb~        /// between 0 and 1.</exception>~\\
\cellcolor{red} & 0 & \verb~238~ & & \verb~        public void SetColor(Vec4F vec) {~\\
\cellcolor{red} & 0 & \verb~239~ & & \verb~            if (vec.X < 0.0f || vec.X > 1.0f ||~\\
\cellcolor{red} & 0 & \verb~240~ & & \verb~                vec.Y < 0.0f || vec.Y > 1.0f ||~\\
\cellcolor{red} & 0 & \verb~241~ & & \verb~                vec.Z < 0.0f || vec.Z > 1.0f ||~\\
\cellcolor{red} & 0 & \verb~242~ & & \verb~                vec.W < 0.0f || vec.W > 1.0f) {~\\
\cellcolor{red} & 0 & \verb~243~ & & \verb~                throw new ArgumentOutOfRangeException($"ARGB Color values must be between 0 and 1: {vec}");~\\
\cellcolor{gray} &  & \verb~244~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~245~ & & \verb~            color = System.Drawing.Color.FromArgb((int)(vec.X * 255.0f), (int)(vec.Y * 255.0f), (int)(vec.Z * 255.0f), (~\\
\cellcolor{red} & 0 & \verb~246~ & & \verb~            CreateBitmapTexture();~\\
\cellcolor{red} & 0 & \verb~247~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~248~ & & \verb~~\\
\cellcolor{gray} &  & \verb~249~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~250~ & & \verb~        /// Change text color~\\
\cellcolor{gray} &  & \verb~251~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~252~ & & \verb~        /// <param name="newColor">System.Drawing.Color containing new color channel values.</param>~\\
\cellcolor{red} & 0 & \verb~253~ & & \verb~        public void SetColor(System.Drawing.Color newColor) {~\\
\cellcolor{red} & 0 & \verb~254~ & & \verb~            color = newColor;~\\
\cellcolor{red} & 0 & \verb~255~ & & \verb~            CreateBitmapTexture();~\\
\cellcolor{red} & 0 & \verb~256~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~257~ & & \verb~~\\
\cellcolor{gray} &  & \verb~258~ & & \verb~        #endregion~\\
\cellcolor{gray} &  & \verb~259~ & & \verb~~\\
\cellcolor{green} & 3 & \verb~260~ & & \verb~        private Matrix4 CreateMatrix() {~\\
\cellcolor{gray} &  & \verb~261~ & & \verb~            // ensure that rotation is performed around the center of the shape~\\
\cellcolor{gray} &  & \verb~262~ & & \verb~            // instead of the bottom-left corner~\\
\cellcolor{green} & 3 & \verb~263~ & & \verb~            var halfX = shape.Extent.X / 2.0f;~\\
\cellcolor{green} & 3 & \verb~264~ & & \verb~            var halfY = shape.Extent.Y / 2.0f;~\\
\cellcolor{gray} &  & \verb~265~ & & \verb~~\\
\cellcolor{green} & 3 & \verb~266~ & & \verb~            return Matrix4.CreateTranslation(-halfX, -halfY, 0.0f) *~\\
\cellcolor{green} & 3 & \verb~267~ & & \verb~                   Matrix4.CreateRotationZ(shape.Rotation) *~\\
\cellcolor{green} & 3 & \verb~268~ & & \verb~                   Matrix4.CreateTranslation(shape.Position.X + halfX, shape.Position.Y + halfY,~\\
\cellcolor{green} & 3 & \verb~269~ & & \verb~                       0.0f);~\\
\cellcolor{green} & 3 & \verb~270~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~271~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~272~ & & \verb~        public void ScaleText(float scale) {~\\
\cellcolor{red} & 0 & \verb~273~ & & \verb~            shape.Position *= scale;~\\
\cellcolor{red} & 0 & \verb~274~ & & \verb~            shape.Scale(scale);~\\
\cellcolor{red} & 0 & \verb~275~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~276~ & & \verb~~\\
\cellcolor{green} & 3 & \verb~277~ & & \verb~        public void RenderText() {~\\
\cellcolor{gray} &  & \verb~278~ & & \verb~            // bind this texture~\\
\cellcolor{green} & 3 & \verb~279~ & & \verb~            BindTexture();~\\
\cellcolor{gray} &  & \verb~280~ & & \verb~~\\
\cellcolor{gray} &  & \verb~281~ & & \verb~            // render this texture~\\
\cellcolor{green} & 3 & \verb~282~ & & \verb~            Matrix4 modelViewMatrix = CreateMatrix();~\\
\cellcolor{green} & 3 & \verb~283~ & & \verb~            GL.MatrixMode(MatrixMode.Modelview);~\\
\cellcolor{green} & 3 & \verb~284~ & & \verb~            GL.LoadMatrix(ref modelViewMatrix);~\\
\cellcolor{gray} &  & \verb~285~ & & \verb~~\\
\cellcolor{green} & 3 & \verb~286~ & & \verb~            GL.Color4(1f,1f,1f,1f);~\\
\cellcolor{green} & 3 & \verb~287~ & & \verb~            GL.Begin(PrimitiveType.Quads);~\\
\cellcolor{gray} &  & \verb~288~ & & \verb~~\\
\cellcolor{green} & 6 & \verb~289~ & & \verb~            GL.TexCoord2(0, 1); GL.Vertex2(0.0f, 0.0f);                      // Top Left~\\
\cellcolor{green} & 6 & \verb~290~ & & \verb~            GL.TexCoord2(0, 0); GL.Vertex2(0.0f, shape.Extent.Y);            // Bottom Left~\\
\cellcolor{green} & 6 & \verb~291~ & & \verb~            GL.TexCoord2(1, 0); GL.Vertex2(shape.Extent.X, shape.Extent.Y);  // Bottom Right~\\
\cellcolor{green} & 6 & \verb~292~ & & \verb~            GL.TexCoord2(1, 1); GL.Vertex2(shape.Extent.X, 0.0f);            // Top Right~\\
\cellcolor{gray} &  & \verb~293~ & & \verb~~\\
\cellcolor{green} & 3 & \verb~294~ & & \verb~            GL.End();~\\
\cellcolor{gray} &  & \verb~295~ & & \verb~~\\
\cellcolor{gray} &  & \verb~296~ & & \verb~            // unbind this texture~\\
\cellcolor{green} & 3 & \verb~297~ & & \verb~            UnbindTexture();~\\
\cellcolor{green} & 3 & \verb~298~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~299~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~300~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Graphics.Texture}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Graphics.Texture\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Graphics/Texture.cs}\end{minipage} \\
\textbf{Covered lines:} & 38\\
\textbf{Uncovered lines:} & 92\\
\textbf{Coverable lines:} & 130\\
\textbf{Total lines:} & 226\\
\textbf{Line coverage:} & 29.2\% (38 of 130)\\
\textbf{Covered branches:} & 3\\
\textbf{Total branches:} & 14\\
\textbf{Branch coverage:} & 21.4\% (3 of 14)\\
\textbf{Covered methods:} & 3\\
\textbf{Total methods:} & 8\\
\textbf{Method coverage:} & 37.5\% (3 of 8)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 75.00\% & 4 & 94.11\%\\
\hline
\textbf{.ctor(...)} & 0\% & 10 & 0\%\\
\hline
\textbf{BindTexture()} & 100\% & 1 & 100\%\\
\hline
\textbf{UnbindTexture()} & 100\% & 1 & 100\%\\
\hline
\textbf{CreateMatrix(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{CreateMatrix(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Render(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Render(...)} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Graphics/Texture.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using System.Drawing.Imaging;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using OpenTK.Mathematics;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~using OpenTK.Graphics.OpenGL;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~namespace DIKUArcade.Graphics {~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~    public class Texture {~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~        /// OpenGL texture handle~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~        public static double offsetX = 0.0;~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~        public static double offsetY = 0.0;~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~        private int textureId;~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~~\\
\cellcolor{green} & 10502 & \verb~17~ & & \verb~        public Texture(string filename) {~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~            // create a texture id~\\
\cellcolor{green} & 5251 & \verb~19~ & & \verb~            textureId = GL.GenTexture();~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~            // bind this new texture id~\\
\cellcolor{green} & 5251 & \verb~22~ & & \verb~            BindTexture();~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~            // find base path~\\
\cellcolor{green} & 5251 & \verb~25~ & & \verb~            var dir = new DirectoryInfo(Path.GetDirectoryName(~\\
\cellcolor{green} & 5251 & \verb~26~ & & \verb~                System.Reflection.Assembly.GetExecutingAssembly().Location));~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~~\\
\cellcolor{green} & 15753 & \verb~28~ & & \verb~            while (dir.Name != "bin")~\\
\cellcolor{green} & 10502 & \verb~29~ & & \verb~            {~\\
\cellcolor{green} & 10502 & \verb~30~ & & \verb~                dir = dir.Parent;~\\
\cellcolor{green} & 10502 & \verb~31~ & & \verb~            }~\\
\cellcolor{green} & 5251 & \verb~32~ & & \verb~            dir = dir.Parent;~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~~\\
\cellcolor{gray} &  & \verb~34~ & & \verb~            // load image file~\\
\cellcolor{green} & 5251 & \verb~35~ & & \verb~            var path = Path.Combine(dir.FullName.ToString(), filename);~\\
\cellcolor{orange} & 5251 & \verb~36~ & & \verb~            if (!File.Exists(path))~\\
\cellcolor{red} & 0 & \verb~37~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~38~ & & \verb~                throw new FileNotFoundException($"Error: The file \"{path}\" does not exist.");~\\
\cellcolor{gray} &  & \verb~39~ & & \verb~            }~\\
\cellcolor{green} & 5251 & \verb~40~ & & \verb~            System.Drawing.Bitmap image = new System.Drawing.Bitmap(path);~\\
\cellcolor{green} & 5251 & \verb~41~ & & \verb~            BitmapData data = image.LockBits(new System.Drawing.Rectangle(0, 0, image.Width, image.Height),~\\
\cellcolor{green} & 5251 & \verb~42~ & & \verb~                ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppPArgb);~\\
\cellcolor{gray} &  & \verb~43~ & & \verb~~\\
\cellcolor{gray} &  & \verb~44~ & & \verb~            // attach it to OpenGL context~\\
\cellcolor{green} & 5251 & \verb~45~ & & \verb~            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba,~\\
\cellcolor{green} & 5251 & \verb~46~ & & \verb~                data.Width, data.Height, 0, OpenTK.Graphics.OpenGL.PixelFormat.Bgra,~\\
\cellcolor{green} & 5251 & \verb~47~ & & \verb~                PixelType.UnsignedByte, data.Scan0);~\\
\cellcolor{gray} &  & \verb~48~ & & \verb~~\\
\cellcolor{green} & 5251 & \verb~49~ & & \verb~            image.UnlockBits(data);~\\
\cellcolor{gray} &  & \verb~50~ & & \verb~~\\
\cellcolor{gray} &  & \verb~51~ & & \verb~            // set texture properties, filters, blending functions, etc.~\\
\cellcolor{green} & 5251 & \verb~52~ & & \verb~            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter,~\\
\cellcolor{green} & 5251 & \verb~53~ & & \verb~                (int)TextureMinFilter.Linear);~\\
\cellcolor{green} & 5251 & \verb~54~ & & \verb~            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter,~\\
\cellcolor{green} & 5251 & \verb~55~ & & \verb~                (int)TextureMagFilter.Linear);~\\
\cellcolor{gray} &  & \verb~56~ & & \verb~~\\
\cellcolor{green} & 5251 & \verb~57~ & & \verb~            GL.Enable(EnableCap.Blend);~\\
\cellcolor{green} & 5251 & \verb~58~ & & \verb~            GL.BlendFunc(BlendingFactor.SrcAlpha, BlendingFactor.OneMinusSrcAlpha);~\\
\cellcolor{green} & 5251 & \verb~59~ & & \verb~            GL.Enable(EnableCap.DepthTest);~\\
\cellcolor{green} & 5251 & \verb~60~ & & \verb~            GL.DepthFunc(DepthFunction.Lequal);~\\
\cellcolor{gray} &  & \verb~61~ & & \verb~~\\
\cellcolor{green} & 5251 & \verb~62~ & & \verb~            GL.Enable(EnableCap.Texture2D);~\\
\cellcolor{green} & 5251 & \verb~63~ & & \verb~            GL.Enable(EnableCap.AlphaTest);~\\
\cellcolor{gray} &  & \verb~64~ & & \verb~~\\
\cellcolor{green} & 5251 & \verb~65~ & & \verb~            GL.AlphaFunc(AlphaFunction.Gequal, 0.5f);~\\
\cellcolor{gray} &  & \verb~66~ & & \verb~~\\
\cellcolor{gray} &  & \verb~67~ & & \verb~            // unbind the texture~\\
\cellcolor{green} & 5251 & \verb~68~ & & \verb~            UnbindTexture();~\\
\cellcolor{green} & 5251 & \verb~69~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~70~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~71~ & & \verb~        public Texture(string filename, int currentStride, int stridesInImage)~\\
\cellcolor{red} & 0 & \verb~72~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~73~ & & \verb~            if (currentStride < 0 || currentStride >= stridesInImage || stridesInImage < 0)~\\
\cellcolor{red} & 0 & \verb~74~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~75~ & & \verb~                throw new ArgumentOutOfRangeException(~\\
\cellcolor{red} & 0 & \verb~76~ & & \verb~                    $"Invalid stride numbers: ({currentStride}/{stridesInImage})");~\\
\cellcolor{gray} &  & \verb~77~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~78~ & & \verb~            // create a texture id~\\
\cellcolor{red} & 0 & \verb~79~ & & \verb~            textureId = GL.GenTexture();~\\
\cellcolor{gray} &  & \verb~80~ & & \verb~~\\
\cellcolor{gray} &  & \verb~81~ & & \verb~            // bind this new texture id~\\
\cellcolor{red} & 0 & \verb~82~ & & \verb~            BindTexture();~\\
\cellcolor{gray} &  & \verb~83~ & & \verb~~\\
\cellcolor{gray} &  & \verb~84~ & & \verb~            // find base path~\\
\cellcolor{red} & 0 & \verb~85~ & & \verb~            var dir = new DirectoryInfo(Path.GetDirectoryName(~\\
\cellcolor{red} & 0 & \verb~86~ & & \verb~                System.Reflection.Assembly.GetExecutingAssembly().Location));~\\
\cellcolor{gray} &  & \verb~87~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~88~ & & \verb~            while (dir.Name != "bin")~\\
\cellcolor{red} & 0 & \verb~89~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~90~ & & \verb~                dir = dir.Parent;~\\
\cellcolor{red} & 0 & \verb~91~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~92~ & & \verb~            dir = dir.Parent;~\\
\cellcolor{gray} &  & \verb~93~ & & \verb~~\\
\cellcolor{gray} &  & \verb~94~ & & \verb~            // load image file~\\
\cellcolor{red} & 0 & \verb~95~ & & \verb~            var path = Path.Combine(dir.FullName.ToString(), filename);~\\
\cellcolor{red} & 0 & \verb~96~ & & \verb~            if (!File.Exists(path))~\\
\cellcolor{red} & 0 & \verb~97~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~98~ & & \verb~                throw new FileNotFoundException($"Error: The file \"{path}\" does not exist.");~\\
\cellcolor{gray} &  & \verb~99~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~100~ & & \verb~            System.Drawing.Bitmap image = new System.Drawing.Bitmap(path);~\\
\cellcolor{red} & 0 & \verb~101~ & & \verb~            var width = (int)((float)image.Width / (float)stridesInImage);~\\
\cellcolor{red} & 0 & \verb~102~ & & \verb~            var posX = currentStride * width;~\\
\cellcolor{red} & 0 & \verb~103~ & & \verb~            BitmapData data = image.LockBits(new System.Drawing.Rectangle(posX, 0, width, image.Height),~\\
\cellcolor{red} & 0 & \verb~104~ & & \verb~                ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppPArgb);~\\
\cellcolor{gray} &  & \verb~105~ & & \verb~~\\
\cellcolor{gray} &  & \verb~106~ & & \verb~            // attach it to OpenGL context~\\
\cellcolor{red} & 0 & \verb~107~ & & \verb~            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba,~\\
\cellcolor{red} & 0 & \verb~108~ & & \verb~                data.Width, data.Height, 0, OpenTK.Graphics.OpenGL.PixelFormat.Bgra,~\\
\cellcolor{red} & 0 & \verb~109~ & & \verb~                PixelType.UnsignedByte, data.Scan0);~\\
\cellcolor{gray} &  & \verb~110~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~111~ & & \verb~            image.UnlockBits(data);~\\
\cellcolor{gray} &  & \verb~112~ & & \verb~~\\
\cellcolor{gray} &  & \verb~113~ & & \verb~            // set texture properties, filters, blending functions, etc.~\\
\cellcolor{red} & 0 & \verb~114~ & & \verb~            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter,~\\
\cellcolor{red} & 0 & \verb~115~ & & \verb~                (int)TextureMinFilter.Linear);~\\
\cellcolor{red} & 0 & \verb~116~ & & \verb~            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter,~\\
\cellcolor{red} & 0 & \verb~117~ & & \verb~                (int)TextureMagFilter.Linear);~\\
\cellcolor{gray} &  & \verb~118~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~119~ & & \verb~            GL.Enable(EnableCap.Blend);~\\
\cellcolor{red} & 0 & \verb~120~ & & \verb~            GL.BlendFunc(BlendingFactor.SrcAlpha, BlendingFactor.OneMinusSrcAlpha);~\\
\cellcolor{red} & 0 & \verb~121~ & & \verb~            GL.Enable(EnableCap.DepthTest);~\\
\cellcolor{red} & 0 & \verb~122~ & & \verb~            GL.DepthFunc(DepthFunction.Lequal);~\\
\cellcolor{gray} &  & \verb~123~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~124~ & & \verb~            GL.Enable(EnableCap.Texture2D);~\\
\cellcolor{red} & 0 & \verb~125~ & & \verb~            GL.Enable(EnableCap.AlphaTest);~\\
\cellcolor{gray} &  & \verb~126~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~127~ & & \verb~            GL.AlphaFunc(AlphaFunction.Gequal, 0.5f);~\\
\cellcolor{gray} &  & \verb~128~ & & \verb~~\\
\cellcolor{gray} &  & \verb~129~ & & \verb~            // unbind the texture~\\
\cellcolor{red} & 0 & \verb~130~ & & \verb~            UnbindTexture();~\\
\cellcolor{red} & 0 & \verb~131~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~132~ & & \verb~~\\
\cellcolor{gray} &  & \verb~133~ & & \verb~        private void BindTexture()~\\
\cellcolor{green} & 5251 & \verb~134~ & & \verb~        {~\\
\cellcolor{green} & 5251 & \verb~135~ & & \verb~            GL.BindTexture(TextureTarget.Texture2D, textureId);~\\
\cellcolor{green} & 5251 & \verb~136~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~137~ & & \verb~~\\
\cellcolor{gray} &  & \verb~138~ & & \verb~        private void UnbindTexture()~\\
\cellcolor{green} & 5251 & \verb~139~ & & \verb~        {~\\
\cellcolor{green} & 5251 & \verb~140~ & & \verb~            GL.BindTexture(TextureTarget.Texture2D, 0); // 0 is invalid texture id~\\
\cellcolor{green} & 5251 & \verb~141~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~142~ & & \verb~~\\
\cellcolor{gray} &  & \verb~143~ & & \verb~        private Matrix4 CreateMatrix(Shape shape)~\\
\cellcolor{red} & 0 & \verb~144~ & & \verb~        {~\\
\cellcolor{gray} &  & \verb~145~ & & \verb~            // ensure that rotation is performed around the center of the shape~\\
\cellcolor{gray} &  & \verb~146~ & & \verb~            // instead of the bottom-left corner~\\
\cellcolor{red} & 0 & \verb~147~ & & \verb~            var halfX = shape.Extent.X / 2.0f;~\\
\cellcolor{red} & 0 & \verb~148~ & & \verb~            var halfY = shape.Extent.Y / 2.0f;~\\
\cellcolor{gray} &  & \verb~149~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~150~ & & \verb~            return Matrix4.CreateTranslation(-halfX, -halfY, 0.0f) *~\\
\cellcolor{red} & 0 & \verb~151~ & & \verb~                   Matrix4.CreateRotationZ(shape.Rotation) *~\\
\cellcolor{red} & 0 & \verb~152~ & & \verb~                   Matrix4.CreateTranslation(shape.Position.X + halfX, shape.Position.Y + halfY,~\\
\cellcolor{red} & 0 & \verb~153~ & & \verb~                       0.0f);~\\
\cellcolor{red} & 0 & \verb~154~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~155~ & & \verb~~\\
\cellcolor{gray} &  & \verb~156~ & & \verb~        // Render things that are affected by a camera (if the game has one)~\\
\cellcolor{gray} &  & \verb~157~ & & \verb~        private Matrix4 CreateMatrix(Shape shape, Camera camera)~\\
\cellcolor{red} & 0 & \verb~158~ & & \verb~        {~\\
\cellcolor{gray} &  & \verb~159~ & & \verb~            // ensure that rotation is performed around the center of the shape~\\
\cellcolor{gray} &  & \verb~160~ & & \verb~            // instead of the bottom-left corner~\\
\cellcolor{red} & 0 & \verb~161~ & & \verb~            var halfX = shape.Extent.X / 2.0f;~\\
\cellcolor{red} & 0 & \verb~162~ & & \verb~            var halfY = shape.Extent.Y / 2.0f;~\\
\cellcolor{gray} &  & \verb~163~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~164~ & & \verb~            return Matrix4.CreateTranslation(~\\
\cellcolor{red} & 0 & \verb~165~ & & \verb~                -halfX - camera.Offset.X,~\\
\cellcolor{red} & 0 & \verb~166~ & & \verb~                -halfY - camera.Offset.Y,~\\
\cellcolor{red} & 0 & \verb~167~ & & \verb~                0.0f) *~\\
\cellcolor{red} & 0 & \verb~168~ & & \verb~                   Matrix4.CreateRotationZ(shape.Rotation) *~\\
\cellcolor{red} & 0 & \verb~169~ & & \verb~                   Matrix4.CreateTranslation(shape.Position.X + halfX + camera.Offset.X,~\\
\cellcolor{red} & 0 & \verb~170~ & & \verb~                    shape.Position.Y + halfY + camera.Offset.Y,~\\
\cellcolor{red} & 0 & \verb~171~ & & \verb~                       0.0f);~\\
\cellcolor{red} & 0 & \verb~172~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~173~ & & \verb~~\\
\cellcolor{gray} &  & \verb~174~ & & \verb~        public void Render(Shape shape, Camera camera)~\\
\cellcolor{red} & 0 & \verb~175~ & & \verb~        {~\\
\cellcolor{gray} &  & \verb~176~ & & \verb~~\\
\cellcolor{gray} &  & \verb~177~ & & \verb~            // bind this texture~\\
\cellcolor{red} & 0 & \verb~178~ & & \verb~            BindTexture();~\\
\cellcolor{gray} &  & \verb~179~ & & \verb~~\\
\cellcolor{gray} &  & \verb~180~ & & \verb~            // render this texture~\\
\cellcolor{red} & 0 & \verb~181~ & & \verb~            Matrix4 modelViewMatrix = CreateMatrix(shape, camera);~\\
\cellcolor{red} & 0 & \verb~182~ & & \verb~            GL.MatrixMode(MatrixMode.Modelview);~\\
\cellcolor{red} & 0 & \verb~183~ & & \verb~            GL.LoadMatrix(ref modelViewMatrix);~\\
\cellcolor{gray} &  & \verb~184~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~185~ & & \verb~            GL.Translate(camera.Offset.X, camera.Offset.Y, 0);~\\
\cellcolor{gray} &  & \verb~186~ & & \verb~            //GL.Scale(camera.Scale, camera.Scale, 1f);~\\
\cellcolor{red} & 0 & \verb~187~ & & \verb~            GL.Color4(1f, 1f, 1f, 1f);~\\
\cellcolor{red} & 0 & \verb~188~ & & \verb~            GL.Begin(PrimitiveType.Quads);~\\
\cellcolor{gray} &  & \verb~189~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~190~ & & \verb~            GL.TexCoord2(0, 1); GL.Vertex2(0.0f, 0.0f);                      // Top Left~\\
\cellcolor{red} & 0 & \verb~191~ & & \verb~            GL.TexCoord2(0, 0); GL.Vertex2(0.0f, shape.Extent.Y);            // Bottom Left~\\
\cellcolor{red} & 0 & \verb~192~ & & \verb~            GL.TexCoord2(1, 0); GL.Vertex2(shape.Extent.X, shape.Extent.Y);  // Bottom Right~\\
\cellcolor{red} & 0 & \verb~193~ & & \verb~            GL.TexCoord2(1, 1); GL.Vertex2(shape.Extent.X, 0.0f);            // Top Right~\\
\cellcolor{gray} &  & \verb~194~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~195~ & & \verb~            GL.End();~\\
\cellcolor{gray} &  & \verb~196~ & & \verb~~\\
\cellcolor{gray} &  & \verb~197~ & & \verb~            // unbind this texture~\\
\cellcolor{red} & 0 & \verb~198~ & & \verb~            UnbindTexture();~\\
\cellcolor{red} & 0 & \verb~199~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~200~ & & \verb~~\\
\cellcolor{gray} &  & \verb~201~ & & \verb~        public void Render(Shape shape)~\\
\cellcolor{red} & 0 & \verb~202~ & & \verb~        {~\\
\cellcolor{gray} &  & \verb~203~ & & \verb~~\\
\cellcolor{gray} &  & \verb~204~ & & \verb~            // bind this texture~\\
\cellcolor{red} & 0 & \verb~205~ & & \verb~            BindTexture();~\\
\cellcolor{gray} &  & \verb~206~ & & \verb~~\\
\cellcolor{gray} &  & \verb~207~ & & \verb~            // render this texture~\\
\cellcolor{red} & 0 & \verb~208~ & & \verb~            Matrix4 modelViewMatrix = CreateMatrix(shape);~\\
\cellcolor{red} & 0 & \verb~209~ & & \verb~            GL.MatrixMode(MatrixMode.Modelview);~\\
\cellcolor{red} & 0 & \verb~210~ & & \verb~            GL.LoadMatrix(ref modelViewMatrix);~\\
\cellcolor{gray} &  & \verb~211~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~212~ & & \verb~            GL.Color4(1f, 1f, 1f, 1f);~\\
\cellcolor{red} & 0 & \verb~213~ & & \verb~            GL.Begin(PrimitiveType.Quads);~\\
\cellcolor{gray} &  & \verb~214~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~215~ & & \verb~            GL.TexCoord2(0, 1); GL.Vertex2(0.0f, 0.0f);                      // Top Left~\\
\cellcolor{red} & 0 & \verb~216~ & & \verb~            GL.TexCoord2(0, 0); GL.Vertex2(0.0f, shape.Extent.Y);            // Bottom Left~\\
\cellcolor{red} & 0 & \verb~217~ & & \verb~            GL.TexCoord2(1, 0); GL.Vertex2(shape.Extent.X, shape.Extent.Y);  // Bottom Right~\\
\cellcolor{red} & 0 & \verb~218~ & & \verb~            GL.TexCoord2(1, 1); GL.Vertex2(shape.Extent.X, 0.0f);            // Top Right~\\
\cellcolor{gray} &  & \verb~219~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~220~ & & \verb~            GL.End();~\\
\cellcolor{gray} &  & \verb~221~ & & \verb~~\\
\cellcolor{gray} &  & \verb~222~ & & \verb~            // unbind this texture~\\
\cellcolor{red} & 0 & \verb~223~ & & \verb~            UnbindTexture();~\\
\cellcolor{red} & 0 & \verb~224~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~225~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~226~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.GUI.Window}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.GUI.Window\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/GUI/Window.cs}\end{minipage} \\
\textbf{Covered lines:} & 6\\
\textbf{Uncovered lines:} & 172\\
\textbf{Coverable lines:} & 178\\
\textbf{Total lines:} & 377\\
\textbf{Line coverage:} & 3.3\% (6 of 178)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 74\\
\textbf{Branch coverage:} & 0\% (0 of 74)\\
\textbf{Covered methods:} & 1\\
\textbf{Total methods:} & 26\\
\textbf{Method coverage:} & 3.8\% (1 of 26)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{get\_Title()} & 100\% & 1 & 0\%\\
\hline
\textbf{set\_Title(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{get\_Resizable()} & 100\% & 1 & 0\%\\
\hline
\textbf{CreateOpenGLContext(} & 100\% & 1 & 100\%\\
\hline
\textbf{ActivateThisWindowCo} & 100\% & 1 & 0\%\\
\hline
\textbf{.ctor(...)} & 0\% & 10 & 0\%\\
\hline
\textbf{Finalize()} & 0\% & 2 & 0\%\\
\hline
\textbf{DefaultResizeHandler} & 0\% & 2 & 0\%\\
\hline
\textbf{AddDefaultResizeHand} & 100\% & 1 & 0\%\\
\hline
\textbf{RemoveDefaultResizeH} & 100\% & 1 & 0\%\\
\hline
\textbf{DefaultKeyEventHandl} & 0\% & 4 & 0\%\\
\hline
\textbf{AddDefaultKeyEventHa} & 100\% & 1 & 0\%\\
\hline
\textbf{RemoveDefaultKeyEven} & 100\% & 1 & 0\%\\
\hline
\textbf{SetKeyEventHandler(.} & 0\% & 2 & 0\%\\
\hline
\textbf{IsRunning()} & 100\% & 1 & 0\%\\
\hline
\textbf{CloseWindow()} & 100\% & 1 & 0\%\\
\hline
\textbf{DestroyWindow()} & 100\% & 1 & 0\%\\
\hline
\textbf{Clear()} & 100\% & 1 & 0\%\\
\hline
\textbf{SetClearColor(...)} & 0\% & 12 & 0\%\\
\hline
\textbf{SetClearColor(...)} & 0\% & 12 & 0\%\\
\hline
\textbf{SetClearColor(...)} & 0\% & 12 & 0\%\\
\hline
\textbf{SetClearColor(...)} & 0\% & 12 & 0\%\\
\hline
\textbf{SetClearColor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{SwapBuffers()} & 100\% & 1 & 0\%\\
\hline
\textbf{PollEvents()} & 100\% & 1 & 0\%\\
\hline
\textbf{SaveScreenShot()} & 0\% & 6 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/GUI/Window.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using PixelFormat = System.Drawing.Imaging.PixelFormat;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using Bitmap = System.Drawing.Bitmap;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using RotateFlipType = System.Drawing.RotateFlipType;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~using System.Drawing.Imaging;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~using OpenTK.Windowing.Desktop;~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~using OpenTK.Windowing.Common;~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~using OpenTK.Graphics.OpenGL;~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~using DIKUArcade.Input;~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~namespace DIKUArcade.GUI {~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~    /// This class represents a graphical window in the DIKUArcade game engine.~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~    public class Window {~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~        private static uint screenShotCounter;~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~        /// Every DIKUArcade.Window instance has its own private~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~        /// OpenTK.GameWindow object.~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~        private GameWindow window;~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~        private bool isRunning;~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~        public string Title {~\\
\cellcolor{red} & 0 & \verb~28~ & & \verb~            get { return window.Title; }~\\
\cellcolor{red} & 0 & \verb~29~ & & \verb~            set { window.Title = value; }~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~~\\
\cellcolor{gray} &  & \verb~32~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~        /// Get or set if this Window instance should be resizable.~\\
\cellcolor{gray} &  & \verb~34~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~35~ & & \verb~        public bool Resizable { get; set; } = true;~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~38~ & & \verb~        /// Instance for transforming OpenTK key events to DIKUArcade-interfaced~\\
\cellcolor{gray} &  & \verb~39~ & & \verb~        /// key events, based on globalization settings.~\\
\cellcolor{gray} &  & \verb~40~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~        private IKeyTransformer keyTransformer;~\\
\cellcolor{gray} &  & \verb~42~ & & \verb~~\\
\cellcolor{gray} &  & \verb~43~ & & \verb~~\\
\cellcolor{gray} &  & \verb~44~ & & \verb~        #region OpenGLContext~\\
\cellcolor{gray} &  & \verb~45~ & & \verb~~\\
\cellcolor{gray} &  & \verb~46~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~47~ & & \verb~        /// A static, private OpenTK.GameWindow instance.~\\
\cellcolor{gray} &  & \verb~48~ & & \verb~        /// Only used for initializing an OpenGL context in the background.~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~50~ & & \verb~        private static GameWindow _contextWin;~\\
\cellcolor{gray} &  & \verb~51~ & & \verb~~\\
\cellcolor{gray} &  & \verb~52~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~53~ & & \verb~        /// Use this method to create an OpenGL context.~\\
\cellcolor{gray} &  & \verb~54~ & & \verb~        /// Never use this method in your application, ONLY in unit testing.~\\
\cellcolor{gray} &  & \verb~55~ & & \verb~        /// This will enable you to unit test classes which use OpenGL-dependent~\\
\cellcolor{gray} &  & \verb~56~ & & \verb~        /// function calls, including `Text', `Image', and `ImageStride' classes.~\\
\cellcolor{gray} &  & \verb~57~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 1 & \verb~58~ & & \verb~        public static void CreateOpenGLContext() {~\\
\cellcolor{green} & 1 & \verb~59~ & & \verb~            var settings = new GameWindowSettings();~\\
\cellcolor{green} & 1 & \verb~60~ & & \verb~            var nativeSettings = new NativeWindowSettings();~\\
\cellcolor{green} & 1 & \verb~61~ & & \verb~            Window._contextWin = new GameWindow(settings, nativeSettings);~\\
\cellcolor{green} & 1 & \verb~62~ & & \verb~            Window._contextWin.Context.MakeCurrent();~\\
\cellcolor{green} & 1 & \verb~63~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~64~ & & \verb~~\\
\cellcolor{gray} &  & \verb~65~ & & \verb~        #endregion~\\
\cellcolor{gray} &  & \verb~66~ & & \verb~~\\
\cellcolor{gray} &  & \verb~67~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~68~ & & \verb~        private void ActivateThisWindowContext(string title, uint width, uint height, bool fullscreen) {~\\
\cellcolor{gray} &  & \verb~69~ & & \verb~            // We use OpenGL 2.0 (ie. fixed-function pipeline!)~\\
\cellcolor{red} & 0 & \verb~70~ & & \verb~            var settings = new GameWindowSettings();~\\
\cellcolor{red} & 0 & \verb~71~ & & \verb~            settings.IsMultiThreaded = false;~\\
\cellcolor{red} & 0 & \verb~72~ & & \verb~            var nativeSettings = new NativeWindowSettings();~\\
\cellcolor{red} & 0 & \verb~73~ & & \verb~            nativeSettings.Profile = ContextProfile.Any;~\\
\cellcolor{red} & 0 & \verb~74~ & & \verb~            nativeSettings.WindowState = WindowState.Normal;~\\
\cellcolor{red} & 0 & \verb~75~ & & \verb~            nativeSettings.API = ContextAPI.OpenGL;~\\
\cellcolor{red} & 0 & \verb~76~ & & \verb~            nativeSettings.APIVersion = new Version(2, 0);~\\
\cellcolor{red} & 0 & \verb~77~ & & \verb~            nativeSettings.IsFullscreen = fullscreen;~\\
\cellcolor{gray} &  & \verb~78~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~79~ & & \verb~            window = new GameWindow(settings, nativeSettings) {~\\
\cellcolor{red} & 0 & \verb~80~ & & \verb~                Title = title,~\\
\cellcolor{red} & 0 & \verb~81~ & & \verb~                Size = new OpenTK.Mathematics.Vector2i((int)width, (int)height)~\\
\cellcolor{red} & 0 & \verb~82~ & & \verb~            };~\\
\cellcolor{gray} &  & \verb~83~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~84~ & & \verb~            GL.ClearDepth(1);~\\
\cellcolor{red} & 0 & \verb~85~ & & \verb~            GL.ClearColor(0.0f, 0.0f, 0.0f, 1.0f);~\\
\cellcolor{gray} &  & \verb~86~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~87~ & & \verb~            isRunning = true;~\\
\cellcolor{red} & 0 & \verb~88~ & & \verb~            window.Context.MakeCurrent();~\\
\cellcolor{red} & 0 & \verb~89~ & & \verb~            window.IsVisible = true;~\\
\cellcolor{gray} &  & \verb~90~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~91~ & & \verb~            GL.Viewport(0, 0, window.Size.X, window.Size.Y);~\\
\cellcolor{red} & 0 & \verb~92~ & & \verb~            GL.MatrixMode(MatrixMode.Projection);~\\
\cellcolor{red} & 0 & \verb~93~ & & \verb~            GL.LoadIdentity();~\\
\cellcolor{red} & 0 & \verb~94~ & & \verb~            GL.Ortho(0.0,1.0,0.0,1.0, 0.0, 4.0);~\\
\cellcolor{red} & 0 & \verb~95~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~96~ & & \verb~~\\
\cellcolor{gray} &  & \verb~97~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~98~ & & \verb~        public Window(WindowArgs windowArgs) {~\\
\cellcolor{gray} &  & \verb~99~ & & \verb~            // keyboard layout~\\
\cellcolor{red} & 0 & \verb~100~ & & \verb~            switch(windowArgs.KeyboardLayout) {~\\
\cellcolor{gray} &  & \verb~101~ & & \verb~                case KeyboardLayout.Danish:~\\
\cellcolor{red} & 0 & \verb~102~ & & \verb~                    keyTransformer = new Input.Languages.DanishKeyTransformer();~\\
\cellcolor{red} & 0 & \verb~103~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~104~ & & \verb~                default:~\\
\cellcolor{red} & 0 & \verb~105~ & & \verb~                    throw new ArgumentException("Window(): only Danish keyboard layout is currently supported!");~\\
\cellcolor{gray} &  & \verb~106~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~107~ & & \verb~~\\
\cellcolor{gray} &  & \verb~108~ & & \verb~            // window dimensions~\\
\cellcolor{red} & 0 & \verb~109~ & & \verb~            uint width = windowArgs.Width;~\\
\cellcolor{red} & 0 & \verb~110~ & & \verb~            uint height = windowArgs.Height;~\\
\cellcolor{red} & 0 & \verb~111~ & & \verb~            switch (windowArgs.AspectRatio) {~\\
\cellcolor{gray} &  & \verb~112~ & & \verb~                case WindowAspectRatio.Aspect_Custom:~\\
\cellcolor{red} & 0 & \verb~113~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~114~ & & \verb~                case WindowAspectRatio.Aspect_1X1:~\\
\cellcolor{red} & 0 & \verb~115~ & & \verb~                    width = height;~\\
\cellcolor{red} & 0 & \verb~116~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~117~ & & \verb~                case WindowAspectRatio.Aspect_3X2:~\\
\cellcolor{red} & 0 & \verb~118~ & & \verb~                    width = (height * 3) / 2;~\\
\cellcolor{red} & 0 & \verb~119~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~120~ & & \verb~                case WindowAspectRatio.Aspect_4X3:~\\
\cellcolor{red} & 0 & \verb~121~ & & \verb~                    width = (height * 4) / 3;~\\
\cellcolor{red} & 0 & \verb~122~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~123~ & & \verb~                case WindowAspectRatio.Aspect_16X9:~\\
\cellcolor{red} & 0 & \verb~124~ & & \verb~                    width = (height * 16) / 9;~\\
\cellcolor{red} & 0 & \verb~125~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~126~ & & \verb~                default:~\\
\cellcolor{red} & 0 & \verb~127~ & & \verb~                    throw new ArgumentException("Window(): invalid aspect ratio!");~\\
\cellcolor{gray} &  & \verb~128~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~129~ & & \verb~~\\
\cellcolor{gray} &  & \verb~130~ & & \verb~            // create and bind OpenGL context~\\
\cellcolor{red} & 0 & \verb~131~ & & \verb~            ActivateThisWindowContext(windowArgs.Title, width, height, windowArgs.FullScreen);~\\
\cellcolor{gray} &  & \verb~132~ & & \verb~~\\
\cellcolor{gray} &  & \verb~133~ & & \verb~            // setup event handlers~\\
\cellcolor{red} & 0 & \verb~134~ & & \verb~            if (windowArgs.Resizable) {~\\
\cellcolor{red} & 0 & \verb~135~ & & \verb~                AddDefaultResizeHandler();~\\
\cellcolor{red} & 0 & \verb~136~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~137~ & & \verb~            AddDefaultKeyEventHandler();~\\
\cellcolor{red} & 0 & \verb~138~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~139~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~140~ & & \verb~         Window() {~\\
\cellcolor{red} & 0 & \verb~141~ & & \verb~            if (window != null) this.DestroyWindow();~\\
\cellcolor{red} & 0 & \verb~142~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~143~ & & \verb~~\\
\cellcolor{gray} &  & \verb~144~ & & \verb~~\\
\cellcolor{gray} &  & \verb~145~ & & \verb~        #region WINDOW_RESIZE~\\
\cellcolor{gray} &  & \verb~146~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~147~ & & \verb~        private void DefaultResizeHandler(ResizeEventArgs args) {~\\
\cellcolor{red} & 0 & \verb~148~ & & \verb~            if (!Resizable) {~\\
\cellcolor{red} & 0 & \verb~149~ & & \verb~                return;~\\
\cellcolor{gray} &  & \verb~150~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~151~ & & \verb~~\\
\cellcolor{gray} &  & \verb~152~ & & \verb~            // GL.Viewport(0, 0, window.Size.X, window.Size.Y);~\\
\cellcolor{red} & 0 & \verb~153~ & & \verb~            GL.Viewport(0, 0, args.Size.X, args.Size.Y); // TODO: Is that right?~\\
\cellcolor{red} & 0 & \verb~154~ & & \verb~            GL.MatrixMode(MatrixMode.Projection);~\\
\cellcolor{red} & 0 & \verb~155~ & & \verb~            GL.LoadIdentity();~\\
\cellcolor{red} & 0 & \verb~156~ & & \verb~            GL.Ortho(0.0, 1.0, 0.0, 1.0, 0.0, 4.0);~\\
\cellcolor{red} & 0 & \verb~157~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~158~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~159~ & & \verb~        private void AddDefaultResizeHandler() {~\\
\cellcolor{red} & 0 & \verb~160~ & & \verb~            window.Resize += DefaultResizeHandler;~\\
\cellcolor{red} & 0 & \verb~161~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~162~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~163~ & & \verb~        private void RemoveDefaultResizeHandler() {~\\
\cellcolor{red} & 0 & \verb~164~ & & \verb~            window.Resize -= DefaultResizeHandler;~\\
\cellcolor{red} & 0 & \verb~165~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~166~ & & \verb~~\\
\cellcolor{gray} &  & \verb~167~ & & \verb~        #endregion WINDOW_RESIZE~\\
\cellcolor{gray} &  & \verb~168~ & & \verb~~\\
\cellcolor{gray} &  & \verb~169~ & & \verb~        #region KEY_EVENT_HANDLERS~\\
\cellcolor{gray} &  & \verb~170~ & & \verb~~\\
\cellcolor{gray} &  & \verb~171~ & & \verb~~\\
\cellcolor{gray} &  & \verb~172~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~173~ & & \verb~        private void DefaultKeyEventHandler(KeyboardKeyEventArgs args) {~\\
\cellcolor{red} & 0 & \verb~174~ & & \verb~            switch(args.Key) {~\\
\cellcolor{gray} &  & \verb~175~ & & \verb~                case OpenTK.Windowing.GraphicsLibraryFramework.Keys.Escape:~\\
\cellcolor{red} & 0 & \verb~176~ & & \verb~                    CloseWindow();~\\
\cellcolor{red} & 0 & \verb~177~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~178~ & & \verb~                case OpenTK.Windowing.GraphicsLibraryFramework.Keys.F12:~\\
\cellcolor{red} & 0 & \verb~179~ & & \verb~                    SaveScreenShot();~\\
\cellcolor{red} & 0 & \verb~180~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~181~ & & \verb~                default:~\\
\cellcolor{red} & 0 & \verb~182~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~183~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~184~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~185~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~186~ & & \verb~        private void AddDefaultKeyEventHandler() {~\\
\cellcolor{red} & 0 & \verb~187~ & & \verb~            window.KeyDown += DefaultKeyEventHandler;~\\
\cellcolor{red} & 0 & \verb~188~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~189~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~190~ & & \verb~        private void RemoveDefaultKeyEventHandler() {~\\
\cellcolor{red} & 0 & \verb~191~ & & \verb~            window.KeyDown -= DefaultKeyEventHandler;~\\
\cellcolor{red} & 0 & \verb~192~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~193~ & & \verb~~\\
\cellcolor{gray} &  & \verb~194~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~195~ & & \verb~        /// Attach the specified keyHandler method argument to this window object.~\\
\cellcolor{gray} &  & \verb~196~ & & \verb~        /// All key inputs will thereafter be directed to this keyHandler.~\\
\cellcolor{gray} &  & \verb~197~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~198~ & & \verb~        public void SetKeyEventHandler(Action<KeyboardAction,KeyboardKey> keyHandler) {~\\
\cellcolor{red} & 0 & \verb~199~ & & \verb~            RemoveDefaultKeyEventHandler();~\\
\cellcolor{red} & 0 & \verb~200~ & & \verb~            window.KeyDown += args => {~\\
\cellcolor{red} & 0 & \verb~201~ & & \verb~                if (!args.IsRepeat) keyHandler(KeyboardAction.KeyPress, keyTransformer.TransformKey(args.Key));~\\
\cellcolor{red} & 0 & \verb~202~ & & \verb~            };~\\
\cellcolor{red} & 0 & \verb~203~ & & \verb~            window.KeyUp += args => {~\\
\cellcolor{red} & 0 & \verb~204~ & & \verb~                keyHandler(KeyboardAction.KeyRelease, keyTransformer.TransformKey(args.Key));~\\
\cellcolor{red} & 0 & \verb~205~ & & \verb~            };~\\
\cellcolor{red} & 0 & \verb~206~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~207~ & & \verb~~\\
\cellcolor{gray} &  & \verb~208~ & & \verb~        #endregion KEY_EVENT_HANDLERS~\\
\cellcolor{gray} &  & \verb~209~ & & \verb~~\\
\cellcolor{gray} &  & \verb~210~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~211~ & & \verb~        /// Check if the Window is still running.~\\
\cellcolor{gray} &  & \verb~212~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~213~ & & \verb~        public bool IsRunning() {~\\
\cellcolor{red} & 0 & \verb~214~ & & \verb~            return isRunning;~\\
\cellcolor{red} & 0 & \verb~215~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~216~ & & \verb~~\\
\cellcolor{gray} &  & \verb~217~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~218~ & & \verb~        /// Sets the window running variable to false such that calls to~\\
\cellcolor{gray} &  & \verb~219~ & & \verb~        /// `IsRunning()` afterwards will return false. This will allow one~\\
\cellcolor{gray} &  & \verb~220~ & & \verb~        /// to exit the game loop.~\\
\cellcolor{gray} &  & \verb~221~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~222~ & & \verb~        public void CloseWindow() {~\\
\cellcolor{red} & 0 & \verb~223~ & & \verb~            isRunning = false;~\\
\cellcolor{red} & 0 & \verb~224~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~225~ & & \verb~~\\
\cellcolor{gray} &  & \verb~226~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~227~ & & \verb~        /// Close the underlying OpenTK window object.~\\
\cellcolor{gray} &  & \verb~228~ & & \verb~        /// Do not call this method outside the engine.~\\
\cellcolor{gray} &  & \verb~229~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~230~ & & \verb~        internal void DestroyWindow() {~\\
\cellcolor{red} & 0 & \verb~231~ & & \verb~            window.Close();~\\
\cellcolor{red} & 0 & \verb~232~ & & \verb~            window.Dispose();~\\
\cellcolor{red} & 0 & \verb~233~ & & \verb~            window = null;~\\
\cellcolor{red} & 0 & \verb~234~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~235~ & & \verb~~\\
\cellcolor{gray} &  & \verb~236~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~237~ & & \verb~        /// Clear the Window with a uniform background color.~\\
\cellcolor{gray} &  & \verb~238~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~239~ & & \verb~        public void Clear() {~\\
\cellcolor{red} & 0 & \verb~240~ & & \verb~            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);~\\
\cellcolor{red} & 0 & \verb~241~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~242~ & & \verb~~\\
\cellcolor{gray} &  & \verb~243~ & & \verb~        #region SET_CLEAR_COLOR~\\
\cellcolor{gray} &  & \verb~244~ & & \verb~~\\
\cellcolor{gray} &  & \verb~245~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~246~ & & \verb~        /// Set color to be used as clear color when using the Window.Clear() method.~\\
\cellcolor{gray} &  & \verb~247~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~248~ & & \verb~        /// <param name="vec">Vec3F containing the RGB color values.</param>~\\
\cellcolor{gray} &  & \verb~249~ & & \verb~        /// <exception cref="ArgumentOutOfRangeException">Normalized color values must be~\\
\cellcolor{gray} &  & \verb~250~ & & \verb~        /// between 0 and 1.</exception>~\\
\cellcolor{red} & 0 & \verb~251~ & & \verb~        public void SetClearColor(Math.Vec3F vec) {~\\
\cellcolor{red} & 0 & \verb~252~ & & \verb~            if (vec.X < 0.0f || vec.X > 1.0f ||~\\
\cellcolor{red} & 0 & \verb~253~ & & \verb~                vec.Y < 0.0f || vec.Y > 1.0f ||~\\
\cellcolor{red} & 0 & \verb~254~ & & \verb~                vec.Z < 0.0f || vec.Z > 1.0f) {~\\
\cellcolor{red} & 0 & \verb~255~ & & \verb~                throw new ArgumentOutOfRangeException(~\\
\cellcolor{red} & 0 & \verb~256~ & & \verb~                    $"Normalized RGB Color values must be between 0 and 1: {vec}");~\\
\cellcolor{gray} &  & \verb~257~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~258~ & & \verb~            GL.ClearColor(vec.X, vec.Y, vec.Z, 1.0f);~\\
\cellcolor{red} & 0 & \verb~259~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~260~ & & \verb~~\\
\cellcolor{gray} &  & \verb~261~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~262~ & & \verb~        /// Set color to be used as clear color when using the Window.Clear() method.~\\
\cellcolor{gray} &  & \verb~263~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~264~ & & \verb~        /// <param name="vec">Vec3I containing the RGB color values.</param>~\\
\cellcolor{gray} &  & \verb~265~ & & \verb~        /// <exception cref="ArgumentOutOfRangeException">Color values must be between 0 and 255.</exception>~\\
\cellcolor{red} & 0 & \verb~266~ & & \verb~        public void SetClearColor(Math.Vec3I vec) {~\\
\cellcolor{red} & 0 & \verb~267~ & & \verb~            if (vec.X < 0 || vec.X > 255 ||~\\
\cellcolor{red} & 0 & \verb~268~ & & \verb~                vec.Y < 0 || vec.Y > 255 ||~\\
\cellcolor{red} & 0 & \verb~269~ & & \verb~                vec.Z < 0 || vec.Z > 255) {~\\
\cellcolor{red} & 0 & \verb~270~ & & \verb~                throw new ArgumentOutOfRangeException(~\\
\cellcolor{red} & 0 & \verb~271~ & & \verb~                    $"RGB Color values must be between 0 and 255: {vec}");~\\
\cellcolor{gray} &  & \verb~272~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~273~ & & \verb~            GL.ClearColor(vec.X / 255.0f, vec.Y / 255.0f, vec.Z / 255.0f, 1.0f);~\\
\cellcolor{red} & 0 & \verb~274~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~275~ & & \verb~~\\
\cellcolor{gray} &  & \verb~276~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~277~ & & \verb~        /// Set color to be used as clear color when using the Window.Clear() method.~\\
\cellcolor{gray} &  & \verb~278~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~279~ & & \verb~        /// <param name="r">red channel value</param>~\\
\cellcolor{gray} &  & \verb~280~ & & \verb~        /// <param name="g">green channel value</param>~\\
\cellcolor{gray} &  & \verb~281~ & & \verb~        /// <param name="b">blue channel value</param>~\\
\cellcolor{gray} &  & \verb~282~ & & \verb~        /// <exception cref="ArgumentOutOfRangeException">Normalized color values must be~\\
\cellcolor{gray} &  & \verb~283~ & & \verb~        /// between 0 and 1.</exception>~\\
\cellcolor{red} & 0 & \verb~284~ & & \verb~        public void SetClearColor(float r, float g, float b) {~\\
\cellcolor{red} & 0 & \verb~285~ & & \verb~            if (r < 0.0f || r > 1.0f ||~\\
\cellcolor{red} & 0 & \verb~286~ & & \verb~                g < 0.0f || g > 1.0f ||~\\
\cellcolor{red} & 0 & \verb~287~ & & \verb~                b < 0.0f || b > 1.0f) {~\\
\cellcolor{red} & 0 & \verb~288~ & & \verb~                throw new ArgumentOutOfRangeException(~\\
\cellcolor{red} & 0 & \verb~289~ & & \verb~                    $"Normalized RGB Color values must be between 0 and 1: ({r},{g},{b})");~\\
\cellcolor{gray} &  & \verb~290~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~291~ & & \verb~            GL.ClearColor(r, g, b, 1.0f);~\\
\cellcolor{red} & 0 & \verb~292~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~293~ & & \verb~~\\
\cellcolor{gray} &  & \verb~294~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~295~ & & \verb~        /// Set color to be used as clear color when using the Window.Clear() method.~\\
\cellcolor{gray} &  & \verb~296~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~297~ & & \verb~        /// <param name="r">red channel value</param>~\\
\cellcolor{gray} &  & \verb~298~ & & \verb~        /// <param name="g">green channel value</param>~\\
\cellcolor{gray} &  & \verb~299~ & & \verb~        /// <param name="b">blue channel value</param>~\\
\cellcolor{gray} &  & \verb~300~ & & \verb~        /// <exception cref="ArgumentOutOfRangeException">Color values must be between 0 and 255.</exception>~\\
\cellcolor{red} & 0 & \verb~301~ & & \verb~        public void SetClearColor(int r, int g, int b) {~\\
\cellcolor{red} & 0 & \verb~302~ & & \verb~            if (r < 0 || r > 255 ||~\\
\cellcolor{red} & 0 & \verb~303~ & & \verb~                g < 0 || g > 255 ||~\\
\cellcolor{red} & 0 & \verb~304~ & & \verb~                b < 0 || b > 255) {~\\
\cellcolor{red} & 0 & \verb~305~ & & \verb~                throw new ArgumentOutOfRangeException(~\\
\cellcolor{red} & 0 & \verb~306~ & & \verb~                    $"RGB Color values must be between 0 and 255: ({r},{g},{b})");~\\
\cellcolor{gray} &  & \verb~307~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~308~ & & \verb~            GL.ClearColor(r / 255.0f, g / 255.0f, b / 255.0f, 1.0f);~\\
\cellcolor{red} & 0 & \verb~309~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~310~ & & \verb~~\\
\cellcolor{gray} &  & \verb~311~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~312~ & & \verb~        /// Set color to be used as clear color when using the Window.Clear() method.~\\
\cellcolor{gray} &  & \verb~313~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~314~ & & \verb~        /// <param name="color">System.Drawing.Color object containing color channel values.</param>~\\
\cellcolor{red} & 0 & \verb~315~ & & \verb~        public void SetClearColor(System.Drawing.Color color) {~\\
\cellcolor{red} & 0 & \verb~316~ & & \verb~            SetClearColor(new Math.Vec3I(color.R, color.G, color.B));~\\
\cellcolor{red} & 0 & \verb~317~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~318~ & & \verb~~\\
\cellcolor{gray} &  & \verb~319~ & & \verb~        #endregion~\\
\cellcolor{gray} &  & \verb~320~ & & \verb~~\\
\cellcolor{gray} &  & \verb~321~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~322~ & & \verb~        /// Swap double buffers for the Window.~\\
\cellcolor{gray} &  & \verb~323~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~324~ & & \verb~        public void SwapBuffers() {~\\
\cellcolor{red} & 0 & \verb~325~ & & \verb~            window.SwapBuffers();~\\
\cellcolor{red} & 0 & \verb~326~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~327~ & & \verb~~\\
\cellcolor{gray} &  & \verb~328~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~329~ & & \verb~        /// Check for incoming keyboard or mouse events.~\\
\cellcolor{gray} &  & \verb~330~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~331~ & & \verb~        public void PollEvents() {~\\
\cellcolor{red} & 0 & \verb~332~ & & \verb~            window.ProcessEvents();~\\
\cellcolor{red} & 0 & \verb~333~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~334~ & & \verb~~\\
\cellcolor{gray} &  & \verb~335~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~336~ & & \verb~        /// Save a screenshot of the Window's current state.~\\
\cellcolor{gray} &  & \verb~337~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~338~ & & \verb~        /// <exception cref="GraphicsContextMissingException"></exception>~\\
\cellcolor{red} & 0 & \verb~339~ & & \verb~        public void SaveScreenShot() {~\\
\cellcolor{red} & 0 & \verb~340~ & & \verb~            if (window.Context == null) {~\\
\cellcolor{red} & 0 & \verb~341~ & & \verb~                throw new ArgumentNullException("GraphicsContextMissingException");~\\
\cellcolor{gray} &  & \verb~342~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~343~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~344~ & & \verb~            var bmp = new Bitmap(window.ClientSize.X, window.ClientSize.Y, PixelFormat.Format24bppRgb);~\\
\cellcolor{red} & 0 & \verb~345~ & & \verb~            var data = bmp.LockBits(new System.Drawing.Rectangle(0, 0, window.ClientSize.X, window.ClientSize.Y),~\\
\cellcolor{red} & 0 & \verb~346~ & & \verb~                                    ImageLockMode.WriteOnly,~\\
\cellcolor{red} & 0 & \verb~347~ & & \verb~                                    PixelFormat.Format24bppRgb);~\\
\cellcolor{red} & 0 & \verb~348~ & & \verb~            GL.ReadPixels(0, 0, window.ClientSize.X, window.ClientSize.Y,~\\
\cellcolor{red} & 0 & \verb~349~ & & \verb~                OpenTK.Graphics.OpenGL.PixelFormat.Bgr,~\\
\cellcolor{red} & 0 & \verb~350~ & & \verb~                PixelType.UnsignedByte, data.Scan0);~\\
\cellcolor{red} & 0 & \verb~351~ & & \verb~            bmp.UnlockBits(data);~\\
\cellcolor{gray} &  & \verb~352~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~353~ & & \verb~            bmp.RotateFlip(RotateFlipType.RotateNoneFlipY);~\\
\cellcolor{gray} &  & \verb~354~ & & \verb~~\\
\cellcolor{gray} &  & \verb~355~ & & \verb~            // save screenshot, not in bin/Debug (et sim.), but in a logical place~\\
\cellcolor{red} & 0 & \verb~356~ & & \verb~            var dir = new DirectoryInfo(Path.GetDirectoryName(~\\
\cellcolor{red} & 0 & \verb~357~ & & \verb~                System.Reflection.Assembly.GetExecutingAssembly().Location));~\\
\cellcolor{gray} &  & \verb~358~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~359~ & & \verb~            while (dir.Name != "bin") {~\\
\cellcolor{red} & 0 & \verb~360~ & & \verb~                dir = dir.Parent;~\\
\cellcolor{red} & 0 & \verb~361~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~362~ & & \verb~            dir = dir.Parent;~\\
\cellcolor{gray} &  & \verb~363~ & & \verb~~\\
\cellcolor{gray} &  & \verb~364~ & & \verb~            // build the save path~\\
\cellcolor{red} & 0 & \verb~365~ & & \verb~            var saveName = $"screenShot_{Window.screenShotCounter++}.bmp";~\\
\cellcolor{red} & 0 & \verb~366~ & & \verb~            var folder = Path.Combine(dir.ToString(), "screenShots");~\\
\cellcolor{red} & 0 & \verb~367~ & & \verb~            var path = Path.Combine(folder, saveName);~\\
\cellcolor{gray} &  & \verb~368~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~369~ & & \verb~            if (!Directory.Exists(folder)) {~\\
\cellcolor{red} & 0 & \verb~370~ & & \verb~                Directory.CreateDirectory(folder);~\\
\cellcolor{red} & 0 & \verb~371~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~372~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~373~ & & \verb~            bmp.Save(path);~\\
\cellcolor{red} & 0 & \verb~374~ & & \verb~            Console.WriteLine($"Screenshot saved as: {path}");~\\
\cellcolor{red} & 0 & \verb~375~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~376~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~377~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.GUI.WindowArgs}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.GUI.WindowArgs\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/GUI/WindowArgs.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 7\\
\textbf{Coverable lines:} & 7\\
\textbf{Total lines:} & 27\\
\textbf{Line coverage:} & 0\% (0 of 7)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 7\\
\textbf{Method coverage:} & 0\% (0 of 7)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{get\_KeyboardLayout()} & 100\% & 1 & 0\%\\
\hline
\textbf{get\_Title()} & 100\% & 1 & 0\%\\
\hline
\textbf{get\_Width()} & 100\% & 1 & 0\%\\
\hline
\textbf{get\_Height()} & 100\% & 1 & 0\%\\
\hline
\textbf{get\_AspectRatio()} & 100\% & 1 & 0\%\\
\hline
\textbf{get\_FullScreen()} & 100\% & 1 & 0\%\\
\hline
\textbf{get\_Resizable()} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/GUI/WindowArgs.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Input;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~namespace DIKUArcade.GUI {~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~    /// Arguments for constructing a DIKUArcade.Window object.~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~    /// Use this class to set fundamental properties of the window.~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    public class WindowArgs {~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~        /* Globalisation settings */~\\
\cellcolor{red} & 0 & \verb~10~ & & \verb~        public KeyboardLayout KeyboardLayout { get; set; } = KeyboardLayout.Danish;~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~        /* Basic window properties */~\\
\cellcolor{red} & 0 & \verb~13~ & & \verb~        public string Title { get; set; } = "DIKUArcade";~\\
\cellcolor{red} & 0 & \verb~14~ & & \verb~        public uint Width { get; set; } = 500U;~\\
\cellcolor{red} & 0 & \verb~15~ & & \verb~        public uint Height { get; set; } = 500U;~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~        /// Specify window aspect ratio. If this value is something else than `WindowAspectRatio.Aspect_Custom`,~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~        /// then the width of the window will be calculated automatically based on the height.~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~21~ & & \verb~        public WindowAspectRatio AspectRatio { get; set; } = WindowAspectRatio.Aspect_Custom;~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~        /* Graphical properties */~\\
\cellcolor{red} & 0 & \verb~24~ & & \verb~        public bool FullScreen { get; set; } = false;~\\
\cellcolor{red} & 0 & \verb~25~ & & \verb~        public bool Resizable { get; set; } = true;~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Input.Languages.DanishKeyTransformer}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Input.Languages.DanishKeyTransformer\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{3Guest/DIKUGames/DIKUArcade/DIKUArcade/Input/Languages/DanishKeyTransformer.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 125\\
\textbf{Coverable lines:} & 125\\
\textbf{Total lines:} & 155\\
\textbf{Line coverage:} & 0\% (0 of 125)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 194\\
\textbf{Branch coverage:} & 0\% (0 of 194)\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 1\\
\textbf{Method coverage:} & 0\% (0 of 1)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{TransformKey(...)} & 0\% & 194 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{3Guest/DIKUGames/DIKUArcade/DIKUArcade/Input/Languages/DanishKeyTransformer.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using OpenTK.Windowing.GraphicsLibraryFramework;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Input;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~namespace DIKUArcade.Input.Languages~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~{~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    /// Represents the Danish keyboard layout.~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    public class DanishKeyTransformer : IKeyTransformer~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    {~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~        public KeyboardKey TransformKey(Keys key)~\\
\cellcolor{red} & 0 & \verb~13~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~14~ & & \verb~            switch (key)~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~16~ & & \verb~                case Keys.Unknown: return KeyboardKey.Unknown;~\\
\cellcolor{red} & 0 & \verb~17~ & & \verb~                case Keys.Space: return KeyboardKey.Space;~\\
\cellcolor{red} & 0 & \verb~18~ & & \verb~                case Keys.Apostrophe: return KeyboardKey.Danish_OE;~\\
\cellcolor{red} & 0 & \verb~19~ & & \verb~                case Keys.Comma: return KeyboardKey.Comma;~\\
\cellcolor{red} & 0 & \verb~20~ & & \verb~                case Keys.Minus: return KeyboardKey.Plus;~\\
\cellcolor{red} & 0 & \verb~21~ & & \verb~                case Keys.Period: return KeyboardKey.Period;~\\
\cellcolor{red} & 0 & \verb~22~ & & \verb~                case Keys.Slash: return KeyboardKey.Minus;~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~24~ & & \verb~                case Keys.D0: return KeyboardKey.Num_0;~\\
\cellcolor{red} & 0 & \verb~25~ & & \verb~                case Keys.D1: return KeyboardKey.Num_1;~\\
\cellcolor{red} & 0 & \verb~26~ & & \verb~                case Keys.D2: return KeyboardKey.Num_2;~\\
\cellcolor{red} & 0 & \verb~27~ & & \verb~                case Keys.D3: return KeyboardKey.Num_3;~\\
\cellcolor{red} & 0 & \verb~28~ & & \verb~                case Keys.D4: return KeyboardKey.Num_4;~\\
\cellcolor{red} & 0 & \verb~29~ & & \verb~                case Keys.D5: return KeyboardKey.Num_5;~\\
\cellcolor{red} & 0 & \verb~30~ & & \verb~                case Keys.D6: return KeyboardKey.Num_6;~\\
\cellcolor{red} & 0 & \verb~31~ & & \verb~                case Keys.D7: return KeyboardKey.Num_7;~\\
\cellcolor{red} & 0 & \verb~32~ & & \verb~                case Keys.D8: return KeyboardKey.Num_8;~\\
\cellcolor{red} & 0 & \verb~33~ & & \verb~                case Keys.D9: return KeyboardKey.Num_9;~\\
\cellcolor{red} & 0 & \verb~34~ & & \verb~                case Keys.Semicolon: return KeyboardKey.Danish_AE;~\\
\cellcolor{red} & 0 & \verb~35~ & & \verb~                case Keys.Equal: return KeyboardKey.AcuteAccent;~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~37~ & & \verb~                case Keys.A: return KeyboardKey.A;~\\
\cellcolor{red} & 0 & \verb~38~ & & \verb~                case Keys.B: return KeyboardKey.B;~\\
\cellcolor{red} & 0 & \verb~39~ & & \verb~                case Keys.C: return KeyboardKey.C;~\\
\cellcolor{red} & 0 & \verb~40~ & & \verb~                case Keys.D: return KeyboardKey.D;~\\
\cellcolor{red} & 0 & \verb~41~ & & \verb~                case Keys.E: return KeyboardKey.E;~\\
\cellcolor{red} & 0 & \verb~42~ & & \verb~                case Keys.F: return KeyboardKey.F;~\\
\cellcolor{red} & 0 & \verb~43~ & & \verb~                case Keys.G: return KeyboardKey.G;~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~                case Keys.H: return KeyboardKey.H;~\\
\cellcolor{red} & 0 & \verb~45~ & & \verb~                case Keys.I: return KeyboardKey.I;~\\
\cellcolor{red} & 0 & \verb~46~ & & \verb~                case Keys.J: return KeyboardKey.J;~\\
\cellcolor{red} & 0 & \verb~47~ & & \verb~                case Keys.K: return KeyboardKey.K;~\\
\cellcolor{red} & 0 & \verb~48~ & & \verb~                case Keys.L: return KeyboardKey.L;~\\
\cellcolor{red} & 0 & \verb~49~ & & \verb~                case Keys.M: return KeyboardKey.M;~\\
\cellcolor{red} & 0 & \verb~50~ & & \verb~                case Keys.N: return KeyboardKey.N;~\\
\cellcolor{red} & 0 & \verb~51~ & & \verb~                case Keys.O: return KeyboardKey.O;~\\
\cellcolor{red} & 0 & \verb~52~ & & \verb~                case Keys.P: return KeyboardKey.P;~\\
\cellcolor{red} & 0 & \verb~53~ & & \verb~                case Keys.Q: return KeyboardKey.Q;~\\
\cellcolor{red} & 0 & \verb~54~ & & \verb~                case Keys.R: return KeyboardKey.R;~\\
\cellcolor{red} & 0 & \verb~55~ & & \verb~                case Keys.S: return KeyboardKey.S;~\\
\cellcolor{red} & 0 & \verb~56~ & & \verb~                case Keys.T: return KeyboardKey.T;~\\
\cellcolor{red} & 0 & \verb~57~ & & \verb~                case Keys.U: return KeyboardKey.U;~\\
\cellcolor{red} & 0 & \verb~58~ & & \verb~                case Keys.V: return KeyboardKey.V;~\\
\cellcolor{red} & 0 & \verb~59~ & & \verb~                case Keys.W: return KeyboardKey.W;~\\
\cellcolor{red} & 0 & \verb~60~ & & \verb~                case Keys.X: return KeyboardKey.X;~\\
\cellcolor{red} & 0 & \verb~61~ & & \verb~                case Keys.Y: return KeyboardKey.Y;~\\
\cellcolor{red} & 0 & \verb~62~ & & \verb~                case Keys.Z: return KeyboardKey.Z;~\\
\cellcolor{gray} &  & \verb~63~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~64~ & & \verb~                case Keys.LeftBracket: return KeyboardKey.Danish_AA;~\\
\cellcolor{red} & 0 & \verb~65~ & & \verb~                case Keys.Backslash: return KeyboardKey.Apostrophe;~\\
\cellcolor{red} & 0 & \verb~66~ & & \verb~                case Keys.RightBracket: return KeyboardKey.Diaresis;~\\
\cellcolor{red} & 0 & \verb~67~ & & \verb~                case Keys.GraveAccent: return KeyboardKey.FractionOneHalf;~\\
\cellcolor{red} & 0 & \verb~68~ & & \verb~                case Keys.Escape: return KeyboardKey.Escape;~\\
\cellcolor{red} & 0 & \verb~69~ & & \verb~                case Keys.Enter: return KeyboardKey.Enter;~\\
\cellcolor{red} & 0 & \verb~70~ & & \verb~                case Keys.Tab: return KeyboardKey.Tab;~\\
\cellcolor{red} & 0 & \verb~71~ & & \verb~                case Keys.Backspace: return KeyboardKey.Backspace;~\\
\cellcolor{red} & 0 & \verb~72~ & & \verb~                case Keys.Insert: return KeyboardKey.Insert;~\\
\cellcolor{red} & 0 & \verb~73~ & & \verb~                case Keys.Delete: return KeyboardKey.Delete;~\\
\cellcolor{gray} &  & \verb~74~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~75~ & & \verb~                case Keys.Right: return KeyboardKey.Right;~\\
\cellcolor{red} & 0 & \verb~76~ & & \verb~                case Keys.Left: return KeyboardKey.Left;~\\
\cellcolor{red} & 0 & \verb~77~ & & \verb~                case Keys.Down: return KeyboardKey.Down;~\\
\cellcolor{red} & 0 & \verb~78~ & & \verb~                case Keys.Up: return KeyboardKey.Up;~\\
\cellcolor{gray} &  & \verb~79~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~80~ & & \verb~                case Keys.PageUp: return KeyboardKey.PageUp;~\\
\cellcolor{red} & 0 & \verb~81~ & & \verb~                case Keys.PageDown: return KeyboardKey.PageDown;~\\
\cellcolor{red} & 0 & \verb~82~ & & \verb~                case Keys.Home: return KeyboardKey.Home;~\\
\cellcolor{red} & 0 & \verb~83~ & & \verb~                case Keys.End: return KeyboardKey.End;~\\
\cellcolor{gray} &  & \verb~84~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~85~ & & \verb~                case Keys.CapsLock: return KeyboardKey.CapsLock;~\\
\cellcolor{red} & 0 & \verb~86~ & & \verb~                case Keys.ScrollLock: return KeyboardKey.ScrollLock;~\\
\cellcolor{red} & 0 & \verb~87~ & & \verb~                case Keys.NumLock: return KeyboardKey.NumLock;~\\
\cellcolor{red} & 0 & \verb~88~ & & \verb~                case Keys.PrintScreen: return KeyboardKey.PrintScreen;~\\
\cellcolor{red} & 0 & \verb~89~ & & \verb~                case Keys.Pause: return KeyboardKey.Pause;~\\
\cellcolor{gray} &  & \verb~90~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~91~ & & \verb~                case Keys.F1: return KeyboardKey.F1;~\\
\cellcolor{red} & 0 & \verb~92~ & & \verb~                case Keys.F2: return KeyboardKey.F2;~\\
\cellcolor{red} & 0 & \verb~93~ & & \verb~                case Keys.F3: return KeyboardKey.F3;~\\
\cellcolor{red} & 0 & \verb~94~ & & \verb~                case Keys.F4: return KeyboardKey.F4;~\\
\cellcolor{red} & 0 & \verb~95~ & & \verb~                case Keys.F5: return KeyboardKey.F5;~\\
\cellcolor{red} & 0 & \verb~96~ & & \verb~                case Keys.F6: return KeyboardKey.F6;~\\
\cellcolor{red} & 0 & \verb~97~ & & \verb~                case Keys.F7: return KeyboardKey.F7;~\\
\cellcolor{red} & 0 & \verb~98~ & & \verb~                case Keys.F8: return KeyboardKey.F8;~\\
\cellcolor{red} & 0 & \verb~99~ & & \verb~                case Keys.F9: return KeyboardKey.F9;~\\
\cellcolor{red} & 0 & \verb~100~ & & \verb~                case Keys.F10: return KeyboardKey.F10;~\\
\cellcolor{red} & 0 & \verb~101~ & & \verb~                case Keys.F11: return KeyboardKey.F11;~\\
\cellcolor{red} & 0 & \verb~102~ & & \verb~                case Keys.F12: return KeyboardKey.F12;~\\
\cellcolor{red} & 0 & \verb~103~ & & \verb~                case Keys.F13: return KeyboardKey.F13;~\\
\cellcolor{red} & 0 & \verb~104~ & & \verb~                case Keys.F14: return KeyboardKey.F14;~\\
\cellcolor{red} & 0 & \verb~105~ & & \verb~                case Keys.F15: return KeyboardKey.F15;~\\
\cellcolor{red} & 0 & \verb~106~ & & \verb~                case Keys.F16: return KeyboardKey.F16;~\\
\cellcolor{red} & 0 & \verb~107~ & & \verb~                case Keys.F17: return KeyboardKey.F17;~\\
\cellcolor{red} & 0 & \verb~108~ & & \verb~                case Keys.F18: return KeyboardKey.F18;~\\
\cellcolor{red} & 0 & \verb~109~ & & \verb~                case Keys.F19: return KeyboardKey.F19;~\\
\cellcolor{red} & 0 & \verb~110~ & & \verb~                case Keys.F20: return KeyboardKey.F20;~\\
\cellcolor{red} & 0 & \verb~111~ & & \verb~                case Keys.F21: return KeyboardKey.F21;~\\
\cellcolor{red} & 0 & \verb~112~ & & \verb~                case Keys.F22: return KeyboardKey.F22;~\\
\cellcolor{red} & 0 & \verb~113~ & & \verb~                case Keys.F23: return KeyboardKey.F23;~\\
\cellcolor{red} & 0 & \verb~114~ & & \verb~                case Keys.F24: return KeyboardKey.F24;~\\
\cellcolor{red} & 0 & \verb~115~ & & \verb~                case Keys.F25: return KeyboardKey.F25;~\\
\cellcolor{gray} &  & \verb~116~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~117~ & & \verb~                case Keys.KeyPad0: return KeyboardKey.KeyPad0;~\\
\cellcolor{red} & 0 & \verb~118~ & & \verb~                case Keys.KeyPad1: return KeyboardKey.KeyPad1;~\\
\cellcolor{red} & 0 & \verb~119~ & & \verb~                case Keys.KeyPad2: return KeyboardKey.KeyPad2;~\\
\cellcolor{red} & 0 & \verb~120~ & & \verb~                case Keys.KeyPad3: return KeyboardKey.KeyPad3;~\\
\cellcolor{red} & 0 & \verb~121~ & & \verb~                case Keys.KeyPad4: return KeyboardKey.KeyPad4;~\\
\cellcolor{red} & 0 & \verb~122~ & & \verb~                case Keys.KeyPad5: return KeyboardKey.KeyPad5;~\\
\cellcolor{red} & 0 & \verb~123~ & & \verb~                case Keys.KeyPad6: return KeyboardKey.KeyPad6;~\\
\cellcolor{red} & 0 & \verb~124~ & & \verb~                case Keys.KeyPad7: return KeyboardKey.KeyPad7;~\\
\cellcolor{red} & 0 & \verb~125~ & & \verb~                case Keys.KeyPad8: return KeyboardKey.KeyPad8;~\\
\cellcolor{red} & 0 & \verb~126~ & & \verb~                case Keys.KeyPad9: return KeyboardKey.KeyPad9;~\\
\cellcolor{red} & 0 & \verb~127~ & & \verb~                case Keys.KeyPadDecimal: return KeyboardKey.KeyPadDecimal;~\\
\cellcolor{red} & 0 & \verb~128~ & & \verb~                case Keys.KeyPadDivide: return KeyboardKey.KeyPadDivide;~\\
\cellcolor{red} & 0 & \verb~129~ & & \verb~                case Keys.KeyPadMultiply: return KeyboardKey.KeyPadMultiply;~\\
\cellcolor{red} & 0 & \verb~130~ & & \verb~                case Keys.KeyPadSubtract: return KeyboardKey.KeyPadSubtract;~\\
\cellcolor{red} & 0 & \verb~131~ & & \verb~                case Keys.KeyPadAdd: return KeyboardKey.KeyPadAdd;~\\
\cellcolor{red} & 0 & \verb~132~ & & \verb~                case Keys.KeyPadEnter: return KeyboardKey.KeyPadEnter;~\\
\cellcolor{red} & 0 & \verb~133~ & & \verb~                case Keys.KeyPadEqual: return KeyboardKey.KeyPadEqual;~\\
\cellcolor{gray} &  & \verb~134~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~135~ & & \verb~                case Keys.LeftShift: return KeyboardKey.LeftShift;~\\
\cellcolor{red} & 0 & \verb~136~ & & \verb~                case Keys.LeftControl: return KeyboardKey.LeftControl;~\\
\cellcolor{red} & 0 & \verb~137~ & & \verb~                case Keys.LeftAlt: return KeyboardKey.LeftAlt;~\\
\cellcolor{red} & 0 & \verb~138~ & & \verb~                case Keys.LeftSuper: return KeyboardKey.LeftSuper;~\\
\cellcolor{red} & 0 & \verb~139~ & & \verb~                case Keys.RightShift: return KeyboardKey.RightShift;~\\
\cellcolor{red} & 0 & \verb~140~ & & \verb~                case Keys.RightControl: return KeyboardKey.RightControl;~\\
\cellcolor{red} & 0 & \verb~141~ & & \verb~                case Keys.RightAlt: return KeyboardKey.RightAlt;~\\
\cellcolor{red} & 0 & \verb~142~ & & \verb~                case Keys.RightSuper: return KeyboardKey.RightSuper;~\\
\cellcolor{red} & 0 & \verb~143~ & & \verb~                case Keys.Menu: return KeyboardKey.Menu;~\\
\cellcolor{gray} &  & \verb~144~ & & \verb~~\\
\cellcolor{gray} &  & \verb~145~ & & \verb~                default:~\\
\cellcolor{red} & 0 & \verb~146~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~147~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~148~ & & \verb~~\\
\cellcolor{gray} &  & \verb~149~ & & \verb~            // special case for Danish keyboard layout, since this key is not given a~\\
\cellcolor{gray} &  & \verb~150~ & & \verb~            // name by OpenTK 4.5.~\\
\cellcolor{red} & 0 & \verb~151~ & & \verb~            if ((int)key == 161) { return KeyboardKey.LessThan; }~\\
\cellcolor{red} & 0 & \verb~152~ & & \verb~            else { return KeyboardKey.Unknown; }~\\
\cellcolor{red} & 0 & \verb~153~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~154~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~155~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Math.Vec2D}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Math.Vec2D\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Math/Vec2D.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 39\\
\textbf{Coverable lines:} & 39\\
\textbf{Total lines:} & 61\\
\textbf{Line coverage:} & 0\% (0 of 39)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 12\\
\textbf{Method coverage:} & 0\% (0 of 12)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{.ctor()} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Addition(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Subtraction(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Dot(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Length()} & 100\% & 1 & 0\%\\
\hline
\textbf{Copy()} & 100\% & 1 & 0\%\\
\hline
\textbf{GetHashCode()} & 100\% & 1 & 0\%\\
\hline
\textbf{ToString()} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Math/Vec2D.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~namespace DIKUArcade.Math {~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~    public class Vec2D {~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~        public double X;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~        public double Y;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~6~ & & \verb~        public Vec2D(double x, double y) {~\\
\cellcolor{red} & 0 & \verb~7~ & & \verb~            X = x;~\\
\cellcolor{red} & 0 & \verb~8~ & & \verb~            Y = y;~\\
\cellcolor{red} & 0 & \verb~9~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~11~ & & \verb~        public Vec2D() : this(0.0f, 0.0f) { }~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~13~ & & \verb~        public static Vec2D operator +(Vec2D v1, Vec2D v2) {~\\
\cellcolor{red} & 0 & \verb~14~ & & \verb~            return new Vec2D(v1.X + v2.X, v1.Y + v2.Y);~\\
\cellcolor{red} & 0 & \verb~15~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~17~ & & \verb~        public static Vec2D operator -(Vec2D v1, Vec2D v2) {~\\
\cellcolor{red} & 0 & \verb~18~ & & \verb~            return new Vec2D(v1.X - v2.X, v1.Y - v2.Y);~\\
\cellcolor{red} & 0 & \verb~19~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~        // pairwise multiplication~\\
\cellcolor{red} & 0 & \verb~22~ & & \verb~        public static Vec2D operator *(Vec2D v1, Vec2D v2) {~\\
\cellcolor{red} & 0 & \verb~23~ & & \verb~            return new Vec2D(v1.X * v2.X, v1.Y * v2.Y);~\\
\cellcolor{red} & 0 & \verb~24~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~26~ & & \verb~        public static Vec2D operator *(Vec2D v, double s) {~\\
\cellcolor{red} & 0 & \verb~27~ & & \verb~            return new Vec2D(v.X * s, v.Y * s);~\\
\cellcolor{red} & 0 & \verb~28~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~30~ & & \verb~        public static Vec2D operator *(double s, Vec2D v) {~\\
\cellcolor{red} & 0 & \verb~31~ & & \verb~            return new Vec2D(v.X * s, v.Y * s);~\\
\cellcolor{red} & 0 & \verb~32~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~34~ & & \verb~        public static double Dot(Vec2D v1, Vec2D v2) {~\\
\cellcolor{red} & 0 & \verb~35~ & & \verb~            return v1.X * v2.X + v1.Y * v2.Y;~\\
\cellcolor{red} & 0 & \verb~36~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~38~ & & \verb~        public double Length() {~\\
\cellcolor{red} & 0 & \verb~39~ & & \verb~            return System.Math.Sqrt(X * X + Y * Y);~\\
\cellcolor{red} & 0 & \verb~40~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~42~ & & \verb~        public Vec2D Copy() {~\\
\cellcolor{red} & 0 & \verb~43~ & & \verb~            return new Vec2D(X, Y);~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~45~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~46~ & & \verb~        public override int GetHashCode() {~\\
\cellcolor{gray} &  & \verb~47~ & & \verb~            // Source: http://stackoverflow.com/a/263416/5801152~\\
\cellcolor{gray} &  & \verb~48~ & & \verb~            unchecked // Overflow is fine, just wrap~\\
\cellcolor{red} & 0 & \verb~49~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~50~ & & \verb~                var hash = 17;~\\
\cellcolor{red} & 0 & \verb~51~ & & \verb~                hash = hash * 23 + X.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~52~ & & \verb~                hash = hash * 23 + Y.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~53~ & & \verb~                return hash;~\\
\cellcolor{gray} &  & \verb~54~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~55~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~56~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~57~ & & \verb~        public override string ToString() {~\\
\cellcolor{red} & 0 & \verb~58~ & & \verb~            return $"Vec2D({X},{Y})";~\\
\cellcolor{red} & 0 & \verb~59~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~60~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~61~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Math.Vec2F}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Math.Vec2F\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Math/Vec2F.cs}\end{minipage} \\
\textbf{Covered lines:} & 8\\
\textbf{Uncovered lines:} & 37\\
\textbf{Coverable lines:} & 45\\
\textbf{Total lines:} & 70\\
\textbf{Line coverage:} & 17.7\% (8 of 45)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 3\\
\textbf{Total methods:} & 14\\
\textbf{Method coverage:} & 21.4\% (3 of 14)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{.ctor()} & 100\% & 1 & 100\%\\
\hline
\textbf{op\_Addition(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{op\_Subtraction(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Division(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Dot(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Length()} & 100\% & 1 & 0\%\\
\hline
\textbf{Normalize(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Copy()} & 100\% & 1 & 0\%\\
\hline
\textbf{GetHashCode()} & 100\% & 1 & 0\%\\
\hline
\textbf{ToString()} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Math/Vec2F.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~namespace DIKUArcade.Math {~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~    public class Vec2F {~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~        public float X;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~        public float Y;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~~\\
\cellcolor{green} & 96594 & \verb~6~ & & \verb~        public Vec2F(float x, float y) {~\\
\cellcolor{green} & 48297 & \verb~7~ & & \verb~            X = x;~\\
\cellcolor{green} & 48297 & \verb~8~ & & \verb~            Y = y;~\\
\cellcolor{green} & 48297 & \verb~9~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~~\\
\cellcolor{green} & 5109 & \verb~11~ & & \verb~        public Vec2F() : this(0.0f, 0.0f) { }~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~~\\
\cellcolor{green} & 122 & \verb~13~ & & \verb~        public static Vec2F operator +(Vec2F v1, Vec2F v2) {~\\
\cellcolor{green} & 122 & \verb~14~ & & \verb~            return new Vec2F(v1.X + v2.X, v1.Y + v2.Y);~\\
\cellcolor{green} & 122 & \verb~15~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~17~ & & \verb~        public static Vec2F operator -(Vec2F v1, Vec2F v2) {~\\
\cellcolor{red} & 0 & \verb~18~ & & \verb~            return new Vec2F(v1.X - v2.X, v1.Y - v2.Y);~\\
\cellcolor{red} & 0 & \verb~19~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~        // pairwise multiplication~\\
\cellcolor{red} & 0 & \verb~22~ & & \verb~        public static Vec2F operator *(Vec2F v1, Vec2F v2) {~\\
\cellcolor{red} & 0 & \verb~23~ & & \verb~            return new Vec2F(v1.X * v2.X, v1.Y * v2.Y);~\\
\cellcolor{red} & 0 & \verb~24~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~26~ & & \verb~        public static Vec2F operator *(Vec2F v, float s) {~\\
\cellcolor{red} & 0 & \verb~27~ & & \verb~            return new Vec2F(v.X * s, v.Y * s);~\\
\cellcolor{red} & 0 & \verb~28~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~30~ & & \verb~        public static Vec2F operator *(float s, Vec2F v) {~\\
\cellcolor{red} & 0 & \verb~31~ & & \verb~            return new Vec2F(v.X * s, v.Y * s);~\\
\cellcolor{red} & 0 & \verb~32~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~34~ & & \verb~        public static Vec2F operator /(Vec2F v, float s) {~\\
\cellcolor{red} & 0 & \verb~35~ & & \verb~            return new Vec2F(v.X / s, v.Y / s);~\\
\cellcolor{red} & 0 & \verb~36~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~38~ & & \verb~        public static float Dot(Vec2F v1, Vec2F v2) {~\\
\cellcolor{red} & 0 & \verb~39~ & & \verb~            return v1.X * v2.X + v1.Y * v2.Y;~\\
\cellcolor{red} & 0 & \verb~40~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~42~ & & \verb~        public double Length() {~\\
\cellcolor{red} & 0 & \verb~43~ & & \verb~            return System.Math.Sqrt(X * X + Y * Y);~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~45~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~46~ & & \verb~        public static Vec2F Normalize(Vec2F v) {~\\
\cellcolor{red} & 0 & \verb~47~ & & \verb~            return v.Copy() * (1.0f / (float)v.Length());~\\
\cellcolor{red} & 0 & \verb~48~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~50~ & & \verb~        public Vec2F Copy() {~\\
\cellcolor{red} & 0 & \verb~51~ & & \verb~            return new Vec2F(X, Y);~\\
\cellcolor{red} & 0 & \verb~52~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~53~ & & \verb~~\\
\cellcolor{gray} &  & \verb~54~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~55~ & & \verb~        public override int GetHashCode() {~\\
\cellcolor{gray} &  & \verb~56~ & & \verb~            // Source: http://stackoverflow.com/a/263416/5801152~\\
\cellcolor{gray} &  & \verb~57~ & & \verb~            unchecked // Overflow is fine, just wrap~\\
\cellcolor{red} & 0 & \verb~58~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~59~ & & \verb~                var hash = 17;~\\
\cellcolor{red} & 0 & \verb~60~ & & \verb~                hash = hash * 23 + X.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~61~ & & \verb~                hash = hash * 23 + Y.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~62~ & & \verb~                return hash;~\\
\cellcolor{gray} &  & \verb~63~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~64~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~65~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~66~ & & \verb~        public override string ToString() {~\\
\cellcolor{red} & 0 & \verb~67~ & & \verb~            return $"Vec2F({X},{Y})";~\\
\cellcolor{red} & 0 & \verb~68~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~69~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~70~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Math.Vec2I}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Math.Vec2I\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Math/Vec2I.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 36\\
\textbf{Coverable lines:} & 36\\
\textbf{Total lines:} & 57\\
\textbf{Line coverage:} & 0\% (0 of 36)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 11\\
\textbf{Method coverage:} & 0\% (0 of 11)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{.ctor()} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Addition(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Subtraction(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Dot(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Length()} & 100\% & 1 & 0\%\\
\hline
\textbf{Copy()} & 100\% & 1 & 0\%\\
\hline
\textbf{GetHashCode()} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Math/Vec2I.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~namespace DIKUArcade.Math {~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~    public class Vec2I {~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~        public int X;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~        public int Y;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~6~ & & \verb~        public Vec2I(int x, int y) {~\\
\cellcolor{red} & 0 & \verb~7~ & & \verb~            X = x;~\\
\cellcolor{red} & 0 & \verb~8~ & & \verb~            Y = y;~\\
\cellcolor{red} & 0 & \verb~9~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~11~ & & \verb~        public Vec2I() : this(0, 0) { }~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~13~ & & \verb~        public static Vec2I operator +(Vec2I v1, Vec2I v2) {~\\
\cellcolor{red} & 0 & \verb~14~ & & \verb~            return new Vec2I(v1.X + v2.X, v1.Y + v2.Y);~\\
\cellcolor{red} & 0 & \verb~15~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~17~ & & \verb~        public static Vec2I operator -(Vec2I v1, Vec2I v2) {~\\
\cellcolor{red} & 0 & \verb~18~ & & \verb~            return new Vec2I(v1.X - v2.X, v1.Y - v2.Y);~\\
\cellcolor{red} & 0 & \verb~19~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~        // pairwise multiplication~\\
\cellcolor{red} & 0 & \verb~22~ & & \verb~        public static Vec2I operator *(Vec2I v1, Vec2I v2) {~\\
\cellcolor{red} & 0 & \verb~23~ & & \verb~            return new Vec2I(v1.X * v2.X, v1.Y * v2.Y);~\\
\cellcolor{red} & 0 & \verb~24~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~26~ & & \verb~        public static Vec2I operator *(Vec2I v, int s) {~\\
\cellcolor{red} & 0 & \verb~27~ & & \verb~            return new Vec2I(v.X * s, v.Y * s);~\\
\cellcolor{red} & 0 & \verb~28~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~30~ & & \verb~        public static Vec2I operator *(int s, Vec2I v) {~\\
\cellcolor{red} & 0 & \verb~31~ & & \verb~            return new Vec2I(v.X * s, v.Y * s);~\\
\cellcolor{red} & 0 & \verb~32~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~34~ & & \verb~        public static int Dot(Vec2I v1, Vec2I v2) {~\\
\cellcolor{red} & 0 & \verb~35~ & & \verb~            return v1.X * v2.X + v1.Y * v2.Y;~\\
\cellcolor{red} & 0 & \verb~36~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~38~ & & \verb~        public double Length() {~\\
\cellcolor{red} & 0 & \verb~39~ & & \verb~            return System.Math.Sqrt(X * X + Y * Y);~\\
\cellcolor{red} & 0 & \verb~40~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~42~ & & \verb~        public Vec2I Copy() {~\\
\cellcolor{red} & 0 & \verb~43~ & & \verb~            return new Vec2I(X, Y);~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~45~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~46~ & & \verb~        public override int GetHashCode() {~\\
\cellcolor{gray} &  & \verb~47~ & & \verb~            // Source: http://stackoverflow.com/a/263416/5801152~\\
\cellcolor{gray} &  & \verb~48~ & & \verb~            unchecked // Overflow is fine, just wrap~\\
\cellcolor{red} & 0 & \verb~49~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~50~ & & \verb~                var hash = 17;~\\
\cellcolor{red} & 0 & \verb~51~ & & \verb~                hash = hash * 23 + X.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~52~ & & \verb~                hash = hash * 23 + Y.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~53~ & & \verb~                return hash;~\\
\cellcolor{gray} &  & \verb~54~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~55~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~56~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~57~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Math.Vec3D}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Math.Vec3D\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Math/Vec3D.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 38\\
\textbf{Coverable lines:} & 38\\
\textbf{Total lines:} & 60\\
\textbf{Line coverage:} & 0\% (0 of 38)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 11\\
\textbf{Method coverage:} & 0\% (0 of 11)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{.ctor()} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Addition(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Subtraction(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Dot(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Length()} & 100\% & 1 & 0\%\\
\hline
\textbf{Copy()} & 100\% & 1 & 0\%\\
\hline
\textbf{GetHashCode()} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Math/Vec3D.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~namespace DIKUArcade.Math {~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~    public class Vec3D {~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~        public double X;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~        public double Y;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~        public double Z;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~7~ & & \verb~        public Vec3D(double x, double y, double z) {~\\
\cellcolor{red} & 0 & \verb~8~ & & \verb~            X = x;~\\
\cellcolor{red} & 0 & \verb~9~ & & \verb~            Y = y;~\\
\cellcolor{red} & 0 & \verb~10~ & & \verb~            Z = z;~\\
\cellcolor{red} & 0 & \verb~11~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~13~ & & \verb~        public Vec3D() : this(0.0f, 0.0f, 0.0f) { }~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~15~ & & \verb~        public static Vec3D operator +(Vec3D v1, Vec3D v2) {~\\
\cellcolor{red} & 0 & \verb~16~ & & \verb~            return new Vec3D(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);~\\
\cellcolor{red} & 0 & \verb~17~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~19~ & & \verb~        public static Vec3D operator -(Vec3D v1, Vec3D v2) {~\\
\cellcolor{red} & 0 & \verb~20~ & & \verb~            return new Vec3D(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);~\\
\cellcolor{red} & 0 & \verb~21~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~        // pairwise multiplication~\\
\cellcolor{red} & 0 & \verb~24~ & & \verb~        public static Vec3D operator *(Vec3D v1, Vec3D v2) {~\\
\cellcolor{red} & 0 & \verb~25~ & & \verb~            return new Vec3D(v1.X * v2.X, v1.Y * v2.Y, v1.Z * v2.Z);~\\
\cellcolor{red} & 0 & \verb~26~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~28~ & & \verb~        public static Vec3D operator *(Vec3D v, double s) {~\\
\cellcolor{red} & 0 & \verb~29~ & & \verb~            return new Vec3D(v.X * s, v.Y * s, v.Z * s);~\\
\cellcolor{red} & 0 & \verb~30~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~32~ & & \verb~        public static Vec3D operator *(double s, Vec3D v) {~\\
\cellcolor{red} & 0 & \verb~33~ & & \verb~            return new Vec3D(v.X * s, v.Y * s, v.Z * s);~\\
\cellcolor{red} & 0 & \verb~34~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~36~ & & \verb~        public static double Dot(Vec3D v1, Vec3D v2) {~\\
\cellcolor{red} & 0 & \verb~37~ & & \verb~            return v1.X * v2.X + v1.Y * v2.Y + v1.Z * v2.Z;~\\
\cellcolor{red} & 0 & \verb~38~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~39~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~40~ & & \verb~        public double Length() {~\\
\cellcolor{red} & 0 & \verb~41~ & & \verb~            return System.Math.Sqrt(X * X + Y * Y + Z * Z);~\\
\cellcolor{red} & 0 & \verb~42~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~43~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~        public Vec3D Copy() {~\\
\cellcolor{red} & 0 & \verb~45~ & & \verb~            return new Vec3D(X, Y, Z);~\\
\cellcolor{red} & 0 & \verb~46~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~47~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~48~ & & \verb~        public override int GetHashCode() {~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~            // Source: http://stackoverflow.com/a/263416/5801152~\\
\cellcolor{gray} &  & \verb~50~ & & \verb~            unchecked // Overflow is fine, just wrap~\\
\cellcolor{red} & 0 & \verb~51~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~52~ & & \verb~                var hash = 17;~\\
\cellcolor{red} & 0 & \verb~53~ & & \verb~                hash = hash * 23 + X.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~54~ & & \verb~                hash = hash * 23 + Y.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~55~ & & \verb~                hash = hash * 23 + Z.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~56~ & & \verb~                return hash;~\\
\cellcolor{gray} &  & \verb~57~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~58~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~59~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~60~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Math.Vec3F}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Math.Vec3F\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Math/Vec3F.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 38\\
\textbf{Coverable lines:} & 38\\
\textbf{Total lines:} & 60\\
\textbf{Line coverage:} & 0\% (0 of 38)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 11\\
\textbf{Method coverage:} & 0\% (0 of 11)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{.ctor()} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Addition(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Subtraction(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Dot(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Length()} & 100\% & 1 & 0\%\\
\hline
\textbf{Copy()} & 100\% & 1 & 0\%\\
\hline
\textbf{GetHashCode()} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Math/Vec3F.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~namespace DIKUArcade.Math {~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~    public class Vec3F {~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~        public float X;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~        public float Y;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~        public float Z;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~7~ & & \verb~        public Vec3F(float x, float y, float z) {~\\
\cellcolor{red} & 0 & \verb~8~ & & \verb~            X = x;~\\
\cellcolor{red} & 0 & \verb~9~ & & \verb~            Y = y;~\\
\cellcolor{red} & 0 & \verb~10~ & & \verb~            Z = z;~\\
\cellcolor{red} & 0 & \verb~11~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~13~ & & \verb~        public Vec3F() : this(0.0f, 0.0f, 0.0f) { }~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~15~ & & \verb~        public static Vec3F operator +(Vec3F v1, Vec3F v2) {~\\
\cellcolor{red} & 0 & \verb~16~ & & \verb~            return new Vec3F(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);~\\
\cellcolor{red} & 0 & \verb~17~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~19~ & & \verb~        public static Vec3F operator -(Vec3F v1, Vec3F v2) {~\\
\cellcolor{red} & 0 & \verb~20~ & & \verb~            return new Vec3F(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);~\\
\cellcolor{red} & 0 & \verb~21~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~        // pairwise multiplication~\\
\cellcolor{red} & 0 & \verb~24~ & & \verb~        public static Vec3F operator *(Vec3F v1, Vec3F v2) {~\\
\cellcolor{red} & 0 & \verb~25~ & & \verb~            return new Vec3F(v1.X * v2.X, v1.Y * v2.Y, v1.Z * v2.Z);~\\
\cellcolor{red} & 0 & \verb~26~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~28~ & & \verb~        public static Vec3F operator *(Vec3F v, float s) {~\\
\cellcolor{red} & 0 & \verb~29~ & & \verb~            return new Vec3F(v.X * s, v.Y * s, v.Z * s);~\\
\cellcolor{red} & 0 & \verb~30~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~32~ & & \verb~        public static Vec3F operator *(float s, Vec3F v) {~\\
\cellcolor{red} & 0 & \verb~33~ & & \verb~            return new Vec3F(v.X * s, v.Y * s, v.Z * s);~\\
\cellcolor{red} & 0 & \verb~34~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~36~ & & \verb~        public static float Dot(Vec3F v1, Vec3F v2) {~\\
\cellcolor{red} & 0 & \verb~37~ & & \verb~            return v1.X * v2.X + v1.Y * v2.Y + v1.Z * v2.Z;~\\
\cellcolor{red} & 0 & \verb~38~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~39~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~40~ & & \verb~        public double Length() {~\\
\cellcolor{red} & 0 & \verb~41~ & & \verb~            return System.Math.Sqrt(X * X + Y * Y + Z * Z);~\\
\cellcolor{red} & 0 & \verb~42~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~43~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~        public Vec3F Copy() {~\\
\cellcolor{red} & 0 & \verb~45~ & & \verb~            return new Vec3F(X, Y, Z);~\\
\cellcolor{red} & 0 & \verb~46~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~47~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~48~ & & \verb~        public override int GetHashCode() {~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~            // Source: http://stackoverflow.com/a/263416/5801152~\\
\cellcolor{gray} &  & \verb~50~ & & \verb~            unchecked // Overflow is fine, just wrap~\\
\cellcolor{red} & 0 & \verb~51~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~52~ & & \verb~                var hash = 17;~\\
\cellcolor{red} & 0 & \verb~53~ & & \verb~                hash = hash * 23 + X.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~54~ & & \verb~                hash = hash * 23 + Y.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~55~ & & \verb~                hash = hash * 23 + Z.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~56~ & & \verb~                return hash;~\\
\cellcolor{gray} &  & \verb~57~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~58~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~59~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~60~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Math.Vec3I}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Math.Vec3I\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Math/Vec3I.cs}\end{minipage} \\
\textbf{Covered lines:} & 5\\
\textbf{Uncovered lines:} & 33\\
\textbf{Coverable lines:} & 38\\
\textbf{Total lines:} & 60\\
\textbf{Line coverage:} & 13.1\% (5 of 38)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 1\\
\textbf{Total methods:} & 11\\
\textbf{Method coverage:} & 9\% (1 of 11)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{.ctor()} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Addition(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Subtraction(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Dot(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Length()} & 100\% & 1 & 0\%\\
\hline
\textbf{Copy()} & 100\% & 1 & 0\%\\
\hline
\textbf{GetHashCode()} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Math/Vec3I.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~namespace DIKUArcade.Math {~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~    public class Vec3I {~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~        public int X;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~        public int Y;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~        public int Z;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~~\\
\cellcolor{green} & 1786 & \verb~7~ & & \verb~        public Vec3I(int x, int y, int z) {~\\
\cellcolor{green} & 893 & \verb~8~ & & \verb~            X = x;~\\
\cellcolor{green} & 893 & \verb~9~ & & \verb~            Y = y;~\\
\cellcolor{green} & 893 & \verb~10~ & & \verb~            Z = z;~\\
\cellcolor{green} & 893 & \verb~11~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~13~ & & \verb~        public Vec3I() : this(0, 0, 0) { }~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~15~ & & \verb~        public static Vec3I operator +(Vec3I v1, Vec3I v2) {~\\
\cellcolor{red} & 0 & \verb~16~ & & \verb~            return new Vec3I(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);~\\
\cellcolor{red} & 0 & \verb~17~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~19~ & & \verb~        public static Vec3I operator -(Vec3I v1, Vec3I v2) {~\\
\cellcolor{red} & 0 & \verb~20~ & & \verb~            return new Vec3I(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);~\\
\cellcolor{red} & 0 & \verb~21~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~        // pairwise multiplication~\\
\cellcolor{red} & 0 & \verb~24~ & & \verb~        public static Vec3I operator *(Vec3I v1, Vec3I v2) {~\\
\cellcolor{red} & 0 & \verb~25~ & & \verb~            return new Vec3I(v1.X * v2.X, v1.Y * v2.Y, v1.Z * v2.Z);~\\
\cellcolor{red} & 0 & \verb~26~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~28~ & & \verb~        public static Vec3I operator *(Vec3I v, int s) {~\\
\cellcolor{red} & 0 & \verb~29~ & & \verb~            return new Vec3I(v.X * s, v.Y * s, v.Z * s);~\\
\cellcolor{red} & 0 & \verb~30~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~32~ & & \verb~        public static Vec3I operator *(int s, Vec3I v) {~\\
\cellcolor{red} & 0 & \verb~33~ & & \verb~            return new Vec3I(v.X * s, v.Y * s, v.Z * s);~\\
\cellcolor{red} & 0 & \verb~34~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~36~ & & \verb~        public static int Dot(Vec3I v1, Vec3I v2) {~\\
\cellcolor{red} & 0 & \verb~37~ & & \verb~            return v1.X * v2.X + v1.Y * v2.Y + v1.Z * v2.Z;~\\
\cellcolor{red} & 0 & \verb~38~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~39~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~40~ & & \verb~        public double Length() {~\\
\cellcolor{red} & 0 & \verb~41~ & & \verb~            return System.Math.Sqrt(X * X + Y * Y + Z * Z);~\\
\cellcolor{red} & 0 & \verb~42~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~43~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~        public Vec3I Copy() {~\\
\cellcolor{red} & 0 & \verb~45~ & & \verb~            return new Vec3I(X, Y, Z);~\\
\cellcolor{red} & 0 & \verb~46~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~47~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~48~ & & \verb~        public override int GetHashCode() {~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~            // Source: http://stackoverflow.com/a/263416/5801152~\\
\cellcolor{gray} &  & \verb~50~ & & \verb~            unchecked // Overflow is fine, just wrap~\\
\cellcolor{red} & 0 & \verb~51~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~52~ & & \verb~                var hash = 17;~\\
\cellcolor{red} & 0 & \verb~53~ & & \verb~                hash = hash * 23 + X.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~54~ & & \verb~                hash = hash * 23 + Y.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~55~ & & \verb~                hash = hash * 23 + Z.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~56~ & & \verb~                return hash;~\\
\cellcolor{gray} &  & \verb~57~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~58~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~59~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~60~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Math.Vec4D}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Math.Vec4D\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Math/Vec4D.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 40\\
\textbf{Coverable lines:} & 40\\
\textbf{Total lines:} & 63\\
\textbf{Line coverage:} & 0\% (0 of 40)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 11\\
\textbf{Method coverage:} & 0\% (0 of 11)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{.ctor()} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Addition(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Subtraction(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Dot(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Length()} & 100\% & 1 & 0\%\\
\hline
\textbf{Copy()} & 100\% & 1 & 0\%\\
\hline
\textbf{GetHashCode()} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Math/Vec4D.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~namespace DIKUArcade.Math {~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~    public class Vec4D {~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~        public double W;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~        public double X;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~        public double Y;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~        public double Z;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~8~ & & \verb~        public Vec4D(double x, double y, double z, double w) {~\\
\cellcolor{red} & 0 & \verb~9~ & & \verb~            X = x;~\\
\cellcolor{red} & 0 & \verb~10~ & & \verb~            Y = y;~\\
\cellcolor{red} & 0 & \verb~11~ & & \verb~            Z = z;~\\
\cellcolor{red} & 0 & \verb~12~ & & \verb~            W = w;~\\
\cellcolor{red} & 0 & \verb~13~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~15~ & & \verb~        public Vec4D() : this(0.0f, 0.0f, 0.0f, 0.0f) { }~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~17~ & & \verb~        public static Vec4D operator +(Vec4D v1, Vec4D v2) {~\\
\cellcolor{red} & 0 & \verb~18~ & & \verb~            return new Vec4D(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z, v1.W + v2.W);~\\
\cellcolor{red} & 0 & \verb~19~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~21~ & & \verb~        public static Vec4D operator -(Vec4D v1, Vec4D v2) {~\\
\cellcolor{red} & 0 & \verb~22~ & & \verb~            return new Vec4D(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z, v1.W - v2.W);~\\
\cellcolor{red} & 0 & \verb~23~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~        // pairwise multiplication~\\
\cellcolor{red} & 0 & \verb~26~ & & \verb~        public static Vec4D operator *(Vec4D v1, Vec4D v2) {~\\
\cellcolor{red} & 0 & \verb~27~ & & \verb~            return new Vec4D(v1.X * v2.X, v1.Y * v2.Y, v1.Z * v2.Z, v1.W * v2.W);~\\
\cellcolor{red} & 0 & \verb~28~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~30~ & & \verb~        public static Vec4D operator *(Vec4D v, double s) {~\\
\cellcolor{red} & 0 & \verb~31~ & & \verb~            return new Vec4D(v.X * s, v.Y * s, v.Z * s, v.W * s);~\\
\cellcolor{red} & 0 & \verb~32~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~34~ & & \verb~        public static Vec4D operator *(double s, Vec4D v) {~\\
\cellcolor{red} & 0 & \verb~35~ & & \verb~            return new Vec4D(v.X * s, v.Y * s, v.Z * s, v.W * s);~\\
\cellcolor{red} & 0 & \verb~36~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~38~ & & \verb~        public static double Dot(Vec4D v1, Vec4D v2) {~\\
\cellcolor{red} & 0 & \verb~39~ & & \verb~            return v1.X * v2.X + v1.Y * v2.Y + v1.Z * v2.Z + v1.W * v2.W;~\\
\cellcolor{red} & 0 & \verb~40~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~42~ & & \verb~        public double Length() {~\\
\cellcolor{red} & 0 & \verb~43~ & & \verb~            return System.Math.Sqrt(X * X + Y * Y + Z * Z + W * W);~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~45~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~46~ & & \verb~        public Vec4D Copy() {~\\
\cellcolor{red} & 0 & \verb~47~ & & \verb~            return new Vec4D(X, Y, Z, W);~\\
\cellcolor{red} & 0 & \verb~48~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~50~ & & \verb~        public override int GetHashCode() {~\\
\cellcolor{gray} &  & \verb~51~ & & \verb~            // Source: http://stackoverflow.com/a/263416/5801152~\\
\cellcolor{gray} &  & \verb~52~ & & \verb~            unchecked // Overflow is fine, just wrap~\\
\cellcolor{red} & 0 & \verb~53~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~54~ & & \verb~                var hash = 17;~\\
\cellcolor{red} & 0 & \verb~55~ & & \verb~                hash = hash * 23 + X.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~56~ & & \verb~                hash = hash * 23 + Y.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~57~ & & \verb~                hash = hash * 23 + Z.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~58~ & & \verb~                hash = hash * 23 + W.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~59~ & & \verb~                return hash;~\\
\cellcolor{gray} &  & \verb~60~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~61~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~62~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~63~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Math.Vec4F}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Math.Vec4F\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Math/Vec4F.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 40\\
\textbf{Coverable lines:} & 40\\
\textbf{Total lines:} & 63\\
\textbf{Line coverage:} & 0\% (0 of 40)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 11\\
\textbf{Method coverage:} & 0\% (0 of 11)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{.ctor()} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Addition(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Subtraction(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Dot(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Length()} & 100\% & 1 & 0\%\\
\hline
\textbf{Copy()} & 100\% & 1 & 0\%\\
\hline
\textbf{GetHashCode()} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Math/Vec4F.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~namespace DIKUArcade.Math {~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~    public class Vec4F {~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~        public float W;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~        public float X;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~        public float Y;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~        public float Z;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~8~ & & \verb~        public Vec4F(float x, float y, float z, float w) {~\\
\cellcolor{red} & 0 & \verb~9~ & & \verb~            X = x;~\\
\cellcolor{red} & 0 & \verb~10~ & & \verb~            Y = y;~\\
\cellcolor{red} & 0 & \verb~11~ & & \verb~            Z = z;~\\
\cellcolor{red} & 0 & \verb~12~ & & \verb~            W = w;~\\
\cellcolor{red} & 0 & \verb~13~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~15~ & & \verb~        public Vec4F() : this(0.0f, 0.0f, 0.0f, 0.0f) { }~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~17~ & & \verb~        public static Vec4F operator +(Vec4F v1, Vec4F v2) {~\\
\cellcolor{red} & 0 & \verb~18~ & & \verb~            return new Vec4F(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z, v1.W + v2.W);~\\
\cellcolor{red} & 0 & \verb~19~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~21~ & & \verb~        public static Vec4F operator -(Vec4F v1, Vec4F v2) {~\\
\cellcolor{red} & 0 & \verb~22~ & & \verb~            return new Vec4F(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z, v1.W - v2.W);~\\
\cellcolor{red} & 0 & \verb~23~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~        // pairwise multiplication~\\
\cellcolor{red} & 0 & \verb~26~ & & \verb~        public static Vec4F operator *(Vec4F v1, Vec4F v2) {~\\
\cellcolor{red} & 0 & \verb~27~ & & \verb~            return new Vec4F(v1.X * v2.X, v1.Y * v2.Y, v1.Z * v2.Z, v1.W * v2.W);~\\
\cellcolor{red} & 0 & \verb~28~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~30~ & & \verb~        public static Vec4F operator *(Vec4F v, float s) {~\\
\cellcolor{red} & 0 & \verb~31~ & & \verb~            return new Vec4F(v.X * s, v.Y * s, v.Z * s, v.W * s);~\\
\cellcolor{red} & 0 & \verb~32~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~34~ & & \verb~        public static Vec4F operator *(float s, Vec4F v) {~\\
\cellcolor{red} & 0 & \verb~35~ & & \verb~            return new Vec4F(v.X * s, v.Y * s, v.Z * s, v.W * s);~\\
\cellcolor{red} & 0 & \verb~36~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~38~ & & \verb~        public static float Dot(Vec4F v1, Vec4F v2) {~\\
\cellcolor{red} & 0 & \verb~39~ & & \verb~            return v1.X * v2.X + v1.Y * v2.Y + v1.Z * v2.Z + v1.W * v2.W;~\\
\cellcolor{red} & 0 & \verb~40~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~42~ & & \verb~        public double Length() {~\\
\cellcolor{red} & 0 & \verb~43~ & & \verb~            return System.Math.Sqrt(X * X + Y * Y + Z * Z + W * W);~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~45~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~46~ & & \verb~        public Vec4F Copy() {~\\
\cellcolor{red} & 0 & \verb~47~ & & \verb~            return new Vec4F(X, Y, Z, W);~\\
\cellcolor{red} & 0 & \verb~48~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~50~ & & \verb~        public override int GetHashCode() {~\\
\cellcolor{gray} &  & \verb~51~ & & \verb~            // Source: http://stackoverflow.com/a/263416/5801152~\\
\cellcolor{gray} &  & \verb~52~ & & \verb~            unchecked // Overflow is fine, just wrap~\\
\cellcolor{red} & 0 & \verb~53~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~54~ & & \verb~                var hash = 17;~\\
\cellcolor{red} & 0 & \verb~55~ & & \verb~                hash = hash * 23 + X.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~56~ & & \verb~                hash = hash * 23 + Y.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~57~ & & \verb~                hash = hash * 23 + Z.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~58~ & & \verb~                hash = hash * 23 + W.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~59~ & & \verb~                return hash;~\\
\cellcolor{gray} &  & \verb~60~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~61~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~62~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~63~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Math.Vec4I}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Math.Vec4I\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Math/Vec4I.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 40\\
\textbf{Coverable lines:} & 40\\
\textbf{Total lines:} & 63\\
\textbf{Line coverage:} & 0\% (0 of 40)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 11\\
\textbf{Method coverage:} & 0\% (0 of 11)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{.ctor()} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Addition(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Subtraction(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Dot(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Length()} & 100\% & 1 & 0\%\\
\hline
\textbf{Copy()} & 100\% & 1 & 0\%\\
\hline
\textbf{GetHashCode()} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Math/Vec4I.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~namespace DIKUArcade.Math {~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~    public class Vec4I {~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~        public int W;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~        public int X;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~        public int Y;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~        public int Z;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~8~ & & \verb~        public Vec4I(int x, int y, int z, int w) {~\\
\cellcolor{red} & 0 & \verb~9~ & & \verb~            X = x;~\\
\cellcolor{red} & 0 & \verb~10~ & & \verb~            Y = y;~\\
\cellcolor{red} & 0 & \verb~11~ & & \verb~            Z = z;~\\
\cellcolor{red} & 0 & \verb~12~ & & \verb~            W = w;~\\
\cellcolor{red} & 0 & \verb~13~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~15~ & & \verb~        public Vec4I() : this(0, 0, 0, 0) { }~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~17~ & & \verb~        public static Vec4I operator +(Vec4I v1, Vec4I v2) {~\\
\cellcolor{red} & 0 & \verb~18~ & & \verb~            return new Vec4I(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z, v1.W + v2.W);~\\
\cellcolor{red} & 0 & \verb~19~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~21~ & & \verb~        public static Vec4I operator -(Vec4I v1, Vec4I v2) {~\\
\cellcolor{red} & 0 & \verb~22~ & & \verb~            return new Vec4I(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z, v1.W - v2.W);~\\
\cellcolor{red} & 0 & \verb~23~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~        // pairwise multiplication~\\
\cellcolor{red} & 0 & \verb~26~ & & \verb~        public static Vec4I operator *(Vec4I v1, Vec4I v2) {~\\
\cellcolor{red} & 0 & \verb~27~ & & \verb~            return new Vec4I(v1.X * v2.X, v1.Y * v2.Y, v1.Z * v2.Z, v1.W * v2.W);~\\
\cellcolor{red} & 0 & \verb~28~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~30~ & & \verb~        public static Vec4I operator *(Vec4I v, int s) {~\\
\cellcolor{red} & 0 & \verb~31~ & & \verb~            return new Vec4I(v.X * s, v.Y * s, v.Z * s, v.W * s);~\\
\cellcolor{red} & 0 & \verb~32~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~34~ & & \verb~        public static Vec4I operator *(int s, Vec4I v) {~\\
\cellcolor{red} & 0 & \verb~35~ & & \verb~            return new Vec4I(v.X * s, v.Y * s, v.Z * s, v.W * s);~\\
\cellcolor{red} & 0 & \verb~36~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~38~ & & \verb~        public static int Dot(Vec4I v1, Vec4I v2) {~\\
\cellcolor{red} & 0 & \verb~39~ & & \verb~            return v1.X * v2.X + v1.Y * v2.Y + v1.Z * v2.Z + v1.W * v2.W;~\\
\cellcolor{red} & 0 & \verb~40~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~42~ & & \verb~        public double Length() {~\\
\cellcolor{red} & 0 & \verb~43~ & & \verb~            return System.Math.Sqrt(X * X + Y * Y + Z * Z + W * W);~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~45~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~46~ & & \verb~        public Vec4I Copy() {~\\
\cellcolor{red} & 0 & \verb~47~ & & \verb~            return new Vec4I(X, Y, Z, W);~\\
\cellcolor{red} & 0 & \verb~48~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~50~ & & \verb~        public override int GetHashCode() {~\\
\cellcolor{gray} &  & \verb~51~ & & \verb~            // Source: http://stackoverflow.com/a/263416/5801152~\\
\cellcolor{gray} &  & \verb~52~ & & \verb~            unchecked // Overflow is fine, just wrap~\\
\cellcolor{red} & 0 & \verb~53~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~54~ & & \verb~                var hash = 17;~\\
\cellcolor{red} & 0 & \verb~55~ & & \verb~                hash = hash * 23 + X.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~56~ & & \verb~                hash = hash * 23 + Y.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~57~ & & \verb~                hash = hash * 23 + Z.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~58~ & & \verb~                hash = hash * 23 + W.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~59~ & & \verb~                return hash;~\\
\cellcolor{gray} &  & \verb~60~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~61~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~62~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~63~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Physics.CollisionData}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Physics.CollisionData\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{ome/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Physics/CollisionData.cs}\end{minipage} \\
\textbf{Covered lines:} & 3\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 3\\
\textbf{Total lines:} & 23\\
\textbf{Line coverage:} & 100\% (3 of 3)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 3\\
\textbf{Total methods:} & 3\\
\textbf{Method coverage:} & 100\% (3 of 3)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{get\_Collision()} & 100\% & 1 & 100\%\\
\hline
\textbf{get\_DirectionFactor(} & 100\% & 1 & 100\%\\
\hline
\textbf{get\_CollisionDir()} & 100\% & 1 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{ome/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Physics/CollisionData.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~namespace DIKUArcade.Physics {~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~    public class CollisionData {~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~        /// Indicating whether or not a collision has occured.~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 1902 & \verb~8~ & & \verb~        public bool Collision { get; set; }~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~        /// This factor should be multiplied onto the actor shape's~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~        /// direction vector to get the closest position to the~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~        /// incident object.~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 960 & \verb~15~ & & \verb~        public Vec2F DirectionFactor { get; set; }~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~        /// The surface normal of the incident object, indicating~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~        /// from which direction a collision has occured.~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 1040 & \verb~21~ & & \verb~        public CollisionDirection CollisionDir { get; set; } // might sometimes be useful!~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Physics.CollisionDetection}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Physics.CollisionDetection\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{tudent/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Physics/CollisionDetection.cs}\end{minipage} \\
\textbf{Covered lines:} & 84\\
\textbf{Uncovered lines:} & 27\\
\textbf{Coverable lines:} & 111\\
\textbf{Total lines:} & 184\\
\textbf{Line coverage:} & 75.6\% (84 of 111)\\
\textbf{Covered branches:} & 33\\
\textbf{Total branches:} & 48\\
\textbf{Branch coverage:} & 68.7\% (33 of 48)\\
\textbf{Covered methods:} & 1\\
\textbf{Total methods:} & 2\\
\textbf{Method coverage:} & 50\% (1 of 2)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{Aabb\_C(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Aabb(...)} & 68.75\% & 48 & 77.06\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{tudent/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Physics/CollisionDetection.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~namespace DIKUArcade.Physics {~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~    // https://learnopengl.com/In-Practice/2D-Game/Collisions/Collision-detection~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    // Potentially allow for AABB with circles.~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~    // Or use SAT.~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    public class CollisionDetection {~\\
\cellcolor{red} & 0 & \verb~11~ & & \verb~        public static CollisionData Aabb_C(DynamicShape actor, Shape shape) {~\\
\cellcolor{red} & 0 & \verb~12~ & & \verb~            throw new NotImplementedException("CollisionDetection.Aabb_C is not finished!");~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~            /*~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~            var data = new CollisionData {~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~                Collision = false,~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~                DirectionFactor = new Vec2F(1.0f, 1.0f),~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~                CollisionDir = CollisionDirection.CollisionDirUnchecked~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~            };~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~            var circRadius = shape.Extent.Y/2;~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~            var circCenter = new Vec2F(shape.Position.X + shape.Extent.X/2, shape.Position.Y + shape.Extent.Y/2);~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~            var staLowerLeft = new Vec2F(shape.Position.X, shape.Position.Y);~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~            var staUpperRight = new Vec2F(shape.Position.X + shape.Extent.X,~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~                shape.Position.Y + shape.Extent.Y);~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~            var staCenter = new Vec2F(shape.Position.X + shape.Extent.X/2, shape.Position.Y + shape.Extent.Y/2);~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~            var D = circCenter - staCenter;~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~            // Clamp D to width/2 height/2 and add it to staCenter~\\
\cellcolor{gray} &  & \verb~32~ & & \verb~~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~            return data;~\\
\cellcolor{gray} &  & \verb~34~ & & \verb~            */~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~~\\
\cellcolor{green} & 942 & \verb~37~ & & \verb~        public static CollisionData Aabb(DynamicShape actor, Shape shape) {~\\
\cellcolor{green} & 942 & \verb~38~ & & \verb~            var data = new CollisionData {~\\
\cellcolor{green} & 942 & \verb~39~ & & \verb~                Collision = false,~\\
\cellcolor{green} & 942 & \verb~40~ & & \verb~                DirectionFactor = new Vec2F(1.0f, 1.0f),~\\
\cellcolor{green} & 942 & \verb~41~ & & \verb~                CollisionDir = CollisionDirection.CollisionDirUnchecked~\\
\cellcolor{green} & 942 & \verb~42~ & & \verb~            };~\\
\cellcolor{gray} &  & \verb~43~ & & \verb~~\\
\cellcolor{green} & 942 & \verb~44~ & & \verb~            var dynLowerLeft = new Vec2F(actor.Position.X, actor.Position.Y);~\\
\cellcolor{green} & 942 & \verb~45~ & & \verb~            var dynUpperRight = new Vec2F(actor.Position.X + actor.Extent.X,~\\
\cellcolor{green} & 942 & \verb~46~ & & \verb~                actor.Position.Y + actor.Extent.Y);~\\
\cellcolor{gray} &  & \verb~47~ & & \verb~~\\
\cellcolor{green} & 942 & \verb~48~ & & \verb~            var staLowerLeft = new Vec2F(shape.Position.X, shape.Position.Y);~\\
\cellcolor{green} & 942 & \verb~49~ & & \verb~            var staUpperRight = new Vec2F(shape.Position.X + shape.Extent.X,~\\
\cellcolor{green} & 942 & \verb~50~ & & \verb~                shape.Position.Y + shape.Extent.Y);~\\
\cellcolor{gray} &  & \verb~51~ & & \verb~~\\
\cellcolor{gray} &  & \verb~52~ & & \verb~            // inactive movement in both x- and y-direction~\\
\cellcolor{orange} & 942 & \verb~53~ & & \verb~            if(System.Math.Abs(actor.Direction.X) < 1e-6f && System.Math.Abs(actor.Direction.Y) < 1e-6f) {~\\
\cellcolor{red} & 0 & \verb~54~ & & \verb~                return data;~\\
\cellcolor{gray} &  & \verb~55~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~56~ & & \verb~~\\
\cellcolor{gray} &  & \verb~57~ & & \verb~            // inactive movement in x-direction~\\
\cellcolor{green} & 942 & \verb~58~ & & \verb~            else if(System.Math.Abs(actor.Direction.X) < 1e-6f)~\\
\cellcolor{green} & 92 & \verb~59~ & & \verb~            {~\\
\cellcolor{gray} &  & \verb~60~ & & \verb~                float entryDistanceY, exitDistanceY;~\\
\cellcolor{green} & 92 & \verb~61~ & & \verb~                if(actor.Direction.Y < 0.0f)~\\
\cellcolor{green} & 91 & \verb~62~ & & \verb~                {~\\
\cellcolor{green} & 91 & \verb~63~ & & \verb~                    entryDistanceY = staUpperRight.Y - dynLowerLeft.Y;~\\
\cellcolor{green} & 91 & \verb~64~ & & \verb~                    exitDistanceY = staLowerLeft.Y - dynUpperRight.Y;~\\
\cellcolor{green} & 91 & \verb~65~ & & \verb~                    data.CollisionDir = CollisionDirection.CollisionDirDown;~\\
\cellcolor{green} & 91 & \verb~66~ & & \verb~                }~\\
\cellcolor{gray} &  & \verb~67~ & & \verb~                else~\\
\cellcolor{green} & 1 & \verb~68~ & & \verb~                {~\\
\cellcolor{green} & 1 & \verb~69~ & & \verb~                    entryDistanceY = staLowerLeft.Y - dynUpperRight.Y;~\\
\cellcolor{green} & 1 & \verb~70~ & & \verb~                    exitDistanceY = staUpperRight.Y - dynLowerLeft.Y;~\\
\cellcolor{green} & 1 & \verb~71~ & & \verb~                    data.CollisionDir = CollisionDirection.CollisionDirUp;~\\
\cellcolor{green} & 1 & \verb~72~ & & \verb~                }~\\
\cellcolor{gray} &  & \verb~73~ & & \verb~~\\
\cellcolor{green} & 92 & \verb~74~ & & \verb~                var entryTimeY = entryDistanceY / actor.Direction.Y;~\\
\cellcolor{green} & 92 & \verb~75~ & & \verb~                var exitTimeY = exitDistanceY / actor.Direction.Y;~\\
\cellcolor{gray} &  & \verb~76~ & & \verb~~\\
\cellcolor{orange} & 92 & \verb~77~ & & \verb~                bool xOverlaps = staUpperRight.X > dynLowerLeft.X && staLowerLeft.X < dynUpperRight.X;~\\
\cellcolor{gray} &  & \verb~78~ & & \verb~~\\
\cellcolor{green} & 92 & \verb~79~ & & \verb~                if(entryTimeY < exitTimeY && entryTimeY >= 0.0f && entryTimeY < 1.0f && xOverlaps)~\\
\cellcolor{green} & 15 & \verb~80~ & & \verb~                {~\\
\cellcolor{green} & 15 & \verb~81~ & & \verb~                    data.DirectionFactor.Y = entryTimeY;~\\
\cellcolor{green} & 15 & \verb~82~ & & \verb~                    data.Collision = true;~\\
\cellcolor{green} & 15 & \verb~83~ & & \verb~                    return data;~\\
\cellcolor{gray} &  & \verb~84~ & & \verb~                }~\\
\cellcolor{gray} &  & \verb~85~ & & \verb~                else~\\
\cellcolor{green} & 77 & \verb~86~ & & \verb~                {~\\
\cellcolor{green} & 77 & \verb~87~ & & \verb~                    return data;~\\
\cellcolor{gray} &  & \verb~88~ & & \verb~                }~\\
\cellcolor{gray} &  & \verb~89~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~90~ & & \verb~            // inactive movement in y-direction~\\
\cellcolor{orange} & 850 & \verb~91~ & & \verb~            else if(System.Math.Abs(actor.Direction.Y) < 1e-6f)~\\
\cellcolor{red} & 0 & \verb~92~ & & \verb~            {~\\
\cellcolor{gray} &  & \verb~93~ & & \verb~                float entryDistanceX, exitDistanceX;~\\
\cellcolor{red} & 0 & \verb~94~ & & \verb~                if(actor.Direction.X < 0.0f)~\\
\cellcolor{red} & 0 & \verb~95~ & & \verb~                {~\\
\cellcolor{red} & 0 & \verb~96~ & & \verb~                    entryDistanceX = staUpperRight.X - dynLowerLeft.X;~\\
\cellcolor{red} & 0 & \verb~97~ & & \verb~                    exitDistanceX = staLowerLeft.X - dynUpperRight.X;~\\
\cellcolor{red} & 0 & \verb~98~ & & \verb~                    data.CollisionDir = CollisionDirection.CollisionDirLeft;~\\
\cellcolor{red} & 0 & \verb~99~ & & \verb~                }~\\
\cellcolor{gray} &  & \verb~100~ & & \verb~                else~\\
\cellcolor{red} & 0 & \verb~101~ & & \verb~                {~\\
\cellcolor{red} & 0 & \verb~102~ & & \verb~                    entryDistanceX = staLowerLeft.X - dynUpperRight.X;~\\
\cellcolor{red} & 0 & \verb~103~ & & \verb~                    exitDistanceX = staUpperRight.X - dynLowerLeft.X;~\\
\cellcolor{red} & 0 & \verb~104~ & & \verb~                    data.CollisionDir = CollisionDirection.CollisionDirRight;~\\
\cellcolor{red} & 0 & \verb~105~ & & \verb~                }~\\
\cellcolor{gray} &  & \verb~106~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~107~ & & \verb~                float entryTimeX = entryDistanceX / actor.Direction.X;~\\
\cellcolor{red} & 0 & \verb~108~ & & \verb~                float exitTimeX = exitDistanceX / actor.Direction.X;~\\
\cellcolor{gray} &  & \verb~109~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~110~ & & \verb~                bool yOverlaps = staUpperRight.Y > dynLowerLeft.Y && staLowerLeft.Y < dynUpperRight.Y;~\\
\cellcolor{gray} &  & \verb~111~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~112~ & & \verb~                if(entryTimeX < exitTimeX && entryTimeX >= 0.0f && entryTimeX < 1.0f && yOverlaps)~\\
\cellcolor{red} & 0 & \verb~113~ & & \verb~                {~\\
\cellcolor{red} & 0 & \verb~114~ & & \verb~                    data.DirectionFactor.X = entryTimeX;~\\
\cellcolor{red} & 0 & \verb~115~ & & \verb~                    data.Collision = true;~\\
\cellcolor{red} & 0 & \verb~116~ & & \verb~                }~\\
\cellcolor{red} & 0 & \verb~117~ & & \verb~                return data;~\\
\cellcolor{gray} &  & \verb~118~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~119~ & & \verb~            // active movement in both x- and y-direction~\\
\cellcolor{gray} &  & \verb~120~ & & \verb~            else~\\
\cellcolor{green} & 850 & \verb~121~ & & \verb~            {~\\
\cellcolor{green} & 850 & \verb~122~ & & \verb~                var entryDistance = new Vec2F();~\\
\cellcolor{green} & 850 & \verb~123~ & & \verb~                var exitDistance = new Vec2F();~\\
\cellcolor{gray} &  & \verb~124~ & & \verb~~\\
\cellcolor{green} & 850 & \verb~125~ & & \verb~                if(actor.Direction.X < 0.0f)~\\
\cellcolor{green} & 138 & \verb~126~ & & \verb~                {~\\
\cellcolor{green} & 138 & \verb~127~ & & \verb~                    entryDistance.X = staUpperRight.X - dynLowerLeft.X;~\\
\cellcolor{green} & 138 & \verb~128~ & & \verb~                    exitDistance.X = staLowerLeft.X - dynUpperRight.X;~\\
\cellcolor{green} & 138 & \verb~129~ & & \verb~                }~\\
\cellcolor{gray} &  & \verb~130~ & & \verb~                else~\\
\cellcolor{green} & 712 & \verb~131~ & & \verb~                {~\\
\cellcolor{green} & 712 & \verb~132~ & & \verb~                    entryDistance.X = staLowerLeft.X - dynUpperRight.X;~\\
\cellcolor{green} & 712 & \verb~133~ & & \verb~                    exitDistance.X = staUpperRight.X - dynLowerLeft.X;~\\
\cellcolor{green} & 712 & \verb~134~ & & \verb~                }~\\
\cellcolor{green} & 850 & \verb~135~ & & \verb~                if(actor.Direction.Y < 0.0f)~\\
\cellcolor{green} & 157 & \verb~136~ & & \verb~                {~\\
\cellcolor{green} & 157 & \verb~137~ & & \verb~                    entryDistance.Y = staUpperRight.Y - dynLowerLeft.Y;~\\
\cellcolor{green} & 157 & \verb~138~ & & \verb~                    exitDistance.Y = staLowerLeft.Y - dynUpperRight.Y;~\\
\cellcolor{green} & 157 & \verb~139~ & & \verb~                }~\\
\cellcolor{gray} &  & \verb~140~ & & \verb~                else~\\
\cellcolor{green} & 693 & \verb~141~ & & \verb~                {~\\
\cellcolor{green} & 693 & \verb~142~ & & \verb~                    entryDistance.Y = staLowerLeft.Y - dynUpperRight.Y;~\\
\cellcolor{green} & 693 & \verb~143~ & & \verb~                    exitDistance.Y = staUpperRight.Y - dynLowerLeft.Y;~\\
\cellcolor{green} & 693 & \verb~144~ & & \verb~                }~\\
\cellcolor{gray} &  & \verb~145~ & & \verb~~\\
\cellcolor{green} & 850 & \verb~146~ & & \verb~                var entryTime = new Vec2F(entryDistance.X / actor.Direction.X, entryDistance.Y / actor.Direction.Y);~\\
\cellcolor{green} & 850 & \verb~147~ & & \verb~                var exitTime = new Vec2F(exitDistance.X / actor.Direction.X, exitDistance.Y / actor.Direction.Y);~\\
\cellcolor{gray} &  & \verb~148~ & & \verb~~\\
\cellcolor{green} & 850 & \verb~149~ & & \verb~                float entryTimeMax = System.Math.Max(entryTime.X, entryTime.Y);~\\
\cellcolor{green} & 850 & \verb~150~ & & \verb~                float exitTimeMin = System.Math.Min(exitTime.X, exitTime.Y);~\\
\cellcolor{gray} &  & \verb~151~ & & \verb~~\\
\cellcolor{green} & 850 & \verb~152~ & & \verb~                if(entryTimeMax < exitTimeMin && (entryTime.X >= 0.0f || entryTime.Y >= 0.0f) &&~\\
\cellcolor{green} & 850 & \verb~153~ & & \verb~                   entryTime.X < 1.0f && entryTime.Y < 1.0f)~\\
\cellcolor{green} & 3 & \verb~154~ & & \verb~                {~\\
\cellcolor{green} & 3 & \verb~155~ & & \verb~                    if (entryTime.X > entryTime.Y)~\\
\cellcolor{green} & 2 & \verb~156~ & & \verb~                    {~\\
\cellcolor{green} & 2 & \verb~157~ & & \verb~                        data.DirectionFactor.X = entryTimeMax;~\\
\cellcolor{orange} & 4 & \verb~158~ & & \verb~                        if (actor.Direction.X < 0.0f) {~\\
\cellcolor{green} & 2 & \verb~159~ & & \verb~                            data.CollisionDir = CollisionDirection.CollisionDirRight;~\\
\cellcolor{green} & 2 & \verb~160~ & & \verb~                        } else {~\\
\cellcolor{red} & 0 & \verb~161~ & & \verb~                            data.CollisionDir = CollisionDirection.CollisionDirLeft;~\\
\cellcolor{red} & 0 & \verb~162~ & & \verb~                        }~\\
\cellcolor{green} & 2 & \verb~163~ & & \verb~                    }~\\
\cellcolor{gray} &  & \verb~164~ & & \verb~                    else~\\
\cellcolor{green} & 1 & \verb~165~ & & \verb~                    {~\\
\cellcolor{green} & 1 & \verb~166~ & & \verb~                        data.DirectionFactor.Y = entryTimeMax;~\\
\cellcolor{orange} & 1 & \verb~167~ & & \verb~                        if (actor.Direction.Y < 0.0f) {~\\
\cellcolor{red} & 0 & \verb~168~ & & \verb~                            data.CollisionDir = CollisionDirection.CollisionDirUp;~\\
\cellcolor{green} & 1 & \verb~169~ & & \verb~                        } else {~\\
\cellcolor{green} & 1 & \verb~170~ & & \verb~                            data.CollisionDir = CollisionDirection.CollisionDirDown;~\\
\cellcolor{green} & 1 & \verb~171~ & & \verb~                        }~\\
\cellcolor{green} & 1 & \verb~172~ & & \verb~                    }~\\
\cellcolor{gray} &  & \verb~173~ & & \verb~~\\
\cellcolor{green} & 3 & \verb~174~ & & \verb~                    data.Collision = true;~\\
\cellcolor{green} & 3 & \verb~175~ & & \verb~                    return data;~\\
\cellcolor{gray} &  & \verb~176~ & & \verb~                }~\\
\cellcolor{gray} &  & \verb~177~ & & \verb~                else~\\
\cellcolor{green} & 847 & \verb~178~ & & \verb~                {~\\
\cellcolor{green} & 847 & \verb~179~ & & \verb~                    return data;~\\
\cellcolor{gray} &  & \verb~180~ & & \verb~                }~\\
\cellcolor{gray} &  & \verb~181~ & & \verb~            }~\\
\cellcolor{green} & 942 & \verb~182~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~183~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~184~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Timers.GameTimer}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Timers.GameTimer\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Timers/GameTimer.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 57\\
\textbf{Coverable lines:} & 57\\
\textbf{Total lines:} & 100\\
\textbf{Line coverage:} & 0\% (0 of 57)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 12\\
\textbf{Branch coverage:} & 0\% (0 of 12)\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 8\\
\textbf{Method coverage:} & 0\% (0 of 8)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{get\_CapturedUpdates(} & 100\% & 1 & 0\%\\
\hline
\textbf{get\_CapturedFrames()} & 100\% & 1 & 0\%\\
\hline
\textbf{.ctor()} & 100\% & 1 & 0\%\\
\hline
\textbf{.ctor(...)} & 0\% & 4 & 0\%\\
\hline
\textbf{MeasureTime()} & 100\% & 1 & 0\%\\
\hline
\textbf{ShouldUpdate()} & 0\% & 2 & 0\%\\
\hline
\textbf{ShouldRender()} & 0\% & 4 & 0\%\\
\hline
\textbf{ShouldReset()} & 0\% & 2 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Timers/GameTimer.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using System.Diagnostics;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~namespace DIKUArcade.Timers {~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~    public class GameTimer {~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~        private double lastTime;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~        private double timer;~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~        private double updateTimeLimit;~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~        private double renderTimeLimit;~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~        private double deltaUpdateTime;~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~        private double deltaRenderTime;~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~        private double nowTime;~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~        /// Get the last observed UPS count~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~17~ & & \verb~        public int CapturedUpdates { get; private set; }~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~        /// Get the last observed FPS count~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~21~ & & \verb~        public int CapturedFrames { get; private set; }~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~        private int updates;~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~        private int frames;~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~        private int desiredMaxFPS;~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~        private Stopwatch stopwatch;~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~30~ & & \verb~        public GameTimer() : this(30, 30) {}~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~32~ & & \verb~        public GameTimer(int ups, int fps = 0) {~\\
\cellcolor{red} & 0 & \verb~33~ & & \verb~            if (ups < 0 || fps < 0) {~\\
\cellcolor{red} & 0 & \verb~34~ & & \verb~                throw new ArgumentOutOfRangeException(~\\
\cellcolor{red} & 0 & \verb~35~ & & \verb~                    $"GameTimer must have positive count values: (ups={ups},fps={fps})");~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~37~ & & \verb~            desiredMaxFPS = fps;~\\
\cellcolor{gray} &  & \verb~38~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~39~ & & \verb~            stopwatch = new Stopwatch();~\\
\cellcolor{red} & 0 & \verb~40~ & & \verb~            stopwatch.Start();~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~42~ & & \verb~            updateTimeLimit = 1.0 / ups;~\\
\cellcolor{red} & 0 & \verb~43~ & & \verb~            renderTimeLimit = 1.0 / fps;~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~            lastTime = stopwatch.ElapsedMilliseconds / 1000.0; // elapsed seconds~\\
\cellcolor{red} & 0 & \verb~45~ & & \verb~            deltaUpdateTime = 0.0;~\\
\cellcolor{red} & 0 & \verb~46~ & & \verb~            deltaRenderTime = 0.0;~\\
\cellcolor{red} & 0 & \verb~47~ & & \verb~            nowTime = 0.0;~\\
\cellcolor{red} & 0 & \verb~48~ & & \verb~            timer = lastTime;~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~50~ & & \verb~            frames = 0;~\\
\cellcolor{red} & 0 & \verb~51~ & & \verb~            updates = 0;~\\
\cellcolor{red} & 0 & \verb~52~ & & \verb~            CapturedFrames = 0;~\\
\cellcolor{red} & 0 & \verb~53~ & & \verb~            CapturedUpdates = 0;~\\
\cellcolor{red} & 0 & \verb~54~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~55~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~56~ & & \verb~        public void MeasureTime() {~\\
\cellcolor{red} & 0 & \verb~57~ & & \verb~            nowTime = stopwatch.ElapsedMilliseconds / 1000.0;~\\
\cellcolor{red} & 0 & \verb~58~ & & \verb~            deltaUpdateTime += (nowTime - lastTime) / updateTimeLimit;~\\
\cellcolor{red} & 0 & \verb~59~ & & \verb~            deltaRenderTime += (nowTime - lastTime) / renderTimeLimit;~\\
\cellcolor{red} & 0 & \verb~60~ & & \verb~            lastTime = nowTime;~\\
\cellcolor{red} & 0 & \verb~61~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~62~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~63~ & & \verb~        public bool ShouldUpdate() {~\\
\cellcolor{red} & 0 & \verb~64~ & & \verb~            var ret = deltaUpdateTime >= 1.0;~\\
\cellcolor{red} & 0 & \verb~65~ & & \verb~            if (ret) {~\\
\cellcolor{red} & 0 & \verb~66~ & & \verb~                updates++;~\\
\cellcolor{red} & 0 & \verb~67~ & & \verb~                deltaUpdateTime--;~\\
\cellcolor{red} & 0 & \verb~68~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~69~ & & \verb~            return ret;~\\
\cellcolor{red} & 0 & \verb~70~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~71~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~72~ & & \verb~        public bool ShouldRender() {~\\
\cellcolor{red} & 0 & \verb~73~ & & \verb~            if (desiredMaxFPS < 1) {~\\
\cellcolor{red} & 0 & \verb~74~ & & \verb~                return true;~\\
\cellcolor{gray} &  & \verb~75~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~76~ & & \verb~            var ret = deltaRenderTime >= 1.0;~\\
\cellcolor{red} & 0 & \verb~77~ & & \verb~            if (ret) {~\\
\cellcolor{red} & 0 & \verb~78~ & & \verb~                frames++;~\\
\cellcolor{red} & 0 & \verb~79~ & & \verb~                deltaRenderTime--;~\\
\cellcolor{red} & 0 & \verb~80~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~81~ & & \verb~            return ret;~\\
\cellcolor{red} & 0 & \verb~82~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~83~ & & \verb~~\\
\cellcolor{gray} &  & \verb~84~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~85~ & & \verb~        /// The timer will reset if 1 second has passed.~\\
\cellcolor{gray} &  & \verb~86~ & & \verb~        /// This information can be used to update game logic in any way desireable.~\\
\cellcolor{gray} &  & \verb~87~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~88~ & & \verb~        public bool ShouldReset() {~\\
\cellcolor{red} & 0 & \verb~89~ & & \verb~            var ret = (stopwatch.ElapsedMilliseconds / 1000.0) - timer > 1.0;~\\
\cellcolor{red} & 0 & \verb~90~ & & \verb~            if (ret) {~\\
\cellcolor{red} & 0 & \verb~91~ & & \verb~                timer += 1.0;~\\
\cellcolor{red} & 0 & \verb~92~ & & \verb~                CapturedUpdates = updates;~\\
\cellcolor{red} & 0 & \verb~93~ & & \verb~                CapturedFrames = frames;~\\
\cellcolor{red} & 0 & \verb~94~ & & \verb~                updates = 0;~\\
\cellcolor{red} & 0 & \verb~95~ & & \verb~                frames = 0;~\\
\cellcolor{red} & 0 & \verb~96~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~97~ & & \verb~            return ret;~\\
\cellcolor{red} & 0 & \verb~98~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~99~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~100~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Timers.StaticTimer}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Timers.StaticTimer\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Timers/StaticTimer.cs}\end{minipage} \\
\textbf{Covered lines:} & 8\\
\textbf{Uncovered lines:} & 21\\
\textbf{Coverable lines:} & 29\\
\textbf{Total lines:} & 59\\
\textbf{Line coverage:} & 27.5\% (8 of 29)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 4\\
\textbf{Branch coverage:} & 0\% (0 of 4)\\
\textbf{Covered methods:} & 2\\
\textbf{Total methods:} & 7\\
\textbf{Method coverage:} & 28.5\% (2 of 7)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.cctor()} & 100\% & 1 & 100\%\\
\hline
\textbf{GetElapsedMillisecon} & 100\% & 1 & 100\%\\
\hline
\textbf{GetElapsedSeconds()} & 100\% & 1 & 0\%\\
\hline
\textbf{GetElapsedMinutes()} & 100\% & 1 & 0\%\\
\hline
\textbf{RestartTimer()} & 100\% & 1 & 0\%\\
\hline
\textbf{PauseTimer()} & 0\% & 2 & 0\%\\
\hline
\textbf{ResumeTimer()} & 0\% & 2 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Timers/StaticTimer.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System.Diagnostics;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~namespace DIKUArcade.Timers {~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~    /// Static timer initialized on engine startup. Can be used for~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~    /// animations based on static, discrete time intervals.~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~    public class StaticTimer {~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~        private static Stopwatch timer;~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~        private static bool paused;~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~~\\
\cellcolor{green} & 1 & \verb~13~ & & \verb~        static StaticTimer() {~\\
\cellcolor{green} & 1 & \verb~14~ & & \verb~            StaticTimer.timer = new Stopwatch();~\\
\cellcolor{green} & 1 & \verb~15~ & & \verb~            StaticTimer.timer.Start();~\\
\cellcolor{green} & 1 & \verb~16~ & & \verb~            StaticTimer.paused = false;~\\
\cellcolor{green} & 1 & \verb~17~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~        /// Get the number of elapsed milliseconds since application start~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 51 & \verb~22~ & & \verb~        public static long GetElapsedMilliseconds() {~\\
\cellcolor{green} & 51 & \verb~23~ & & \verb~            return StaticTimer.timer.ElapsedMilliseconds;~\\
\cellcolor{green} & 51 & \verb~24~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~        /// Get the number of elapsed seconds since application start~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~29~ & & \verb~        public static double GetElapsedSeconds() {~\\
\cellcolor{red} & 0 & \verb~30~ & & \verb~            return StaticTimer.timer.ElapsedMilliseconds / 1000.0;~\\
\cellcolor{red} & 0 & \verb~31~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~32~ & & \verb~~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~34~ & & \verb~        /// Get the number of elapsed minutes since application start~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~        /// <returns></returns>~\\
\cellcolor{red} & 0 & \verb~37~ & & \verb~        public static double GetElapsedMinutes() {~\\
\cellcolor{red} & 0 & \verb~38~ & & \verb~            return StaticTimer.timer.ElapsedMilliseconds / 60000.0;~\\
\cellcolor{red} & 0 & \verb~39~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~40~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~41~ & & \verb~        public static void RestartTimer() {~\\
\cellcolor{red} & 0 & \verb~42~ & & \verb~            StaticTimer.timer.Restart();~\\
\cellcolor{red} & 0 & \verb~43~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~44~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~45~ & & \verb~        public static void PauseTimer() {~\\
\cellcolor{red} & 0 & \verb~46~ & & \verb~            if (!StaticTimer.paused) {~\\
\cellcolor{red} & 0 & \verb~47~ & & \verb~                StaticTimer.timer.Stop();~\\
\cellcolor{red} & 0 & \verb~48~ & & \verb~                StaticTimer.paused = true;~\\
\cellcolor{red} & 0 & \verb~49~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~50~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~51~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~52~ & & \verb~        public static void ResumeTimer() {~\\
\cellcolor{red} & 0 & \verb~53~ & & \verb~            if (StaticTimer.paused) {~\\
\cellcolor{red} & 0 & \verb~54~ & & \verb~                StaticTimer.timer.Start();~\\
\cellcolor{red} & 0 & \verb~55~ & & \verb~                StaticTimer.paused = false;~\\
\cellcolor{red} & 0 & \verb~56~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~57~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~58~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~59~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Timers.TimePeriod}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Timers.TimePeriod\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Timers/TimePeriod.cs}\end{minipage} \\
\textbf{Covered lines:} & 8\\
\textbf{Uncovered lines:} & 8\\
\textbf{Coverable lines:} & 16\\
\textbf{Total lines:} & 30\\
\textbf{Line coverage:} & 50\% (8 of 16)\\
\textbf{Covered branches:} & 1\\
\textbf{Total branches:} & 6\\
\textbf{Branch coverage:} & 16.6\% (1 of 6)\\
\textbf{Covered methods:} & 3\\
\textbf{Total methods:} & 5\\
\textbf{Method coverage:} & 60\% (3 of 5)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{NewMilliseconds(...)} & 0\% & 2 & 0\%\\
\hline
\textbf{NewSeconds(...)} & 50.0\% & 2 & 100\%\\
\hline
\textbf{NewMinutes(...)} & 0\% & 2 & 0\%\\
\hline
\textbf{ToMilliseconds()} & 100\% & 1 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Timers/TimePeriod.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~namespace DIKUArcade.Timers {~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~    public struct TimePeriod {~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~        // A TimeSpan will internally be represented as an amount of milliseconds.~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~        private readonly System.Int64 value;~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~~\\
\cellcolor{green} & 6 & \verb~9~ & & \verb~        private TimePeriod(System.Int64 value) {~\\
\cellcolor{green} & 6 & \verb~10~ & & \verb~            this.value = value;~\\
\cellcolor{green} & 6 & \verb~11~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~13~ & & \verb~        public static TimePeriod NewMilliseconds(System.Int64 value) {~\\
\cellcolor{red} & 0 & \verb~14~ & & \verb~            if (value < 0) { throw new System.ArgumentOutOfRangeException("value cannot be negative."); }~\\
\cellcolor{red} & 0 & \verb~15~ & & \verb~            return new TimePeriod(value);~\\
\cellcolor{red} & 0 & \verb~16~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~~\\
\cellcolor{green} & 6 & \verb~18~ & & \verb~        public static TimePeriod NewSeconds(System.Double value) {~\\
\cellcolor{orange} & 6 & \verb~19~ & & \verb~            if (value < 0.0) { throw new System.ArgumentOutOfRangeException("value cannot be negative."); }~\\
\cellcolor{green} & 6 & \verb~20~ & & \verb~            return new TimePeriod((System.Int64)System.Math.Floor(value * 1000));~\\
\cellcolor{green} & 6 & \verb~21~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~23~ & & \verb~        public static TimePeriod NewMinutes(System.Double value) {~\\
\cellcolor{red} & 0 & \verb~24~ & & \verb~            if (value < 0.0) { throw new System.ArgumentOutOfRangeException("value cannot be negative."); }~\\
\cellcolor{red} & 0 & \verb~25~ & & \verb~            return new TimePeriod((System.Int64)System.Math.Floor(value * 60000));~\\
\cellcolor{red} & 0 & \verb~26~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~~\\
\cellcolor{green} & 200 & \verb~28~ & & \verb~        public System.Int64 ToMilliseconds() => value;~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Utilities.FileIO}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Utilities.FileIO\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Utilities/FileIO.cs}\end{minipage} \\
\textbf{Covered lines:} & 9\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 9\\
\textbf{Total lines:} & 23\\
\textbf{Line coverage:} & 100\% (9 of 9)\\
\textbf{Covered branches:} & 2\\
\textbf{Total branches:} & 2\\
\textbf{Branch coverage:} & 100\% (2 of 2)\\
\textbf{Covered methods:} & 1\\
\textbf{Total methods:} & 1\\
\textbf{Method coverage:} & 100\% (1 of 1)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{GetProjectPath()} & 100\% & 2 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Utilities/FileIO.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~namespace DIKUArcade.Utilities {~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~    public class FileIO {~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~        /// Return the platform-specific path of the current project directory~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~        /// <returns></returns>~\\
\cellcolor{green} & 1 & \verb~10~ & & \verb~        public static string GetProjectPath() {~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~            // find base path~\\
\cellcolor{green} & 1 & \verb~12~ & & \verb~            var dir = new DirectoryInfo(Path.GetDirectoryName(~\\
\cellcolor{green} & 1 & \verb~13~ & & \verb~                System.Reflection.Assembly.GetExecutingAssembly().Location));~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~~\\
\cellcolor{green} & 5 & \verb~15~ & & \verb~            while (dir.Name != "bin") {~\\
\cellcolor{green} & 2 & \verb~16~ & & \verb~                dir = dir.Parent;~\\
\cellcolor{green} & 2 & \verb~17~ & & \verb~            }~\\
\cellcolor{green} & 1 & \verb~18~ & & \verb~            dir = dir.Parent;~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~~\\
\cellcolor{green} & 1 & \verb~20~ & & \verb~            return dir.FullName.ToString();~\\
\cellcolor{green} & 1 & \verb~21~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Utilities.RandomGenerator}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Utilities.RandomGenerator\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Utilities/RandomGenerator.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 6\\
\textbf{Coverable lines:} & 6\\
\textbf{Total lines:} & 13\\
\textbf{Line coverage:} & 0\% (0 of 6)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 2\\
\textbf{Branch coverage:} & 0\% (0 of 2)\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 2\\
\textbf{Method coverage:} & 0\% (0 of 2)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{get\_Generator()} & 100\% & 1 & 0\%\\
\hline
\textbf{.cctor()} & 0\% & 2 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{student/SU23Guest/DIKUGames/DIKUArcade/DIKUArcade/Utilities/RandomGenerator.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~namespace DIKUArcade.Utilities {~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~    public class RandomGenerator {~\\
\cellcolor{red} & 0 & \verb~5~ & & \verb~        public static Random Generator { get; private set; }~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~7~ & & \verb~        static RandomGenerator() {~\\
\cellcolor{red} & 0 & \verb~8~ & & \verb~            if (RandomGenerator.Generator == null) {~\\
\cellcolor{red} & 0 & \verb~9~ & & \verb~                RandomGenerator.Generator = new Random();~\\
\cellcolor{red} & 0 & \verb~10~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~11~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~}~\\
\end{longtable}
\end{document}